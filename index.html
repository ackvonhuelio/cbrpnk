<!DOCTYPE html>
<!--Credit to vexcess for pjs in html script which i copied -->
<html>

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
        <title>CBRPNK</title>
        <style>
            :root {
                --background-color: #000000;
            }

            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0px;
                padding: 0px;
                background-color: var(--background-color);
                display: flex;
                justify-content: center;
                align-items: center;
            }

            #wrapper {
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            canvas {
                position: absolute;
                transform-origin: center;
            }
        </style>
    </head>
    <body id="wrapper">
    <!-- jquery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- jQuery plugin file -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.4.1/jquery.timeago.min.js"></script>
    <script id="PJS_code" type="data" data-width="600" data-height="600">
    /**

     _____ ____  _____  _____  _   _ _  __
    / ____|  _ \|  __ \|  __ \| \ | | |/ /
   | |    | |_) | |__) | |__) |  \| | ' / 
   | |    |  _ <|  _  /|  ___/| . ` |  <  
   | |____| |_) | | \ \| |    | |\  | . \ 
    \_____|____/|_|  \_\_|    |_| \_|_|\_\
                
     - Full-size Roguelike Deckbuilder 
     (Possibly the first on KA)
     
     - Intuitive, smooth, and ultra user-friendly UI
     - 77 Unique Cards
     - 40 Unique Enemies
     
     
     
     
    
     - Ackvonhey's slay the spire clone
     - Made in 2 weeks for CoC
     (I ripped numbers directly from STS to meet deadline)
     
     subpage for future cool stuff:
https://www.khanacademy.org/computer-programming/subpage/5430441814310912

**/

/** 
    Is the game too hard, or not hard enough?
    Change some of these numbers!
    
**/
    var AVG_ENEMY_CREDITS_REWARD = 30;
    var NUM_REWARD_CARD_OPTIONS = 3;
    var BASE_RARE_CHANCE_PERCENT = 3;
    var PLAYER_MAX_INTEGRITY = 100;
    var PLAYER_HANDSIZE = 5;
    var STARTING_CREDITS = 50;
    // *Make sure to restart the program after changing anything

/**

    Most of the game is pretty easy to learn
    
    BUT here's how the game works in depth.
    
    ------------------------------

HOW PROGRESSION WORKS

Each game played is independent of others. 
    
The game is divided into 3 towers, each with 15 procedurally generated floors and one boss floor at the top.

Your goal is to make it through all 48 floors, constructing a deck that continuously gets more powerful along the way.

Each floor can have 1-3 options. You pick exactly ONE option per floor and then progress to the next floor. Here are the options:

FIGHT: You must defeat a random selection of enemies with your deck. Enemies get stronger as the game progresses. When you win, you gain some credits and can add a card to your deck.

REST: Either heal your player to the max or upgrade a card in your deck. No more than two rest options will ever be present in a row.

MERCHANT: Spend credits to buy cards for your deck, remove cards from your deck, or rest. A merchant will never be offered twice in a row.

BOSS: Only present at the top floor of each tower. A very difficult fight. There will always be a REST option right before the boss.

    ------------------------------
    
HOW CARDS WORK

You have a deck that consists of any number of cards. Your deck can be viewed at pretty much any time during the game.

Each card has the following properties:

NAME - Each card has a unique name

COST - An energy cost from 0 to 3

RARITY - Either common, uncommon or rare. Shown by the upper color of the card (gray, blue, or yellow-ish). Rare cards are usually better and... rarer

LEVEL - A card has a level from 1 to 3, shown by the bar that fills up underneath the card name. Upgrading a card increases its level. Some cards only go up to level 2.

EFFECT - What the card does. The effect gets more powerful as the card increases levels.

TYPE - Either Hack, Program or Cyberware.
Hack - does damage
Program - does something else
Cyberware - sticks around when played, has a permanent effect

Malware - special card type for bad cards (added by some enemies)

    ------------------------------
    
HOW FIGHTS WORK

**IMPORTANT**: When you enter a fight, your deck is CLONED. Everything that happens to cards in a fight is temporary. So, if a card says "delete this card", it is only deleted for THAT FIGHT.

Combat is turn-based. It always starts on your turn.

Cards start off in a DRAW pile. At the beginning of your turn, some number of cards are drawn into your HAND. 
When cards are played or are in your hand at the end of your turn, they are put into your DISCARD.

When your DRAW runs out, your DISCARD is shuffled and put into your DRAW. So, you have an infinite cycle of cards.


During your turn, you get 3 Energy. You can use this energy to play cards from your hand for their energy costs. 
When you are done and press END TURN, it becomes the enemy turn.

Enemies will take turns attacking you on their turn. What they will do on their turn is always known to you, hover over an enemy to see its intent. 

When enemies are done attacking, it becomes your turn again.

The fight ends when you defeat all enemies by reducing their Integrities to 0, or when you are defeated.

    ------------------------------
    
HOW VARIOUS MECHANICS WORK

Defense - If you have defense, damage is dealt to your defense before your Integrity. You lose all defense at the start of your turn.
* if something says "Remove Integrity", it gets around defense

Effects - Various cards and enemy attacks cause the player and enemies to gain effects, both good and bad. Effects do varying things - exactly what is done can be seen by hovering over and clicking whoever is affected.
Some enemies start fights with effects.
Pay attention to what effects are present!

Cyberware - Cyberware cards are special. When played, they do not go to your discard like other cards, instead, they go above the player and have a continuous effect.

Malware - Many enemies add bad MALWARE type cards to your draw and discard. These cards are not permanent, they will only last for that battle.

Upgrading - A card can only be upgraded if it is not at its maximum level. Upgrading different cards does different things, from increasing damage to reducing cost to making the card always appear in your first hand. Upgrading a card always makes it better.

Boss Fight - A boss is one enemy that is very strong. Expect to lose most runs from boss fights. When you defeat a boss, in addition to gaining 75 credits, you choose from 4 rare cards to add to your deck.

Rarity - Cards always have a 37 percent change of being uncommon. The percent chance for a rare card is equal to the Base rarity chance + Rare chance modifier. The Rare chance modifier starts at -5 and increases by 1 whenever a common card is offered. The Base rarity chance is 3 for fights and 9 for the merchant. The remaining percentage is the chance for a common card.

**/

/**

CREDITS

Slay the Spire for lots of numbers and ideas
(I was NOT gonna balance a game on my own within two weeks)

Bob Lyon for the scroll lock fix

Arrow for the new keyword fix

Ackvonhey (sometime within the last several years) for basic functions like capitalize, shuffleArray, and the basic structure for the button constructor. Also a basic graphics tool which was only used for the game title and fire.

Ackvonhey (past two weeks) for all the other code

**/

var msx = 0;
var msy = 0;

function getTrueMouse(){
var window = (function(what) { return this[what]; })("window");
var scaleFactor = window.scaleFactor;
return {
x:(mouseX-300)/scaleFactor + 300,
y:(mouseY-300)/scaleFactor + 300,
};
}

// base settings for text
textFont(createFont("monospace"));
textAlign(CENTER, BASELINE);

/**
 * Shuffles an array
 * @param {Array} e - array to be shuffled
 * @returns {Array} Shuffled array
 * @example
 * var a = shuffleArray([1,2,3,4,5]); 
 * -> [5,2,3,1,4] or some other random order
 */
function shuffleArray(e) {
    var sra = [];
    var ea = [];
    for(var q = 0; q < e.length; q++) {
        ea.push(e[q]);
    }
    for(var i = 0; i < e.length; i++) {
        var sn = round(random(0, ea.length - 1));
        sra.push(ea[sn]);
        ea.splice(sn, 1);
    }
    return (sra);
}

/*
    Cache for words that are run through captialize()
*/
var capitalizedCache = {};

/**
 * Properly capitalizes a string
 * @param {String} s - string to be capitalized
 * @returns {String} capitalized string
 * @example
 * var a = capitalize("im a dummy");
 * -> "Im A Dummy"
 */
function capitalize(s) {
    //return s;
    if(capitalizedCache[s]) {
        return capitalizedCache[s];
    }
    var ret = "";
    for(var i = 0; i < s.length; i++) {
        if(i === 0 || (i > 0 && s[i - 1] === " ")) {
            ret += s[i].toUpperCase();
        } else {
            ret += s[i];
        }
    }
    capitalizedCache[s] = ret;
    return ret;
}


/*
    Variables that store mouse inputs
*/
var clicked = false;
var rclicked = false;
var mclicked = false;

// Current scene to display
var scene = "menu";

// Current enemies
var enemies = [];

// Options for the selection screen
var selection = [];

// Stores the selected option
var selected = false;

// Stores the previous scene when the selection scene is opened
var selectionBackTo = "fight";

// The caption for the selection scene
var selectionCaption = "Select SOMETHING";

// Whether or not something is being selected
var noSelection = false;

/**
 * Properly initiates the selection scene
 * @param {Boolean} keepSelection - whether or not the options should be reset upon calling the function
 */
function queueSelection(keepSelection) {
    selectionBackTo = scene;
    scene = "selection";
    if(!keepSelection) {
        selection = [];
    }
    selected = false;
    noSelection = false;
    selectionCaption = "Select";
}

/**
 * A weighted option entry
 * @typedef {[any, number]} WeightedOption
 * The first element is the value.
 * The second element is the weight.
 */
/**
 * Selects a random value based on weighted probabilities.
 * @param {WeightedOption[]} options - Array of [value, weight] pairs.
 * @returns {any} A randomly selected value, weighted by probability.
 *
 * @example
 * var randomChoice = manageProbablities([
 *   ["possibility 1", 20],
 *   [2, 80],
 *   [anotherPossibility, 40]
 * ])
 */
function manageProbabilities(options) {
    var totalWeight = 0;
    for(var i = 0; i < options.length; i++) {
        totalWeight += options[i][1];
    }
    var r = random(0, totalWeight);

    for(var i = 0; i < options.length; i++) {
        r -= options[i][1];
        if(r < 0) {
            return options[i][0];
        }
    }

    // fallback
    return options[0][0];
}

// stores a snapshot of the screen when some scenes are changed
var snapshotBg = get();

// stores info regarding the mouse
var m = {
    hold: false,
    px: msx,
    py: msy,
};

/**
 * Whether or not the mouse has moved since last frame
 * @returns {Boolean} if the mouse has moved
 */
function mouseHasMoved() {
    return m.px !== msx || m.py !== msy;
}

/**
 * Whether or not the player has prompted for the picking up of a card through mouse actions
 * @returns {Boolean} if the player is trying to pick up a card
 */
function selectInput() {
    if(clicked || (mouseHasMoved() && mouseIsPressed)) {
        if(clicked) {
            clicked = false;
        }
        return true;
    }
}

/**
 * A button
 * @constructor
 * @param {number} x - x position
 * @param {number} y - y position
 * @param {number} w - hitbox width
 * @param {number} h - hitbox height
 */
function button(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.anim = 0;
    this.lastDrawn = 0;
}
/**
 * Draws the button and manages user input
 */
button.prototype.draw = function() {

    if(frameCount > this.lastDrawn + 1 && !this.saveAnim) {
        this.anim = 0;
    }
    this.lastDrawn = frameCount;

    if(msx >= this.x - this.w / 2 && msx <= this.x + this.w / 2 && msy >= this.y - this.h / 2 && msy < this.y + this.h / 2) {
        cursor(HAND);
        if(clicked) {
            if(this.onClick) {
                this.onClick();
            }
            clicked = false;
        }
        this.anim = lerp(this.anim, 1, 0.1);
        this.hovered = true;
    } else {
        this.anim = lerp(this.anim, 0, 0.1);
        this.hovered = false;
    }

    if(this.art) {
        pushMatrix();
        translate(this.x, this.y);
        this.art(this.anim);
        popMatrix();
    }
};

/**
 * Draws a cool fire graphic
 * @param {color} c1 - outer color
 * @param {color} c2 - middle color
 * @param {color} c3 - inner color
 */
function fire(c1, c2, c3) {
    pushMatrix();

    translate(-15, -17);
    scale(0.05);
    fill(c1);
    beginShape();
    vertex(323, 67);
    vertex(311, 103);
    vertex(328, 141);
    vertex(384, 194);
    vertex(394, 252);
    vertex(372, 303);
    vertex(388, 331);
    vertex(398, 332);
    vertex(410, 314);
    vertex(395, 292);
    vertex(426, 312);
    vertex(447, 358);
    vertex(450, 403);
    vertex(431, 443);
    vertex(386, 483);
    vertex(319, 499);
    vertex(253, 492);
    vertex(199, 466);
    vertex(163, 419);
    vertex(148, 348);
    vertex(152, 301);
    vertex(200, 223);
    vertex(208, 256);
    vertex(235, 274);
    vertex(258, 254);
    vertex(256, 217);
    vertex(239, 183);
    vertex(241, 143);
    vertex(265, 102);
    endShape(CLOSE);
    noStroke();
    fill(c2);
    beginShape();
    vertex(302, 216);
    vertex(296, 241);
    vertex(305, 269);
    vertex(322, 295);
    vertex(347, 323);
    vertex(354, 366);
    vertex(356, 379);
    vertex(377, 387);
    vertex(387, 377);
    vertex(390, 375);
    vertex(395, 356);
    vertex(406, 385);
    vertex(405, 421);
    vertex(390, 460);
    vertex(351, 491);
    vertex(326, 501);
    vertex(273, 498);
    vertex(249, 488);
    vertex(217, 453);
    vertex(201, 397);
    vertex(205, 364);
    vertex(218, 331);
    vertex(229, 350);
    vertex(251, 353);
    vertex(271, 341);
    vertex(280, 303);
    vertex(281, 259);
    vertex(285, 239);
    endShape(CLOSE);
    fill(c3);
    beginShape();
    vertex(275, 429);
    vertex(267, 403);
    vertex(277, 369);
    vertex(305, 331);
    vertex(300, 363);
    vertex(311, 386);
    vertex(326, 397);
    vertex(346, 419);
    vertex(355, 440);
    vertex(353, 473);
    vertex(337, 490);
    vertex(319, 501);
    vertex(280, 499);
    vertex(254, 479);
    vertex(241, 450);
    vertex(239, 410);
    vertex(260, 428);
    endShape(CLOSE);
    popMatrix();
}

// cards that are queued
var stack = [];
// attacks that are queued
var attacks = [];
// timer for resolving the stack and attacks
var stackTimer = 0;

// stores cards that are being animated as discarded
var discarding = [];
// stores cards that are being animated as added to the draw pile
var drawAdding = [];

// stores info regarding the player
var player = {
};


/**
 * Calculates the damage that would be dealt
 * @param {Object} card - the source of the damage
 * @param {Object} target - the target for the damage
 * @param {Object} enemy - the enemy that is providing the source of damage
 * @returns {number} the amount of damage that would be dealt
 */
function calculateDamage(card, target, enemy) {
    var amount = 0;
    var weak = (enemy) ? enemy.effects.weak : player.effects.weak;
    var strength = (enemy) ? enemy.effects.strength : player.effects.strength;
    if(card.identifier && card.identifier === 'card' && target === player) {
        strength = 0;
    }
    if(card.data) {
        amount = card.data.damage(card, target);
    } else {
        amount = card.damage(card, target, enemy);
    }
    if(strength) {
        amount += strength;
    }
    if(weak) {
        amount *= 0.75;
    }
    if(target.effects.vulnerable) {
        amount *= 1.5;
    }
    return constrain(floor(amount), 0, 999);
}

/**
 * Calculates the defense that would be gained
 * @param {Object} card - the source of the gain
 * @param {Object} target - the target for the gain
 * @returns {number} the amount of defense that would be gained
 */
function calculateDefense(card, target) {
    var amount = 0;
    if(card.data) {
        amount = card.data.defense(card, target);
    } else {
        amount = card.defense(card, target);
    }
    if(target.effects.frail) {
        amount *= 0.75;
    }
    return floor(amount);
}

/**
 * Actuates defense gain
 * @param {Object} card - the source of the gain
 * @param {Object} target - the target for the gain
 */
function normalDefend(card, target) {
    var amount = calculateDefense(card, target);
    managePowers(target, "defended", {
        amount: amount
    });
    target.defense += amount;
    if(target === player) {
        player.dy += 20;
    }
    target.shieldAnim = 1;
}

/**
 * Actuates damage dealing
 * @param {Object} card - the source of the damage
 * @param {Object} target - the target for the damage
 * @param {Object} enemy - the enemy that is providing the source of damage
 */
function normalDamage(card, target, enemy) {

    var amount = calculateDamage(card, target, enemy);
    if(amount >= target.defense) {
        amount -= target.defense;
        target.defense = 0;
    } else {
        target.defense -= amount;
        amount = 0;
    }

    target.integrity -= floor(amount);
    if(amount > 0) {
        target.shake = 10;
        if(amount >= 15) {
            target.shake = 18;
        }
        if(amount >= 25) {
            target.shake = 26;
        }
    }
    managePowers(target, "attacked", {
        attacker: enemy || player,
        amount: amount,
        card: card
    });
    if(enemy) {
        managePowers(enemy, "attacks", {
            amount: amount,
            card: card
        });
    } else {
        player.dx += 50;
    }

}

/**
 * Actuates draining (defense is ignored)
 * @param {Object} card - the source of the damage
 * @param {Object} target - the target for the damage
 * @param {Object} amount - how much is being drained
 */
function normalDrain(card, target, amount) {

    managePowers(target, "drain", {
        card: card,
        amount: amount
    });
    target.integrity -= amount;
}

// stores the names of all[whatever it says] in the game
var allTypes = [];
var allEnemies = [];
var allSpecialEffects = [];

/**
 * Applies an effect, modifing the effects property of the target. Takes into account the "artifact" effect, which negates effects.
 * @param {String} effect - the name of the effect
 * @param {number} amount - the amount of the effect added
 * @param {Object} target - the receiver of the effect
 */
function applyEffect(effect, amount, target) {
    if(effect === "artifact" || !target.effects.artifact) {
        if(target.effects[effect]) {
            target.effects[effect] += amount;
        } else {
            target.effects[effect] = amount;
        }
    } else {
        target.effects.artifact -= 1;
    }
}

/**
 * Actuates the upgrading of a card
 * @param {Object} card - the card to be upgrade 1 level
 */
function upgradeCard(card) {

    card.level++;
    card.level = constrain(card.level, 0, 2);
    card.cost = card.data.baseCost(card);
}

// stores cards that are deleted throughout the fight
var deleted = [];

/**
 * Actuates deleting of a card
 * @param {Object} card - the card to be deleted
 */
function deleteCard(card) {
    if(!card.FAKE) {
        deleted.push(card);
    }
    if(stack.indexOf(card) > 0) {
        stack.splice(stack.indexOf(card), 1);
    }
    if(card.data.deleted) {
        card.data.deleted(card);
    }
    managePowers(player, "cardDeleted", {
        card: card
    });
}


// stores all the cards of each rarity type
var rarityData = {
    "basic": [],
    "common": [],
    "uncommon": [],
    "rare": [],
    "MALWARE": [],
};


/**
 * Stores all the data for each card
 * 
 * @typeDef {Object} cardData
 * @property {String} type - the type of card
 * @property {String} rarity - the rarity of the card
 * @property {number} nameTextSize - if present, the size at which the name of the card should be drawn
 * @property {Boolean} noTarget - if the card is played without targeting an enemy
 * @property {Function} baseCost - returns the cost of the card
 *      @param {Object} card - the card
 *      @returns {number} the cost
 * @property {Function} condition - returns whether or not the card can be played
 *      @param {card} card - the card
 *      @returns {Boolean} if the card can be played
 * @property {Function} description - a description of what the card does
 *      @param {Object} card - the card
 *      @returns {String} - a description
 * @property {Function} unused - what happens if the card is not used
 *      @param {Object} card - the card
 * @property {Function} damage - returns the amount of damage the card deals
 *      @param {Object} card - the card
 * @property {Function} defense - returns the amount of defense the card grants
 *      @param {Object} card - the card
 * @property {Array} effect - a list of functions that are called, in order, when the card is played. The functions are passed the @param {Object} card - the card
 */
var cardData = {
    "null": {
        type: "MALWARE",
        rarity: "MALWARE",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        condition: function(card) {
            return false;
        },
        description: function(card) {
            return "Unplayable";
        },
        effect: [
            function(card) {

            },
        ],
    },
    "NaN": {
        type: "MALWARE",
        rarity: "MALWARE",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        condition: function(card) {
            return false;
        },
        damage: function(card) {
            return 2;
        },
        unused: function(card) {
            normalDamage(card, player);
        },
        description: function(card) {
            return "Unplayable. Take 2 damage when discarded";
        },
        effect: [
            function(card) {

            },
        ],
    },
    "undefined": {
        type: "MALWARE",
        rarity: "MALWARE",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        condition: function(card) {
            return false;
        },
        description: function(card) {
            return "Unplayable.\nDelete this card if not used";
        },
        unused: function(card) {
            if(player.discard.indexOf(card) >= 0) {
                deleteCard(card);
                player.discard.splice(player.discard.indexOf(card), 1);
            }
        },
        effect: [
            function(card) {

            },
        ],
    },
    "slime": {
        type: "MALWARE",
        rarity: "MALWARE",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 1;
        },
        description: function(card) {
            return "Delete this card";
        },
        effect: [
            function(card) {

            },
        ],
    },

    "firewall": {
        type: "program",
        rarity: "basic",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 5 + 3 * card.level;
        },
        description: function(card) {
            return "Gain " + card.data.defense(card) + " defense";
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
        ],
    },
    "spike": {
        type: "hack",
        rarity: "basic",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 6 + 3 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
        ],
    },
    "shellshock": {
        type: "hack",
        rarity: "basic",
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 8 + 2 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Apply " + (2 + card.level) + " Vulnerable";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                applyEffect("vulnerable", 2 + card.level, card.target);
            },
        ],
    },

    // hacks
    "fork bomb": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 0;
        },
        damage: function(card, target) {
            return 6 + 2 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Add a copy of this card to your discard";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                var card2 = new cardObj("fork bomb", card.level);
                card2.cost = card.cost;
                discarding.push(card2);
                player.discard.push(card2);
            }
        ],
    },
    "flood": {
        type: "hack",
        rarity: "common",
        onlyOneUpgrade: true,
        baseCost: function(card) {
            if(card.level > 0) {
                return 0;
            }
            return 1;
        },
        damage: function(card, target) {
            return player.defense;
        },
        description: function(card) {
            return "Deal damage equal to your defense";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
        ],
    },
    "execution spike": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 0;
        },
        damage: function(card, target) {
            return 14 + 4 * card.level;
        },
        condition: function(card) {
            for(var i = 0; i < player.hand.length; i++) {
                if(player.hand[i].data.type !== "hack") {
                    return false;
                }
            }
            return true;
        },
        description: function(card) {
            return "Can only be played if every card in your hand is a Hack. (" + card.data.condition(card) + ") Deal " + card.data.damage(card) + " damage";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
        ],
    },
    "detonate": {
        type: "hack",
        rarity: "common",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 8 + 3 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage to ALL enemies";
        },
        effect: [
            function(card) {
                for(var i = 0; i < enemies.length; i++) {
                    normalDamage(card, enemies[i]);
                }
            },
        ],
    },
    "overflow": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 12 + 2 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Apply " + (2 + card.level) + " Weak";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                applyEffect("weak", 2 + card.level, card.target);
            },
        ],
    },
    "rupture": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 9 + 3 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Put a card from your discard on top of your draw";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                if(player.discard.length > 0) {

                    queueSelection();
                    selectionCaption = "Select a card to put on top of your draw";

                    for(var i = 0; i < player.discard.length; i++) {
                        selection.push(player.discard[i]);
                    }
                }
            },
            function(card) {
                if(selected) {
                    if(player.discard.indexOf(selected) >= 0) {
                        player.draw.splice(0, 0, selected);
                        drawAdding.push(selected);
                        player.discard.splice(player.discard.indexOf(selected), 1);
                    }
                }
            },
        ],
    },
    "crash": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 14;
        },
        description: function(card) {
            return "Temporarily gain " + (3 + 2 * card.level) + "X strength. Deal " + card.data.damage(card) + " damage.";
        },
        effect: [
            function(card) {
                if(player.effects.strength) {
                    card.counter = (player.effects.strength * (3 + 2 * card.level)) - player.effects.strength;
                }
                player.effects.strength += card.counter;
            },
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                if(player.effects.strength && card.counter) {
                    player.effects.strength -= card.counter;
                }
            },
        ],
    },
    "hijack": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 5 + 2 * card.level;
        },
        defense: function(card, target) {
            return 5 + 2 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Gain " + card.data.defense(card) + " defense";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                normalDefend(card, player);
            },
        ],
    },
    "pulse": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 9 + 1 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Draw " + (1 + card.level) + " card" + ((card.level > 0) ? "s" : "");
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                for(var i = 0; i < 1 + card.level; i++) {
                    drawCard();
                }
            },
        ],
    },
    "recursive call": {
        type: "hack",
        rarity: "common",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 3;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage to a random enemy " + (card.level + 3) + " times";
        },
        effect: [
            function(card) {
                card.counter = 0;
                stackTimer += 450;
            },
            function(card) {
                card.counter++;
                normalDamage(card, enemies[floor(random(0, enemies.length))]);
                stackTimer += 200;
                if(card.counter < card.level + 3) {
                    card.animStep--;
                }
            },
        ],
    },
    "breach": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 4 + 3 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Apply 1 Vulnerable to ALL enemies";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                for(var i = 0; i < enemies.length; i++) {
                    applyEffect("vulnerable", 1, enemies[i]);
                }
            },
        ],
    },
    "stack smash": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 5 + 2 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage, twice";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                normalDamage(card, card.target);
            },
        ],
    },
    "bruteforce loop": {
        type: "hack",
        rarity: "common",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 12 + 5 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Put a Null card on top of your draw.";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                var card2 = new cardObj("null", 0);
                drawAdding.push(card2);
                player.draw.splice(0, 0, card2);
            },
        ],
    },
    "deadlock trigger": {
        type: "hack",
        rarity: "uncommon",
        nameTextSize: 8.5,
        baseCost: function(card) {
            return constrain((4 - card.level) - floor((player.maxIntegrity - player.integrity) / 10), 0, 4);
        },
        staticHandEffect: function(card) {
            card.cost = card.data.baseCost(card);
        },
        damage: function(card, target) {
            return 18 + 4 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Costs 4 energy minus 1 energy for each 10 integrity missing";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
        ],
    },
    "timing attack": {
        type: "hack",
        rarity: "uncommon",
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 20 + 8 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Delete this card if not used";
        },
        unused: function(card) {
            if(player.discard.indexOf(card) >= 0) {
                deleteCard(card);
                player.discard.splice(player.discard.indexOf(card), 1);
            }
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
        ],
    },
    "exploit": {
        type: "hack",
        rarity: "uncommon",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 5 + 3 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. If the enemy is Vulnerable, gain 1 energy and draw a card";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
                if(!card.target.effects.vulnerable) {
                    stackTimer += 500;
                }
            },
            function(card) {
                if(card.target.effects.vulnerable) {
                    drawCard();
                    player.energy++;
                }
            },
        ],
    },
    "meltdown": {
        type: "hack",
        rarity: "uncommon",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 15 + 5 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Lose 2 integrity";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                normalDrain(card, player, 2);
            },
        ],
    },
    "segfault barrage": {
        type: "hack",
        rarity: "uncommon",
        nameTextSize: 8.5,
        exhaust: true,
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 2;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage,\n" + (card.level + 4) + " times.\nDelete this card";
        },
        effect: [
            function(card) {
                card.counter = 0;
                stackTimer += 450;
            },
            function(card) {
                card.counter++;
                normalDamage(card, card.target);
                stackTimer += 200;
                if(card.counter < card.level + 4) {
                    card.animStep--;
                }
            },
        ],
    },
    "phantom write": {
        type: "hack",
        rarity: "uncommon",
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            if(card.counter) {
                return 8 + card.counter;
            }
            return 8;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Increase this card's damage by " + (card.level * 3 + 5) + " this combat";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                if(!card.counter) {
                    card.counter = 0;
                }
                card.counter += (card.level * 3 + 5);
                card.counter = round(card.counter);
            },
        ],
    },
    "undefined behavior": {
        type: "hack",
        rarity: "uncommon",
        nameTextSize: 8,
        baseCost: function(card) {
            return 0;
        },
        damage: function(card, target) {
            return 7 + 3 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Put an Undefined card on top of your draw.";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                var card2 = new cardObj("undefined", 0);
                drawAdding.push(card2);
                player.draw.splice(0, 0, card2);
            },
        ],
    },
    "malicious patch": {
        type: "hack",
        rarity: "uncommon",
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 16 + 6 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Delete all non-Hack cards in your hand";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                for(var i = player.hand.length - 1; i > -1; i--) {
                    if(player.hand[i].data.type !== "hack") {
                        deleteCard(player.hand[i]);
                        player.hand.splice(i, 1);
                    }
                }
            },
        ],
    },
    "corrupt": {
        type: "hack",
        rarity: "uncommon",
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 13;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. Apply " + (1 + card.level) + " weak and " + (1 + card.level) + " Vulnerable";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
            function(card) {
                applyEffect("vulnerable", 1, card.target);
                applyEffect("weak", 1, card.target);
            },
        ],
    },
    "buffer overflow": {
        type: "hack",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        damage: function(card, target) {
            return 5 + 3 * card.level;
        },
        description: function(card) {
            return "Uses all energy. Deal " + card.data.damage(card) + " damage to ALL enemies, once for each energy";
        },
        effect: [
            function(card) {
                card.counter = 0;
                card.maxCounter = player.energy;
                player.energy = 0;
            },
            function(card) {
                card.counter++;
                for(var i = 0; i < enemies.length; i++) {
                    normalDamage(card, enemies[i]);
                }
                stackTimer += 100;
                if(card.counter < card.maxCounter) {
                    card.animStep--;
                }
            },
        ],
    },
    "fry": {
        type: "hack",
        rarity: "rare",
        baseCost: function(card) {
            return 3;
        },
        damage: function(card, target) {
            return 32 + 10 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
            },
        ],
    },
    "backdoor install": {
        type: "hack",
        rarity: "rare",
        nameTextSize: 8.5,
        exhaust: true,
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 10 + 2 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage. If it is fatal, raise your max integrity by " + (3 + card.level) + ". Delete this card.";
        },
        effect: [
            function(card) {
                normalDamage(card, card.target);
                if(card.target.integrity <= 0) {
                    player.maxIntegrity += 3;
                    player.integrity += 3;
                }
            },
        ],
    },
    "firmware breach": {
        type: "hack",
        rarity: "rare",
        exhaust: true,
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 7 + 3 * card.level;
        },
        description: function(card) {
            return "Delete all cards in your hand. Deal " + card.data.damage(card) + " damage for each card deleted. Delete this card";
        },
        effect: [
            function(card) {
                card.counter = 0;
                card.maxCounter = player.hand.length;
                var deleting = [];
                for(var i = 0; i < player.hand.length; i++) {
                    deleting.push(player.hand[i]);
                }
                player.hand = [];
                for(var i = 0; i < deleting.length; i++) {
                    deleteCard(deleting[i]);
                }
            },
            function(card) {
                if(card.maxCounter > 0) {
                    card.counter++;
                    normalDamage(card, card.target);
                    stackTimer += 100;
                    if(card.counter < card.maxCounter) {
                        card.animStep--;
                    }
                }
            },
        ],
    },
    "logic bomb": {
        type: "hack",
        rarity: "rare",
        noTarget: true,
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 21 + 7 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage to ALL enemies. Add a NaN card to your discard";
        },
        effect: [
            function(card) {
                for(var i = 0; i < enemies.length; i++) {
                    normalDamage(card, enemies[i]);
                }
            },
            function(card) {
                var card2 = new cardObj("NaN", 0);
                discarding.push(card2);
                player.discard.push(card2);
            },
        ],
    },
    "ghost process": {
        type: "hack",
        rarity: "rare",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 2;
        },
        damage: function(card, target) {
            return 4 + 1 * card.level;
        },
        description: function(card) {
            return "Deal " + card.data.damage(card) + " damage to ALL enemies. Recover integrity equal to damage dealt. Delete this card";
        },
        effect: [
            function(card) {
                for(var i = 0; i < enemies.length; i++) {
                    normalDamage(card, enemies[i]);
                    var amt = calculateDamage(card, enemies[i]);
                    player.integrity += amt;
                }
                player.integrity = round(constrain(player.integrity, -999, player.maxIntegrity));
            },
        ],
    },

    // programs
    "upgrade": {
        type: "program",
        rarity: "common",
        noTarget: true,
        onlyOneUpgrade: true,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 5;
        },
        description: function(card) {
            // card.level = 1;
            var a = "Upgrade a card in your hand.";
            if(card.level > 0) {
                a = "Upgrade ALL cards in your hand.";
            }
            return "Gain " + card.data.defense(card) + " defense. " + a;
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
            function(card) {
                if(card.level === 0) {
                    if(player.hand.length > 0) {
                        queueSelection();
                        selectionCaption = "Select a card to upgrade";
                        selection = player.hand;
                    }
                } else {
                    for(var i = 0; i < player.hand.length; i++) {
                        upgradeCard(player.hand[i]);
                    }
                    card.animStep++;
                }
            },
            function(card) {
                if(selected) {
                    upgradeCard(selected);
                }
            },
        ],
    },
    "bolster": {
        type: "program",
        rarity: "common",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        description: function(card) {
            return "Gain " + ((1 + card.level) * 2) + " strength. Lose " + ((1 + card.level) * 2) + " strength at the end of your turn";
        },
        endTurn: function(target, value) {
            if(!target.effects.strength) {
                target.effects.strength = 0;
            }
            target.effects.strength -= value;
            target.effects.bolster = false;
        },
        effect: [
            function(card) {
                applyEffect("strength", ((1 + card.level) * 2), player);
                applyEffect("bolster", ((1 + card.level) * 2), player);
            },
        ],
    },
    "inject": {
        type: "program",
        rarity: "common",
        onlyOneUpgrade: true,
        baseCost: function(card) {
            return (card.level === 0) ? 1 : 0;
        },
        condition: function(card) {
            return player.draw.length > 0;
        },
        description: function(card) {
            return "Play the top card of your draw.";
        },
        effect: [
            function(card) {
                if(player.draw[0]) {
                    player.draw[0].animStep = -1;
                    player.draw[0].target = card.target;
                    player.draw[0].dx = -200;
                    player.draw[0].dy = 500;
                    player.energy += player.draw[0].cost;
                    stack.push(player.draw[0]);
                    player.draw.splice(0, 1);
                }
            },
        ],
    },
    "buffer": {
        type: "program",
        rarity: "common",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 8 + 3 * card.level;
        },
        description: function(card) {
            return "Gain " + card.data.defense(card) + " defense. Draw a card";
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
            function(card) {
                drawCard();
            },
        ],
    },
    "refactor": {
        type: "program",
        rarity: "common",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 7 + 2 * card.level;
        },
        description: function(card) {
            // card.level = 1;
            var a = (card.level === 0) ? "Delete a random card in your hand" : "Delete a card";
            return "Gain " + card.data.defense(card) + " defense. " + a;
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
            function(card) {
                if(card.level === 0) {
                    if(player.hand.length > 0) {
                        var chosen = floor(random(0, player.hand.length));
                        deleteCard(player.hand[chosen]);
                        player.hand.splice(chosen, 1);
                        card.animStep++;
                    }
                } else {
                    if(player.hand.length > 0) {
                        queueSelection();
                        selectionCaption = "Select a card to delete";
                        selection = player.hand;
                    } else {
                        card.animStep++;
                    }
                }
            },
            function(card) {
                if(selected) {
                    deleteCard(selected);
                    if(player.hand.indexOf(selected) >= 0) {
                        player.hand.splice(player.hand.indexOf(selected), 1);
                    }
                }
            },
        ],
    },
    "schedule": {
        type: "program",
        rarity: "common",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 0;
        },
        description: function(card) {
            return "Draw " + ((card.level === 0) ? "a card" : ((card.level + 1) + " cards")) + ". Put a card on top of your draw. Delete this card";
        },
        effect: [
            function(card) {
                for(var i = 0; i < card.level + 1; i++) {
                    drawCard();
                }
            },
            function(card) {
                queueSelection();
                selectionCaption = "Select a card to put on top of your draw";
                selection = player.hand;
            },
            function(card) {
                if(selected) {
                    player.draw.splice(0, 0, selected);
                    if(player.hand.indexOf(selected) >= 0) {
                        player.hand.splice(player.hand.indexOf(selected), 1);
                    }
                }
            },
        ],
    },
    "test harness": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        description: function(card) {
            return "Draw " + (card.level + 3) + " cards. You cannot draw cards for 1 turn";
        },
        effect: [
            function(card) {
                for(var i = 0; i < card.level + 3; i++) {
                    drawCard();
                }
                applyEffect("no draw", 1, player);
            },
        ],
    },
    "throttle": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        description: function(card) {
            return "Gain " + (2 + card.level) + " energy. Lose 3 integrity";
        },
        effect: [
            function(card) {
                player.energy += 2 + card.level;
                normalDrain(card, player, 3);
            },
        ],
    },
    "network": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        condition: function(card) {
            return player.hand.length > 1;
        },
        description: function(card) {
            return "Delete a card. Draw " + (2 + card.level) + " cards";
        },
        effect: [
            function(card) {
                if(player.hand.length > 0) {
                    queueSelection();
                    selectionCaption = "Select a card to delete";
                    selection = player.hand;
                } else {
                    card.animStep++;
                }
            },
            function(card) {
                if(selected) {
                    deleteCard(selected);
                    if(player.hand.indexOf(selected) >= 0) {
                        player.hand.splice(player.hand.indexOf(selected), 1);
                    }
                    for(var i = 0; i < 2 + card.level; i++) {
                        drawCard();
                    }
                }
            },
        ],
    },
    "anchor": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 1;
        },
        description: function(card) {
            return "Remove up to " + (card.level + 2) + " strength from each enemy. Delete this card";
        },

        effect: [
            function(card) {
                for(var i = 0; i < enemies.length; i++) {
                    var enemy = enemies[i];
                    if(enemy.effects.strength > 0) {
                        enemy.effects.strength -= min(card.level + 2, enemy.effects.strength);
                    }
                }
            },
        ],
    },
    "mirror": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        description: function(card) {
            return "Create a copy of a hack or cyberware card in your hand" + ((card.level > 0) ? (" " + (card.level + 1) + " times") : "");
        },

        effect: [
            function(card) {

                selection = [];
                for(var i = 0; i < player.hand.length; i++) {
                    if(player.hand[i].data.type === "hack" || player.hand[i].data.type === "cyberware") {
                        selection.push(player.hand[i]);
                    }
                }
                if(selection.length > 0) {
                    queueSelection(true);
                    selectionCaption = "Select a card to copy" + ((card.level > 0) ? (" " + (card.level + 1) + " times") : "");
                } else {
                    card.animStep++;
                }
            },
            function(card) {
                if(selected) {
                    for(var i = 0; i < card.level + 1; i++) {
                        var card2 = new cardObj(selected.type, selected.level);
                        player.hand.push(card2);
                    }
                }
            }
        ],
    },
    "redundancy layer": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        nameTextSize: 8.5,
        baseCost: function(card) {
            return constrain(2 - card.level, 0, 2);
        },
        description: function(card) {
            return "Double your defense";
        },
        effect: [
            function(card) {
                player.defense *= 2;
            },
        ],
    },
    "counter-exploit": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 2;
        },
        defense: function(card, target) {
            return 12 + 4 * card.level;
        },
        startTurn: function(target, value) {
            target.effects["counter-exploit"] = false;
        },
        attacked: function(target, value, data) {
            data.attacker.integrity -= value;
        },
        description: function(card) {
            return "Gain " + card.data.defense(card) + " defense. Until your next turn, when you are attacked, remove " + (4 + card.level * 2) + " integrity from the attacker";
        },
        effect: [
            function(card) {
                normalDefend(card, player);
                applyEffect("counter-exploit", (4 + card.level * 2), player);
            },
        ],
    },
    "safety protocol": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 10 + 3 * card.level;
        },
        description: function(card) {
            return "Gain " + card.data.defense(card) + " defense. Delete this card if not used";
        },
        unused: function(card) {
            if(player.discard.indexOf(card) >= 0) {
                deleteCard(card);
                player.discard.splice(player.discard.indexOf(card), 1);
            }
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
        ],
    },
    "hot reload": {
        type: "program",
        rarity: "uncommon",
        exhaust: true,
        noTarget: true,
        onlyOneUpgrade: true,
        baseCost: function(card) {
            return (card.level === 0) ? 1 : 0;
        },
        description: function(card) {
            return "Add a random hack to your hand. It costs 0 this turn. Delete this card";
        },
        effect: [
            function(card) {
                var a = "hot reload";
                while(cardData[a].type !== "hack") {
                    a = allTypes[floor(random(0, allTypes.length))];
                }
                var card2 = new cardObj(a, 0);
                card2.cost = 0;
                player.hand.push(card2);
                player.resetCosts.push(card2);
            },
        ],
    },
    "rate limit": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 0;
        },
        description: function(card) {
            return "Apply " + (card.level + 1) + " Weak to ALL enemies. Delete this card";
        },
        effect: [
            function(card) {
                for(var i = 0; i < enemies.length; i++) {
                    applyEffect("weak", card.level + 1, enemies[i]);
                }
            },
        ],
    },
    "unstable patch": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 15 + 5 * card.level;
        },
        description: function(card) {
            return "Gain " + card.data.defense(card) + " defense. Add 2 Null cards to your hand";
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
            function(card) {
                var card2 = new cardObj("null", 0);
                player.hand.push(card2);
                var card2 = new cardObj("null", 0);
                player.hand.push(card2);
            },
        ],
    },
    "load balance": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        defense: function(card, target) {
            return 3 + 2 * card.level;
        },
        endTurn: function(target, value) {
            target.effects["load balance"] = false;
        },
        cardPlayed: function(target, value, data) {
            if(data.card.data.type === "hack") {
                target.defense += value;
                managePowers(target, "defended", {
                    amount: value
                });
            }
        },
        description: function(card) {
            return "Whenever you play a Hack this turn, gain " + card.data.defense(card) + " defense";
        },
        effect: [
            function(card) {
                applyEffect("load balance", card.data.defense(card), player);
            },
        ],
    },
    "diagnostic sweep": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        nameTextSize: 8.5,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 5 + 2 * card.level;
        },
        description: function(card) {
            return "Delete all non-Hack cards in your hand. Gain " + card.data.defense(card) + " defense for each card deleted";
        },
        effect: [
            function(card) {
                for(var i = player.hand.length - 1; i > -1; i--) {
                    if(player.hand[i].data.type !== "hack") {
                        deleteCard(player.hand[i]);
                        player.hand.splice(i, 1);
                        normalDefend(card, player);
                    }
                }
            },
        ],
    },
    "power surge": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        exhaust: true,
        onlyOneUpgrade: true,
        baseCost: function(card) {
            return (card.level === 0) ? 1 : 0;
        },
        description: function(card) {
            return "Gain 2 energy. Delete this card";
        },
        effect: [
            function(card) {
                player.energy += 2;
            },
        ],
    },
    "power seal": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        defense: function(card, target) {
            return 5 + 3 * card.level;
        },
        deleted: function(card) {
            player.energy += (2 + card.level);
        },
        description: function(card) {
            return "Gain " + card.data.defense(card) + " defense. If this card is deleted, gain " + (2 + card.level) + " energy";
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
        ],
    },
    "heap corruption": {
        type: "program",
        rarity: "uncommon",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 2;
        },
        description: function(card) {
            return "Apply " + (3 + 2 * card.level) + " Weak and Vulnerable to ALL enemies. Delete this card";
        },
        effect: [
            function(card) {
                for(var i = 0; i < enemies.length; i++) {
                    applyEffect("weak", (3 + 2 * card.level), enemies[i]);
                    applyEffect("vulnerable", (3 + 2 * card.level), enemies[i]);

                }
            },
        ],
    },
    "data pilfer": {
        type: "program",
        rarity: "uncommon",
        baseCost: function(card) {
            return 1;
        },
        description: function(card) {
            return "If the enemy intends to deal damage, gain " + (3 + card.level) + " strength";
        },
        effect: [
            function(card) {
                if(card.target.data.attacks[card.target.selectedAttack].damage) {
                    applyEffect("strength", 3 + card.level, player);
                }
            },
        ],
    },
    "parallelize": {
        type: "program",
        rarity: "rare",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        endTurn: function(target, value) {
            target.effects.parallelize = false;
        },
        cardPlayed: function(target, value, data) {
            if(data.card.data.type === "hack" && !data.card.parallelizeEffect) {
                var card2 = new cardObj(data.card.type, data.card.level);
                card2.cost = 0;
                card2.exhaust = true;
                card2.FAKE = true;
                card2.target = data.card.target;
                card2.animStep = -1;
                card2.parallelizeEffect = true;
                stack.push(card2);
                target.effects.parallelize--;
            }

        },
        description: function(card) {
            // card.level = 1;
            return "This turn, your next " + ((card.level === 0) ? "Hack is" : ((card.level + 1) + " Hacks are")) + " copied";
        },
        effect: [
            function(card) {
                applyEffect("parallelize", 1 + card.level, player);
            },
        ],
    },
    "recover": {
        type: "program",
        rarity: "rare",
        noTarget: true,
        exhaust: true,
        onlyOneUpgrade: true,
        baseCost: function(card) {
            return (card.level === 0) ? 1 : 0;
        },
        description: function(card) {
            return "Put a deleted card into your hand. Delete this card";
        },
        effect: [
            function(card) {
                selection = [];
                for(var i = 0; i < deleted.length; i++) {
                    if(deleted[i].data.type !== "MALWARE" && deleted[i].type !== "recover") {
                        selection.push(deleted[i]);
                    }
                }
                if(selection.length > 0) {
                    queueSelection(true);
                    selectionCaption = "Select a card to put into you hand";
                } else {
                    card.animStep++;
                }
            },
            function(card) {
                if(selected) {
                    if(deleted.indexOf(selected) >= 0) {
                        deleted.splice(deleted.indexOf(selected), 1);
                    }
                    player.hand.push(selected);
                }
            },
        ],
    },
    "bastion": {
        type: "program",
        rarity: "rare",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 2;
        },
        defense: function(card, target) {
            return 30 + 10 * card.level;
        },
        description: function(card) {
            return "Gain " + card.data.defense(card) + " defense. Delete this card";
        },
        effect: [
            function(card) {
                normalDefend(card, player);
            },
        ],
    },
    "optimize": {
        type: "program",
        rarity: "rare",
        noTarget: true,
        exhaust: true,
        onlyOneUpgrade: true,
        exhaustOverride: function(card) {
            return card.level >= 1;
        },
        baseCost: function(card) {
            return 1;
        },
        description: function(card) {
            // card.level = 1;
            return "Double your strength" + ((card.level === 0) ? ".\nDelete this card" : "");
        },
        effect: [
            function(card) {
                player.effects.strength *= 2;
            },
        ],
    },
    "shadow process": {
        type: "program",
        rarity: "rare",
        noTarget: true,
        exhaust: true,
        baseCost: function(card) {
            return 0;
        },
        description: function(card) {
            return "Lose 6 integrity.\nGain 2 Energy.\nDraw " + (3 + 2 * card.level) + " cards. Delete this card";
        },
        effect: [
            function(card) {
                normalDrain(card, player, 6);
            },
            function(card) {
                player.energy += 2;
            },
            function(card) {
                for(var i = 0; i < 3 + 2 * card.level; i++) {
                    drawCard();
                }
            },
        ],
    },

    // cyberware
    "recursive fault": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        damage: function(card, target) {
            return 5 + 2 * card.level;
        },
        endTurn: function(target, card, data) {
            for(var i = 0; i < enemies.length; i++) {
                normalDamage(card, enemies[i]);
            }

            normalDrain(card, target, 1);
            card.pop *= 1.5;
        },
        description: function(card) {
            return "At the end of your turn, deal " + (5 + 2 * card.level) + " damage to ALL enemies and lose 1 integrity";
        },
        effect: [],
    },
    "memory vault": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            // card.level = 1;
            return constrain(2 - card.level, 0, 2);
        },
        cardDeleted: function(target, card, data) {
            drawCard();
            card.pop *= 1.5;
        },
        description: function(card) {
            return "Whenever a card is deleted, draw a card";
        },
        effect: [],
    },
    "perception filter": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        nameTextSize: 8.5,
        baseCost: function(card) {
            return 1;
        },
        cardDraw: function(target, card, data) {
            if(data.card.data.type === "MALWARE") {
                for(var i = 0; i < card.level + 1; i++) {
                    drawCard();
                }
                card.pop *= 1.5;
            }
        },
        description: function(card) {
            return "Whenever you draw a MALWARE card, draw another " + ((card.level === 0) ? "card" : ((card.level + 1) + " cards"));
        },
        effect: [],
    },
    "memory co-processor": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        nameTextSize: 8,
        baseCost: function(card) {
            return 1;
        },
        cardDeleted: function(target, card, data) {
            normalDefend(card, target);
            card.pop *= 1.5;
        },
        defense: function(card, target) {
            return 3 + 1 * card.level;
        },
        description: function(card) {
            return "Whenever a card is deleted, gain " + card.data.defense(card) + " defense";
        },
        effect: [],
    },
    "reactive firmware": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        nameTextSize: 8.5,
        baseCost: function(card) {
            return 1;
        },
        damage: function(card) {
            return 6 + 4 * card.level;
        },
        description: function(card) {
            return "Whenever you draw a MALWARE card, deal " + card.data.damage(card) + " to ALL enemies";
        },
        cardDraw: function(target, card, data) {
            if(data.card.data.type === "MALWARE") {
                for(var i = 0; i < enemies.length; i++) {
                    normalDamage(card, enemies[i]);
                }
                card.pop *= 1.5;
            }
        },

        effect: [],
    },
    "motor amp": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        description: function(card) {
            return "Gain " + (2 + card.level) + " strength";
        },
        effect: [
            function(card) {
                applyEffect("strength", 2 + card.level, player);
            },
        ],
    },
    "shield amp": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        endTurn: function(target, card, data) {
            normalDefend(card, target);
            card.pop *= 1.5;
        },
        defense: function(card, target) {
            return 3 + 1 * card.level;
        },
        description: function(card) {
            return "At the end of your turn, gain " + card.data.defense(card) + " defense";
        },
        effect: [],
    },
    "pain editor": {
        type: "cyberware",
        rarity: "uncommon",
        noTarget: true,
        baseCost: function(card) {
            return 1;
        },
        attacked: function(target, card, data) {
            if(data.card && data.card.identifier === 'card') {

                if(data.amount > 0) {
                    applyEffect("strength", 1, target);
                    card.pop *= 1.5;
                }
            }
        },
        drain: function(target, card, data) {
            if(data.card) {
                if(data.card.identifier === 'card') {
                    applyEffect("strength", 1, target);
                    card.pop *= 1.5;
                }
            }
        },
        description: function(card) {
            return "Whenever you lose integrity from a card, gain " + (1 + card.level) + " strength";
        },
        effect: [],
    },
    "shield reservoir": {
        type: "cyberware",
        rarity: "rare",
        noTarget: true,
        nameTextSize: 8.5,
        baseCost: function(card) {
            return constrain(3 - card.level, 0, 3);
        },
        startTurn: function(target, card, data) {
            target.keepShield = true;
            card.pop *= 1.5;
        },
        description: function(card) {
            return "You don't lose defense at the start of your turn";
        },
        effect: [],
    },
    "cortical amp": {
        type: "cyberware",
        rarity: "rare",
        noTarget: true,
        baseCost: function(card) {
            return 0;
        },
        startTurn: function(target, card, data) {
            player.energy++;
            card.pop *= 1.5;
        },
        description: function(card) {
            return ((card.level < 2) ? ("Gain " + (3 - card.level) + " Vulnerable.\n") : "") + "At the start of your turn, gain 1 Energy";
        },
        effect: [
            function(card) {
                if(card.level < 2) {
                    applyEffect("vulnerable", 3 - card.level, player);
                }
            },
        ],
    },
    "thought injector": {
        type: "cyberware",
        rarity: "rare",
        noTarget: true,
        nameTextSize: 8.5,
        onlyOneUpgrade: true,
        baseCost: function(card) {
            return 0;
        },
        startTurn: function(target, card, data) {
            drawCard();
            normalDrain(card, target, 1);
            card.pop *= 1.5;
        },
        innate: function(card) {
            return card.level > 0;
        },
        description: function(card) {
            return ((card.level > 0) ? "Always in your first hand.\n" : "") + "At the start of your turn, draw a card and lose 1 integrity";
        },
        effect: [],
    },
    "corrupt sector": {
        type: "cyberware",
        rarity: "rare",
        noTarget: true,
        baseCost: function(card) {
            return constrain(3 - card.level, 0, 3);
        },
        makeFree: function(card, target) {
            target.cost = 0;
            target.exhaust = true;
        },
        staticPower: function(card) {
            for(var i = 0; i < player.hand.length; i++) {
                if(player.hand[i].data.type === "program") {
                    card.data.makeFree(card, player.hand[i]);
                }
            }
        },
        description: function(card) {
            return "Programs cost 0. Delete them when played";
        },
        effect: [],
    },
    "power matrix": {
        type: "cyberware",
        rarity: "rare",
        noTarget: true,
        baseCost: function(card) {
            return 3;
        },
        startTurn: function(target, card, data) {
            applyEffect("strength", 2 + card.level, player);
            card.pop *= 1.5;
        },
        description: function(card) {
            return "At the start of your turn, gain " + (2 + card.level) + " Strength";
        },
        effect: [],
    },
    "firewall bloom": {
        type: "cyberware",
        rarity: "rare",
        noTarget: true,
        baseCost: function(card) {
            return 2;
        },
        damage: function(card) {
            return 5 + 2 * card.level;
        },
        defended: function(target, card, data) {
            normalDamage(card, enemies[floor(random(0, enemies.length))]);
            card.pop *= 1.5;
        },
        description: function(card) {
            return "Whenever you gain defense, deal " + card.data.damage(card) + " damage to a random enemy";
        },
        effect: [],
    },

};
/**
 * Stores all the data for more complicated special effects
 */
var specialEffectData = {
    "ritual": {
        endTurn: function(target, value, data) {
            applyEffect("strength", value, target);
        },
        draw: function(value) {
            noStroke();
            pushMatrix();
            translate(0, 3);
            fire(color(23, 118, 207), color(20, 175, 227), color(143, 229, 230));
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
        },
        description: function(value) {
            return "At end of turn, gain " + value + " Strength";
        },
    },
    "split": {
        draw: function(value) {
            noStroke();
            fill(52, 217, 134);
            ellipse(-5, 0, 15, 15);
            ellipse(5, 0, 15, 15);
            stroke(217, 37, 37);
            strokeWeight(4);
            point(-5, -2);
            point(5, 2);
            strokeWeight(2);
            line(-5, -2, 5, 2);
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
        },
        startTurn: function(target, value, data) {
            if(target.integrity <= target.maxIntegrity / 2) {
                target.selectedAttack = target.data.attacks.length - 1;
            }
        },
        description: function(value) {
            return "If integrity is at or below 50%, cancel attack and split into two smaller slimes with the same integrity instead";
        },
    },
    "skulk": {
        draw: function(value) {
            noStroke();
            fill(43, 43, 43);
            ellipse(0, 0, 15, 15);
            fill(186, 65, 65);
            triangle(-1, 2, -5, -3, -5, 1);
            triangle(1, 2, 5, -3, 5, 1);
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
        },
        attacked: function(target, value, data) {
            if(data.amount > 0 && target.integrity > 0) {
                target.defense += value;
                target.effects.skulk = false;
            }
        },
        description: function(value) {
            return "When first dealt damage, gain " + value + " defense";
        },
    },
    "contaminate": {
        draw: function(value) {
            noStroke();
            fill(121, 148, 59);
            ellipse(-2, -2, 15, 15);
            fill(190, 219, 123);
            ellipse(0, 4, 15, 15);
            fill(146, 179, 69);
            ellipse(4, 0, 15, 15);
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
        },
        death: function(target, value, data) {
            applyEffect("vulnerable", 2, player);
        },
        description: function(value) {
            return "On death, apply " + value + " Vulnerable";
        },
    },
    "thievery": {
        draw: function(value, target) {
            noStroke();
            stroke(176, 137, 10);
            strokeWeight(3);
            fill(245, 190, 27);
            rect(-6, -6, 12, 12, 5);
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
            if(!target.heldCredits) {
                target.heldCredits = 0;
            } else {
                textSize(12);
                fill(48, 38, 8);
                text(target.heldCredits, 7, 5);
            }
        },
        death: function(target, value, data) {
            if(target.heldCredits) {
                player.credits += target.heldCredits;
            }
        },
        attacks: function(target, value, data) {
            if(!target.heldCredits) {
                target.heldCredits = 0;
            }
            if(value > player.credits) {
                value = player.credits;
            }
            player.credits -= value;
            target.heldCredits += value;
        },
        description: function(value) {
            return "Steal " + value + " credits on attack. The credits are returned if defeated";
        },
    },
    "barricade": {
        draw: function(value) {
            noStroke();
            pushMatrix();
            scale(0.18);
            translate(0, -28);

            noStroke();
            stroke(62, 115, 94);
            strokeWeight(8);

            fill(59, 184, 136);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(127, 227, 189);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(62, 115, 94);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
        },
        startTurn: function(target, value, data) {
            target.keepShield = true;
        },
        description: function(value) {
            return "Defense is not lost at the start of the turn";
        },
    },
    "artifact": {
        draw: function(value) {
            noStroke();
            pushMatrix();
            scale(0.18);
            translate(0, -28);

            noStroke();
            stroke(115, 107, 62);
            strokeWeight(8);

            fill(184, 168, 61);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(227, 214, 127);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(115, 107, 62);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
        },
        description: function(value) {
            return "Negate applied effects, " + value + " time" + ((value > 1) ? "s" : "");
        },
    },
    "hex": {
        draw: function(value) {
            noStroke();
            fill(167, 24, 186);
            ellipse(0, 0, 18, 18);
            fill(201, 100, 217);
            ellipse(0, 0, 12, 12);
            fill(231, 197, 237);
            ellipse(0, 0, 5, 5);
            stroke(111, 235, 235);
            strokeWeight(1);

            pushMatrix();
            rotate(floor(frameCount / 10) * 100);
            line(-1, 0, 3, 3);
            line(2, -4, 3, 3);
            line(2, -4, -6, -1);
            line(3, 8, -6, -1);
            line(3, 8, 9, -4);
            line(-4, -10, 9, -4);
            line(-4, -10, -10, 1);
            popMatrix();
            textAlign(LEFT, BASELINE);
            textSize(12);
        },
        cardPlayed: function(target, value, data) {
            if(data.card) {
                if(data.card.data.type !== "hack") {
                    var card2 = new cardObj("undefined", 0);
                    drawAdding.push(card2);
                    player.draw.push(card2);
                    player.draw = shuffleArray(player.draw);
                }
            }
        },
        description: function(value) {
            return "Whenever you play a non-Hack card, shuffle an Undefined card into your draw";
        },
    },
    "plated": {
        draw: function(value) {
            noStroke();
            pushMatrix();
            scale(0.18);
            translate(0, -28);

            noStroke();
            stroke(64, 45, 45);
            strokeWeight(8);

            fill(97, 61, 61);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(128, 92, 92);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(64, 45, 45);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
        },
        endTurn: function(target, value, data) {
            target.defense += value;
        },
        attacked: function(target, value, data) {
            if(data.amount > 0) {
                target.effects.plated--;
            }
            if(!target.effects.plated || target.effects.plated < 0) {
                target.effects.plated = 0;
            }
        },
        description: function(value) {
            return "Gain " + value + " defense at end of turn. When damaged, lose 1 Plated";
        },
    },
    "hardened": {
        draw: function(value) {
            noStroke();
            pushMatrix();
            scale(0.18);
            translate(0, -28);

            noStroke();
            stroke(89, 89, 89);
            strokeWeight(8);

            fill(107, 107, 107);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(148, 148, 148);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(89, 89, 89);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
        },
        endTurn: function(target, value, data) {
            target.defense += value;
        },
        description: function(value) {
            return "Gain " + value + " defense at end of turn.";
        },
    },
    "flying": {
        draw: function(value, target) {
            noStroke();
            pushMatrix();
            scale(0.06);
            translate(-260, -255);
            fill(111, 199, 209);
            beginShape();
            vertex(132, 444);
            vertex(134, 390);
            vertex(161, 318);
            vertex(199, 262);
            vertex(212, 304);
            vertex(217, 268);
            vertex(236, 226);
            vertex(266, 186);
            vertex(306, 152);
            vertex(308, 196);
            vertex(324, 152);
            vertex(334, 138);
            vertex(362, 117);
            vertex(425, 88);
            vertex(466, 73);
            vertex(504, 66);
            vertex(520, 67);
            vertex(526, 73);
            vertex(526, 91);
            vertex(501, 143);
            vertex(460, 201);
            vertex(418, 250);
            vertex(404, 260);
            vertex(386, 263);
            vertex(358, 258);
            vertex(384, 276);
            vertex(355, 298);
            vertex(326, 312);
            vertex(289, 322);
            vertex(320, 327);
            vertex(339, 324);
            vertex(306, 364);
            vertex(276, 394);
            vertex(247, 413);
            vertex(210, 433);
            vertex(155, 451);
            vertex(137, 454);
            endShape(CLOSE);
            stroke(40, 121, 130);
            strokeWeight(20);
            line(96, 500, 272, 288);
            line(431, 140, 272, 288);
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(target.flyCounter, 5, 15);
        },
        endTurn: function(target, value, data) {
            target.flyCounter = value;
        },
        attacked: function(target, value, data) {
            target.integrity += floor(data.amount / 2);
            target.flyCounter--;
            if(!target.flyCounter) {
                target.effects.flying = false;
                target.selectedAttack = target.data.attacks.length - 1;
            }
        },
        description: function(value) {
            return "Take 50% less damage from attacks. Lose flying when attacked " + value + " times in a single turn";
        },
    },
    "malleable": {
        draw: function(value, target) {
            noStroke();
            pushMatrix();
            scale(0.18);
            translate(0, -28);

            noStroke();
            stroke(49, 64, 45);
            strokeWeight(8);

            fill(61, 97, 68);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(99, 128, 92);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(49, 64, 45);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(target.malleableCounter, 5, 15);
        },
        endTurn: function(target, value, data) {
            target.malleableCounter = value;
        },
        attacked: function(target, value, data) {
            if(data.amount > 0) {
                if(!target.malleableCounter) {
                    target.malleableCounter = value;
                }
                target.defense += target.malleableCounter;
                target.malleableCounter++;
            }
        },
        description: function(value) {
            return "Gain " + value + " defense when dealt damage and increase future defense gain by 1. Reset defense gain at end of turn";
        },
    },
    "CHAOS": {
        draw: function(value, target) {
            noStroke();
            var rc = [abs(cos(frameCount * 3 / 2)) * (255 / 1.5), abs(cos(frameCount * 5 / 2)) * (255 / 1.5), abs(cos(frameCount * 7 / 2)) * (255 / 1.5)];
            pushMatrix();
            translate(0, 3);
            fire(color(rc[0], rc[1], rc[2]), color(rc[0] * 1.2, rc[1] * 1.2, rc[2] * 1.2), color(rc[0] * 1.5, rc[1] * 1.5, rc[2] * 1.5));
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
        },

        cardDraw: function(target, value, data) {
            if(data.card) {
                data.card.cost = floor(random(0, 4));
            }
        },
        description: function(value) {
            return "Whenever you draw a card, randomize its cost";
        },
    },
    "thorns": {
        draw: function(value, target) {
            noStroke();
            fill(181, 181, 181);
            beginShape();
            var a = 15;
            var n = 8;
            var a2 = 1;
            for(var i = 15; i < 360; i += 360 / n) {
                a2 = 1 - a2;
                vertex(a / (1 + a2 * 0.5) * cos(i), a / (1 + a2 * 0.5) * sin(i));
                vertex((a / 3) * cos(i + 360 / (n * 2)), (a / 3) * sin(i + 360 / (n * 2)));
            }
            endShape();
            fill(219, 219, 219);
            beginShape();
            var a = 7;
            var n = 8;
            var a2 = 1;
            for(var i = -30; i < 360; i += 360 / n) {
                a2 = 1 - a2;
                vertex(a / (1 + a2 * 0.5) * cos(i), a / (1 + a2 * 0.5) * sin(i));
                vertex((a / 3) * cos(i + 360 / (n * 2)), (a / 3) * sin(i + 360 / (n * 2)));
            }
            endShape();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(value, 5, 15);
        },
        attacked: function(target, value, data) {
            if(data.amount > 0) {
                var amount = value;
                if(amount >= data.attacker.defense) {
                    amount -= data.attacker.defense;
                    data.attacker.defense = 0;
                } else {
                    data.attacker.defense -= amount;
                    amount = 0;
                }

                data.attacker.integrity -= floor(amount);
            }
        },
        description: function(value) {
            return "When dealt damage, deal " + value + " damage to the attacker";
        },
    },
    "reactive": {
        draw: function(value, target) {
            noStroke();
            fill(224, 61, 61);
            ellipse(0, 0, 18, 18);
            fill(212, 108, 108);
            ellipse(0, 0, 12, 12);
            fill(224, 150, 150);
            ellipse(0, 0, 5, 5);
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
        },
        attacked: function(target, value, data) {
            if(data.amount > 0) {
                var pSelect = target.selectedAttack;
                while(target.selectedAttack === pSelect) {
                    target.selectedAttack = floor(random(0, target.data.attacks.length));
                }
            }
        },
        description: function(value) {
            return "When damaged, change intended attack";
        },
    },
    "fragile": {
        draw: function(value, target) {
            noStroke();
            pushMatrix();
            scale(0.2);
            translate(35, -40);
            rotate(30);
            noStroke();

            fill(161, 161, 161);
            beginShape();
            vertex(-4, 114);
            vertex(-7, 90);
            vertex(-12, 80);
            vertex(-20, -10);
            vertex(-7, 9);
            vertex(5, -1);
            vertex(11, 14);
            vertex(20, 8);
            vertex(12, 80);
            vertex(7, 90);
            vertex(4, 114);
            endShape(CLOSE);
            fill(105, 105, 105);
            beginShape();
            vertex(-25, 90);
            vertex(-35, 80);
            vertex(-30, 70);
            vertex(-20, 80);
            vertex(-12, 80);
            vertex(12, 80);
            vertex(20, 80);
            vertex(30, 70);
            vertex(35, 80);
            vertex(25, 90);
            endShape(CLOSE);
            fill(196, 196, 196);
            beginShape();
            vertex(-12, 111);
            vertex(-8, 105);
            vertex(8, 105);
            vertex(12, 111);
            vertex(0, 124);
            endShape(CLOSE);
            noStroke();
            fill(102, 102, 102);
            beginShape();
            vertex(-1, 80);
            vertex(7, 31);
            vertex(16, 24);
            vertex(7, 63);
            endShape(CLOSE);
            popMatrix();
            fill(0, 0, 0);
            textAlign(LEFT, BASELINE);
            textSize(12);
            text(target.fragileCounter, 5, 15);
        },
        endTurn: function(target, value, data) {
            target.fragileCounter = 0;
        },
        attacked: function(target, value, data) {
            if(data.amount > 0) {
                target.fragileCounter += data.amount;
            }
        },
        description: function(value) {
            return "When damaged, deal that much less damage until end of turn";
        },
    },
};

// log all the cards and effects in their respective all[whatever it is] array. also log them all in the rarityData array.
for(var i in cardData) {
    rarityData[cardData[i].rarity].push(i);
    allTypes.push(i);
}
for(var i in specialEffectData) {
    allSpecialEffects.push(i);
}

/**
 * The constructor for cards
 * @constructor
 * @param {String} type - what card it is
 * @param {number} level - initial level of the card
*/
function cardObj(type, level) {
    this.x = 300;
    this.y = 350;
    this.dx = this.x;
    this.dy = this.y;
    this.type = type || "stack smash";
    this.data = cardData[this.type];
    this.level = level || 0;
    this.cost = this.data.baseCost(this);
    this.pop = 1;
    this.toPop = 1;
    this.identifier = 'card';
    // this.level = floor(random(0,3));
    // println(this.baseCost);
}

// whether or not the card is being hovered over
cardObj.prototype.hovered = function() {
    return msx >= this.x - 50 * this.pop && msx <= this.x + 50 * this.pop && msy >= this.y - 70 * this.pop && msy <= this.y + 70 * this.pop;
};

// ports the player's deck to the player's temporary draw pile and then shuffles it
function portDeck() {
    player.draw = [];
    player.hand = [];
    player.discard = [];

    for(var i = 0; i < player.deck.length; i++) {
        var card = new cardObj(player.deck[i].type, player.deck[i].level);
        card.cost = player.deck[i].cost;
        player.draw.push(card);
    }
    player.draw = shuffleArray(player.draw);
}

// data for the makeup of each encounter
var encounters = [

    // tower 1
    [
        // first 3
        [
            [function() {
                return ['hacktivist'];
            }, 25],
            [function() {
                return ['big rat'];
            }, 25],
            [function() {
                return [
                    manageProbabilities([
                        ["sickly cyberat", 50],
                        ["angry cyberat", 50],
                    ]),
                    manageProbabilities([
                        ["sickly cyberat", 50],
                        ["angry cyberat", 50],
                    ]),
                ];
            }, 25],
            [function() {
                return [
                    manageProbabilities([
                        ["acid slime", 50],
                        ["plasma slime", 50],
                    ]),
                    manageProbabilities([
                        ["tiny acid slime", 50],
                        ["tiny plasma slime", 50],
                    ]),
                ];
            }, 25],
        ],
        // other
        [
            [function() {
                return [
                    manageProbabilities([
                        ["giant acid slime", 50],
                        ["giant plasma slime", 50],
                    ]),
                ];
            }, 125],
            [function() {
                var pool = ["heavy scrapling", "heavy scrapling", "scrapling", "scrapling", "sharp scrapling", "sharp scrapling", "shield scrapling", "scrapling crusher"];
                while(pool.length > 4) {
                    pool.splice(floor(random(0, pool.length)), 1);
                }
                return pool;
            }, 125],
            [function() {
                return ["tiny acid slime", "tiny acid slime", "tiny plasma slime", "tiny plasma slime", "tiny plasma slime"];
            }, 63],
            [function() {
                return ["enforcer"];
            }, 63],
            [function() {
                return [
                    manageProbabilities([
                        ["sickly cyberat", 50],
                        ["angry cyberat", 50],
                    ]),
                    manageProbabilities([
                        ["sickly cyberat", 50],
                        ["angry cyberat", 50],
                    ]),
                    manageProbabilities([
                        ["sickly cyberat", 50],
                        ["angry cyberat", 50],
                    ])
                ];
            }, 125],
            [function() {
                return ["viral vessel", "viral vessel"];
            }, 125],
            [function() {
                return [
                    manageProbabilities([
                        ["acid slime", 25],
                        ["plasma slime", 25],
                        ["sickly cyberat", 25],
                        ["angry cyberat", 25],
                    ]),
                    manageProbabilities([
                        ["looter", 25],
                        ['hacktivist', 25],
                        ['enforcer', 25],
                    ]),
                ];
            }, 94],
            [function() {
                return [
                    manageProbabilities([
                        ["viral vessel", 50],
                        ["big rat", 50],
                    ]),
                    manageProbabilities([
                        ["acid slime", 25],
                        ["plasma slime", 25],
                        ["sickly cyberat", 25],
                        ["angry cyberat", 25],
                    ]),
                ];
            }, 94],
            [function() {
                return ["looter"];
            }, 125],
        ],
        // boss
        [
            [function() {
                return ["mega slime", ];
            }, 80],
            [function() {
                return ["hexaghost", ];
            }, 20],
        ],
    ],
    // tower 2
    [
        // first 3
        [
            [function() {
                return ['orb sentinel'];
            }, 20],
            [function() {
                return ['ascended'];
            }, 20],
            [function() {
                return ['shellwrecker'];
            }, 20],
            [function() {
                return ['drone', 'drone', 'drone'];
            }, 20],
            [function() {
                return ['looter', 'mugger'];
            }, 200],
        ],
        // other
        [
            [function() {
                return ['ascended', 'drone'];
            }, 7],
            [function() {
                return ['hacktivist', 'ascended'];
            }, 10],
            [function() {
                return ['sentry', 'orb sentinel'];
            }, 7],
            [function() {
                return ['biomanipulator'];
            }, 21],
            [function() {
                return ['CHAOS bot'];
            }, 14],
            [function() {
                return ['centurion', 'healer'];
            }, 21],
            [function() {
                return ['hacktivist', 'hacktivist', 'hacktivist'];
            }, 10],
            [function() {
                return ['shellwrecker', 'viral vessel'];
            }, 10],
        ],
        // boss
        [
            [function() {
                return ["scrapling supreme", ];
            }, 10],
        ],
    ],
    // tower 3
    [
        // first 2
        [
            [function() {
                return ['strider'];
            }, 50],
            [function() {
                var pool = ["repulsor", "repulsor", "spiker", "spiker", "exploder", "exploder", ];
                while(pool.length > 3) {
                    pool.splice(floor(random(0, pool.length)), 1);
                }
                return pool;
            }, 50],
        ],
        // other
        [
            [function() {
                var pool = ["repulsor", "repulsor", "spiker", "spiker", "exploder", "exploder", ];
                while(pool.length > 4) {
                    pool.splice(floor(random(0, pool.length)), 1);
                }
                return pool;
            }, 10],
            [function() {
                return ['mega rat'];
            }, 10],
            [function() {
                return [
                    "orb sentinel",
                    manageProbabilities([
                        ["repulsor", 10],
                        ["spiker", 10],
                        ["exploder", 10],
                    ]),
                    manageProbabilities([
                        ["repulsor", 10],
                        ["spiker", 10],
                        ["exploder", 10],
                    ])
                ];
            }, 10],
            [function() {
                return [
                    "ascended",
                    manageProbabilities([
                        ["repulsor", 10],
                        ["spiker", 10],
                        ["exploder", 10],
                    ]),
                    manageProbabilities([
                        ["repulsor", 10],
                        ["spiker", 10],
                        ["exploder", 10],
                    ])
                ];
            }, 10],
            [function() {
                return ['big rat', 'big rat', 'big rat'];
            }, 10],
            [function() {
                return ['overseer'];
            }, 10],
            [function() {
                return ['volatile construct'];
            }, 10],
        ],
        // boss
        [
            [function() {
                return ["ACKVNHY", "ACKVNHLO"];
            }, 10],
        ],
    ],
];

// data for each enemy
/**
 * @typedef {Object} enemyData
 * @property {Array} integrityVals - min and max for starting integrity
 * @property {number} height - how tall the enemy is
 * @property {Function} draw - draw the enemy
 *      @param {Object} enemy - the enemy being drawn
 * @property {Function} chooseAttack - choose an attack
 *      @param {Object} enemy - the enemy choosing an attack
 * @property {attackData[]} attacks - a list of possible attacks that the enemy can do
 *      @typedef {Object} attackData - data for an attack
 *      @property {String} name - the name of the attack
 *      @property {Function} description - description of the attack
 *          @param {Object} attack - the attack to describe
 *          @returns {String} - a description
 * @property {String[]} symbols - symbols to represent the attack
 *      @property {Array} effect - an array of functions to be called in order when the attack is used
*/
var enemyData = {
    "hacktivist": {
        integrityVals: [48, 54],
        height: 140,
        draw: function(enemy) {
            pushMatrix();
            translate(10, -6);
            pushMatrix();
            strokeWeight(8);
            stroke(22, 42, 84);
            line(0, -22, -65, -16 + sin(frameCount * 3) * 5);
            translate(0, sin(frameCount * 3) * 5);
            line(-65, -25, -65, -10);
            line(-65, -25, -79, -25);
            line(-65, -10, -73, -10);
            popMatrix();

            stroke(26, 109, 161);
            strokeWeight(4);
            fill(102, 209, 242);
            beginShape();
            vertex(42, 23);
            vertex(22, 43);
            vertex(-22, 40);
            vertex(-43, 23);
            vertex(-23, -67);
            vertex(20, -67);
            endShape(CLOSE);
            noStroke();
            fill(49, 150, 181);
            beginShape();
            vertex(35, 23);
            vertex(22, 32);
            vertex(5, 27);
            vertex(21, 23);
            vertex(6, -67);
            vertex(15, -67);
            endShape(CLOSE);

            pushMatrix();
            translate(18, -69 + sin(frameCount * 3) * 5);
            pushMatrix();
            rotate(-30 + sin(frameCount * 3) * 5);
            stroke(61, 61, 61);
            fill(120, 120, 120);
            rect(-70, -50, 75, 60, 10);
            line(5, -25, -30, -25);
            line(5, -15, -8, -15);
            popMatrix();
            translate(-4, 0);
            fill(0, 170, 212);
            rect(-83, -2, 40, 20, 10);
            popMatrix();

            // pushMatrix();
            // translate(-7,-111+sin(frameCount*3)*8);
            // rotate(sin(frameCount*6)*10);
            // stroke(255, 221, 0);
            // noFill();
            // strokeWeight(8);
            // ellipse(0,0,60,20);
            // popMatrix();

            pushMatrix();
            translate(30, 0);
            strokeWeight(8);
            stroke(22, 42, 84);
            line(-30, -22, -65, -16 + cos(frameCount * 3) * 5);
            translate(0, cos(frameCount * 3) * 5);
            line(-65, -25, -65, -10);
            line(-65, -25, -79, -25);
            line(-65, -10, -73, -10);
            popMatrix();
            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.effects.ritual) {
                return 1;
            }
            return 0;
        },
        attacks: [{
                name: "dark strike",
                description: function(attack) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                damage: function(attack, target) {
                    return 3;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "incantation",
                description: function(attack) {
                    return "Gain 3 ritual";
                },
                symbols: ["buff"],
                num: 3,
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("ritual", 3, enemy);
                    }
                ],
            },
        ],
    },
    "big rat": {
        integrityVals: [40, 44],
        height: 65,
        draw: function(enemy) {
            pushMatrix();
            translate(-14, -10);

            stroke(222, 145, 217);
            strokeWeight(8);
            noFill();
            beginShape();
            vertex(134, 13);

            vertex(63, 12);
            curveVertex(134, -4 + cos(frameCount * 3) * 5);
            vertex(264 + sin(frameCount * 3) * 60, -152);
            endShape();

            stroke(117, 117, 117);
            strokeWeight(4);
            // noStroke();

            fill(189, 189, 189);
            pushMatrix();

            translate(-157, -115 + sin(frameCount * 3) * 2);
            beginShape();
            vertex(103, 125);
            bezierVertex(102, 128, 166, 171, 232, 126);
            bezierVertex(221, 77, 136, 60, 102, 128);
            endShape();
            popMatrix();
            pushMatrix();
            translate(-30, 7);
            rotate(10 + sin(frameCount * 3) * 5);
            translate(-157, -110);
            noStroke();
            fill(230, 230, 230);
            rect(103, 121, 10, 20, 5);

            stroke(117, 117, 117);
            fill(163, 163, 163);
            pushMatrix();
            translate(175, 82);
            rotate(126);
            ellipse(0, 0, 20, 10);
            popMatrix();
            pushMatrix();
            translate(144, 80);
            rotate(78);
            ellipse(0, 0, 20, 10);
            popMatrix();
            beginShape();
            vertex(103, 125);
            bezierVertex(102, 128, 141, 144, 176, 118);
            bezierVertex(184, 77, 147, 60, 102, 128);
            endShape();
            stroke(222, 145, 217);
            strokeWeight(16);
            point(103, 126);
            strokeWeight(10);
            stroke(0, 0, 0);
            point(161, 105);
            popMatrix();
            stroke(222, 145, 217);
            strokeWeight(12);
            pushMatrix();
            line(-18, 37, -5, 25);
            line(56, 30, 45, 20);
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 1;
                return 0;
            }
            var choice;
            while(!choice || (choice === 2 && enemy.selectedAttack === 2)) {
                choice = manageProbabilities([
                    [0, 25],
                    [1, 30],
                    [2, 45],
                ]);
            }
            return choice;
        },
        attacks: [{
                name: "chomp",
                description: function(attack) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                damage: function(attack, target) {
                    return 11;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "thrash",
                damage: function(attack, target) {
                    return 7;
                },
                defense: function(attack, target) {
                    return 5;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage. Gain " + attack.defense(attack, enemy) + " defense";
                },
                symbols: ["sword", "shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
            {
                name: "bellow",
                defense: function(attack, target) {
                    return 6;
                },
                description: function(attack, enemy) {
                    return "Gain 3 Strength. Gain " + attack.defense(attack, enemy) + " defense";
                },
                num: 3,
                symbols: ["buff", "shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 3, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
        ],
    },
    "sickly cyberat": {
        integrityVals: [11, 17],
        height: 45,
        draw: function(enemy) {
            pushMatrix();
            translate(-8, -1);
            scale(0.66);

            stroke(168, 148, 167);
            strokeWeight(8);
            noFill();
            beginShape();
            vertex(134, 13);

            vertex(63, 12);
            curveVertex(134, -4 + cos(frameCount * 3) * 5);
            vertex(264 + sin(frameCount * 3) * 60, -152);
            endShape();

            stroke(117, 117, 117);
            strokeWeight(6);
            // noStroke();

            fill(149, 184, 170);
            pushMatrix();

            translate(-157, -115 + sin(frameCount * 3) * 2);
            beginShape();
            vertex(103, 125);
            bezierVertex(102, 128, 166, 171, 232, 126);
            bezierVertex(221, 77, 136, 60, 102, 128);
            endShape();
            popMatrix();
            pushMatrix();
            translate(-30, 7);
            rotate(10 + sin(frameCount * 3) * 5);
            translate(-157, -110);
            noStroke();
            fill(230, 230, 230);
            rect(103, 121, 10, 20, 5);

            stroke(117, 117, 117);
            fill(99, 148, 120);
            pushMatrix();
            translate(175, 82);
            rotate(126);
            ellipse(0, 0, 20, 10);
            popMatrix();
            pushMatrix();
            translate(144, 80);
            rotate(78);
            ellipse(0, 0, 20, 10);
            popMatrix();
            beginShape();
            vertex(103, 125);
            bezierVertex(102, 128, 141, 144, 176, 118);
            bezierVertex(184, 77, 147, 60, 102, 128);
            endShape();
            stroke(222, 145, 217);
            strokeWeight(16);
            point(103, 126);

            strokeWeight(12);
            stroke(141, 230, 200);
            line(164, 102, 118, 102);

            popMatrix();
            stroke(128, 128, 128);
            strokeWeight(12);
            pushMatrix();
            line(-18, 37, -5, 25);
            line(56, 30, 45, 20);
            popMatrix();

            popMatrix();
        },
        startingEffects: function() {
            return {
                skulk: floor(random(3, 8)),
            };
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 75],
                [1, 25],
            ]);
        },
        attacks: [{
                name: "chomp",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    if(!enemy.chooseNum) {
                        enemy.chooseNum = floor(random(5, 8));
                    }
                    return enemy.chooseNum;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "spit",
                num: 2,
                description: function(attack) {
                    return "Apply 2 Weak.";
                },
                symbols: ["debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 2, player);
                    },
                ],
            },
        ],
    },
    "angry cyberat": {
        integrityVals: [10, 15],
        height: 45,
        draw: function(enemy) {
            pushMatrix();
            translate(-8, -1);
            scale(0.66);

            stroke(168, 148, 167);
            strokeWeight(8);
            noFill();
            beginShape();
            vertex(134, 13);

            vertex(63, 12);
            curveVertex(134, -4 + cos(frameCount * 3) * 5);
            vertex(264 + sin(frameCount * 3) * 60, -152);
            endShape();

            stroke(117, 117, 117);
            strokeWeight(6);
            // noStroke();

            fill(176, 146, 150);
            pushMatrix();

            translate(-157, -115 + sin(frameCount * 3) * 2);
            beginShape();
            vertex(103, 125);
            bezierVertex(102, 128, 166, 171, 232, 126);
            bezierVertex(221, 77, 136, 60, 102, 128);
            endShape();
            popMatrix();
            pushMatrix();
            translate(-30, 7);
            rotate(10 + sin(frameCount * 3) * 5);
            translate(-157, -110);
            noStroke();
            fill(230, 230, 230);
            rect(103, 121, 10, 20, 5);

            stroke(117, 117, 117);
            fill(176, 104, 104);
            pushMatrix();
            translate(175, 82);
            rotate(126);
            ellipse(0, 0, 20, 10);
            popMatrix();
            pushMatrix();
            translate(144, 80);
            rotate(78);
            ellipse(0, 0, 20, 10);
            popMatrix();
            beginShape();
            vertex(103, 125);
            bezierVertex(102, 128, 141, 144, 176, 118);
            bezierVertex(184, 77, 147, 60, 102, 128);
            endShape();
            stroke(222, 145, 217);
            strokeWeight(16);
            point(103, 126);

            strokeWeight(12);
            stroke(145, 55, 55);
            line(164, 102, 133, 112);
            line(133, 112, 118, 102);

            popMatrix();
            stroke(128, 128, 128);
            strokeWeight(12);
            pushMatrix();
            line(-18, 37, -5, 25);
            line(56, 30, 45, 20);
            popMatrix();

            popMatrix();
        },
        startingEffects: function() {
            return {
                skulk: floor(random(3, 8)),
            };
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 75],
                [1, 25],
            ]);
        },
        attacks: [{
                name: "chomp",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    if(!enemy.chooseNum) {
                        enemy.chooseNum = floor(random(5, 8));
                    }
                    return enemy.chooseNum;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "enrage",
                num: 3,
                description: function(attack) {
                    return "Gain 3 strength.";
                },
                symbols: ["buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 3, enemy);
                    },
                ],
            },
        ],
    },
    "acid slime": {
        integrityVals: [28, 32],
        height: 60,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -10);
            pushMatrix();
            var num = cos(frameCount * 3) * 0.08;

            rotate(sin(frameCount * 6) * 5);
            var a = 45;
            translate(0, a);
            scale(1 + num, 0.8 - num);
            translate(0, -a);

            stroke(49, 171, 15);
            strokeWeight(8);
            fill(56, 222, 58, 200);
            ellipse(0, 0, 80, 80);
            popMatrix();
            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 30],
                [1, 30],
                [2, 40],
            ]);
        },
        attacks: [{
                name: "corrosive spit",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Shuffle 1 slimed card into discard";
                },
                damage: function(attack, player, enemy) {
                    return 7;
                },
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },
            {
                name: "lick",
                num: 1,
                description: function(attack) {
                    return "Apply 1 Weak";
                },
                symbols: ["debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 1, player);
                    },
                ],
            },
            {
                name: "tackle",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
        ],
    },
    "plasma slime": {
        integrityVals: [28, 32],
        height: 60,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -10);
            pushMatrix();
            var num = cos(frameCount * 3 + 180) * 0.08;

            rotate(sin(frameCount * 6) * 5);
            var a = 45;
            translate(0, a);
            scale(1 + num, 0.8 - num);
            translate(0, -a);

            stroke(15, 155, 171);
            strokeWeight(8);
            fill(68, 195, 199, 200);
            ellipse(0, 0, 80, 80);

            popMatrix();
            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 30],
                [1, 70],
            ]);
        },
        attacks: [{
                name: "corrosive spit",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Shuffle 1 slimed card into discard";
                },
                damage: function(attack, player, enemy) {
                    return 8;
                },
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },
            {
                name: "lick",
                num: 1,
                description: function(attack) {
                    return "Apply 1 Frail";
                },
                symbols: ["debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("frail", 1, player);
                    },
                ],
            },
        ],
    },
    "tiny plasma slime": {
        integrityVals: [10, 14],
        height: 45,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -1);
            scale(0.8);
            pushMatrix();
            var num = cos(frameCount * 3 + 180) * 0.08;

            rotate(sin(frameCount * 6) * 5);
            var a = 45;
            translate(0, a);
            scale(1 + num, 0.8 - num);
            translate(0, -a);

            stroke(15, 155, 171);
            strokeWeight(10);
            fill(68, 195, 199, 200);
            ellipse(0, 0, 80, 80);

            popMatrix();
            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 100],
            ]);
        },
        attacks: [{
            name: "tackle",
            description: function(attack, enemy) {
                return "Deal " + attack.damage(attack, player, enemy) + " damage";
            },
            damage: function(attack, player, enemy) {
                return 5;
            },
            symbols: ["sword"],
            effect: [
                function(attack, enemy) {
                    enemy.dx -= 60;
                    normalDamage(attack, player, enemy);
                }
            ],
        }, ],
    },
    "tiny acid slime": {
        integrityVals: [8, 12],
        height: 45,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -1);
            scale(0.8);
            pushMatrix();
            var num = cos(frameCount * 3) * 0.08;

            rotate(sin(frameCount * 6) * 5);
            var a = 45;
            translate(0, a);
            scale(1 + num, 0.8 - num);
            translate(0, -a);

            stroke(49, 171, 15);
            strokeWeight(10);
            fill(56, 222, 58, 200);
            ellipse(0, 0, 80, 80);

            popMatrix();
            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 50],
                [1, 50],
            ]);
        },
        attacks: [{
                name: "tackle",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 3;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "lick",
                num: 1,
                description: function(attack) {
                    return "Apply 1 Weak";
                },
                symbols: ["debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 1, player);
                    },
                ],
            },
        ],
    },
    "heavy scrapling": {
        integrityVals: [20, 24],
        height: 110,
        draw: function(enemy) {
            pushMatrix();
            translate(0, 5);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 11);
            rotate(7);
            rect(0, 0, 16, 10, 5);
            popMatrix();
            pushMatrix();
            translate(-24, 11);
            rotate(-7);
            rect(0, 0, 16, 10, 5);
            popMatrix();

            // left hand
            pushMatrix();
            translate(-46, -20 + sin(frameCount * 3) * 2);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            // enemy.smashAnim = 1;
            rotate(60 - enemy.smashAnim * 150);

            stroke(112, 103, 90);
            strokeWeight(8);
            line(0, 10, 0, -130);
            fill(97, 96, 92);

            stroke(0, 0, 0);
            strokeWeight(4);
            triangle(0, -100, 0, -120, -20, -110);
            triangle(0, -80, 0, -100, -20, -90);
            triangle(0, -100, 0, -120, 20, -110);
            triangle(0, -80, 0, -100, 20, -90);

            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 + 8);
            translate(-40, -50);
            fill(135, 135, 135);
            rect(0, 0, 70, 50, 10);
            fill(99, 99, 99);
            rect(-5, -5, 80, 20, 10);
            popMatrix();

            // head
            pushMatrix();
            translate(0, cos(frameCount * 3) * -4);
            translate(-42, -91);
            fill(176, 176, 176);
            rect(0, 0, 71, 60, 40);

            // eyes
            pushMatrix();
            translate(0, cos(frameCount * 3) * -2);
            fill(255, 162, 0);
            stroke(163, 118, 35);
            ellipse(58, 36, 15, 15);
            ellipse(4, 28, 15, 15);
            popMatrix();

            // mouth
            pushMatrix();
            translate(12, sin(frameCount * 3));
            translate(19, 46);
            rotate(10 + sin(frameCount * 3 / 2) * 5);
            fill(224, 224, 224);
            stroke(166, 166, 166);
            arc(0, 0, 40, 27, 0, 180);
            line(-20, 0, 20, 0);
            popMatrix();

            popMatrix();
            stroke(0, 0, 0);

            // right hand
            pushMatrix();
            translate(39, -7 + sin(frameCount * 3) * 2);
            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 100],
            ]);
        },
        attacks: [{
            name: "scratch",
            description: function(attack, enemy) {
                return "Deal " + attack.damage(attack, player, enemy) + " damage";
            },
            damage: function(attack, player, enemy) {
                return 6;
            },
            symbols: ["sword"],
            effect: [
                function(attack, enemy) {
                    enemy.dx -= 60;
                    enemy.smashAnim = 1;
                    normalDamage(attack, player, enemy);
                }
            ],
        }, ],
    },
    "scrapling": {
        integrityVals: [13, 17],
        height: 110,
        draw: function(enemy) {
            pushMatrix();
            translate(0, 5);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 11);
            rotate(7);
            rect(0, 0, 16, 10, 5);
            popMatrix();
            pushMatrix();
            translate(-24, 11);
            rotate(-7);
            rect(0, 0, 16, 10, 5);
            popMatrix();

            // left hand
            pushMatrix();
            translate(-46, -20 + sin(frameCount * 3) * 2);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            rotate(60 - enemy.smashAnim * 150);

            stroke(112, 103, 90);
            strokeWeight(8);
            line(0, 10, 0, -130);
            fill(97, 96, 92);

            stroke(0, 0, 0);
            strokeWeight(4);
            rect(-20, -125, 40, 20, 5);

            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-20, -50);
            fill(135, 135, 135);
            rect(0, 0, 40, 50, 10);
            fill(99, 99, 99);
            rect(-5, -5, 50, 20, 10);
            popMatrix();

            // head
            pushMatrix();
            translate(0, cos(frameCount * 3) * -4);
            translate(-42, -91);
            fill(176, 176, 176);
            rect(0, 0, 60, 60, 40);

            // eyes
            pushMatrix();
            translate(0, cos(frameCount * 3) * -2);
            fill(255, 162, 0);
            stroke(163, 118, 35);
            ellipse(40, 36, 15, 15);
            ellipse(4, 28, 15, 15);
            popMatrix();

            // mouth
            pushMatrix();
            translate(0, sin(frameCount * 3));
            translate(19, 46);
            rotate(10 + sin(frameCount * 3 / 2) * 5);
            fill(224, 224, 224);
            stroke(166, 166, 166);
            arc(0, 0, 40, 27, 0, 180);
            line(-20, 0, 20, 0);
            popMatrix();

            popMatrix();
            stroke(0, 0, 0);

            // right hand
            pushMatrix();
            translate(39, -7 + sin(frameCount * 3) * 2);
            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 100],
            ]);
        },
        attacks: [{
            name: "smash",
            description: function(attack, enemy) {
                return "Deal " + attack.damage(attack, player, enemy) + " damage. Apply 1 Weak";
            },
            damage: function(attack, player, enemy) {
                return 4;
            },
            num: 1,
            symbols: ["sword", "debuff"],
            effect: [
                function(attack, enemy) {
                    enemy.dx -= 60;
                    normalDamage(attack, player, enemy);
                    enemy.smashAnim = 1;
                },
                function(attack, enemy) {
                    enemy.dx -= 60;
                    applyEffect("weak", 1, player);
                    enemy.smashAnim = 1;
                },
            ],
        }, ],
    },
    "shield scrapling": {
        integrityVals: [12, 15],
        height: 110,
        draw: function(enemy) {
            pushMatrix();
            translate(0, 5);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 11);
            rotate(7);
            rect(0, 0, 16, 10, 5);
            popMatrix();
            pushMatrix();
            translate(-24, 11);
            rotate(-7);
            rect(0, 0, 16, 10, 5);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-20, -50);
            fill(135, 135, 135);
            rect(0, 0, 40, 50, 10);
            fill(99, 99, 99);
            rect(-5, -5, 50, 20, 10);
            popMatrix();

            // head
            pushMatrix();
            translate(0, cos(frameCount * 3) * -4);
            translate(-42, -91);
            fill(176, 176, 176);
            rect(0, 0, 60, 60, 40);

            // eyes
            pushMatrix();
            translate(0, cos(frameCount * 3) * -2);
            fill(255, 162, 0);
            stroke(163, 118, 35);
            ellipse(40, 36, 15, 15);
            ellipse(4, 28, 15, 15);
            popMatrix();

            // mouth
            pushMatrix();
            translate(0, sin(frameCount * 3));
            translate(19, 46);
            rotate(10 + sin(frameCount * 3 / 2) * 5);
            fill(224, 224, 224);
            stroke(166, 166, 166);
            arc(0, 0, 40, 27, 0, 180);
            line(-20, 0, 20, 0);
            popMatrix();

            popMatrix();
            stroke(0, 0, 0);

            // left hand
            pushMatrix();
            translate(-49, -31 + sin(frameCount * 3) * 2);
            rotate(7 + sin(frameCount * 3) * 5);
            pushMatrix();
            scale(0.7);
            translate(0, -28);

            noStroke();
            stroke(87, 87, 87);
            strokeWeight(8);

            fill(128, 126, 116);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(181, 170, 150);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(89, 89, 89);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();

            popMatrix();

            // right hand
            pushMatrix();
            translate(39, -7 + sin(frameCount * 3) * 2);
            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 50],
                [1, 50],
            ]);
        },
        attacks: [{
                name: "shield bash",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 6;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "protect",
                defense: function(attack, target) {
                    return 7;
                },
                description: function(attack, enemy) {
                    return "Give " + attack.defense(attack, enemy) + " defense to a random enemy";
                },
                symbols: ["shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemies[floor(random(0, enemies.length))]);
                    }
                ],
            },
        ],
    },
    "sharp scrapling": {
        integrityVals: [10, 14],
        height: 120,
        draw: function(enemy) {
            pushMatrix();
            translate(0, 5);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 11);
            rotate(7);
            rect(0, 0, 16, 10, 5);
            popMatrix();
            pushMatrix();
            translate(-24, 11);
            rotate(-7);
            rect(0, 0, 16, 10, 5);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-20, -50);
            fill(135, 135, 135);
            rect(0, 0, 40, 50, 10);
            fill(99, 99, 99);
            rect(-5, -5, 50, 20, 10);
            popMatrix();

            // head
            pushMatrix();
            translate(0, cos(frameCount * 3) * -4);
            translate(-42, -91);
            translate(50, 60);
            rotate(cos(frameCount * 6) * 5);
            translate(-50, -60);
            fill(176, 176, 176);
            rect(0, 0, 60, 60, 40);
            fill(186, 186, 186);
            triangle(20, 5, 25, -15, 30, 5);
            triangle(45, 9, 47, -9, 35, 5);
            triangle(48, 10, 62, 7, 55, 18);

            // eyes
            pushMatrix();
            translate(0, cos(frameCount * 3) * -2);
            fill(255, 251, 0);
            stroke(161, 151, 35);
            ellipse(40, 36, 15, 15);
            ellipse(4, 28, 15, 15);
            popMatrix();

            // mouth
            pushMatrix();
            translate(0, sin(frameCount * 3));
            translate(19, 46);
            rotate(10 + sin(frameCount * 3 / 2) * 5);
            fill(209, 217, 185);
            stroke(166, 166, 166);
            arc(0, 0, 40, 30 + cos(frameCount * 6) * 10, 0, 180);
            line(-20, 0, 20, 0);
            popMatrix();

            popMatrix();
            stroke(0, 0, 0);

            // left hand
            pushMatrix();
            translate(-46, -20 + sin(frameCount * 3) * 2);

            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            popMatrix();

            // right hand
            pushMatrix();
            translate(39, -7 + sin(frameCount * 3) * 2);

            rotate(-81);

            stroke(112, 103, 90);
            strokeWeight(8);
            line(0, 10, 0, -115);
            fill(97, 96, 92);

            stroke(0, 0, 0);
            strokeWeight(4);
            fill(186, 186, 186);
            triangle(0, -143, 10, -115, -10, -115);

            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 100],
            ]);
        },
        attacks: [{
            name: "puncture",
            description: function(attack, enemy) {
                return "Deal " + attack.damage(attack, player, enemy) + " damage";
            },
            damage: function(attack, player, enemy) {
                return 9;
            },
            symbols: ["sword"],
            effect: [
                function(attack, enemy) {
                    enemy.dx -= 60;
                    normalDamage(attack, player, enemy);
                }
            ],
        }, ],
    },
    "scrapling crusher": {
        integrityVals: [23, 25],
        height: 115,
        draw: function(enemy) {
            pushMatrix();
            translate(0, 5);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 11);
            rotate(7);
            rect(0, 0, 16, 10, 5);
            popMatrix();
            pushMatrix();
            translate(-24, 11);
            rotate(-7);
            rect(0, 0, 16, 10, 5);
            popMatrix();

            // left hand
            pushMatrix();
            translate(-46, -20 + sin(frameCount * 3) * 2);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            rotate(60 - enemy.smashAnim * 150);

            stroke(112, 103, 90);
            strokeWeight(8);
            line(0, 33, 0, -155);
            fill(54, 54, 54);

            stroke(0, 0, 0);
            strokeWeight(4);
            rect(-40, -150, 80, 60, 5);

            fill(79, 79, 79);
            ellipse(0, 0, 15, 15);
            ellipse(0, 21, 15, 15);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-20, -50);
            fill(135, 135, 135);
            rect(0, 0, 40, 50, 10);
            fill(99, 99, 99);
            rect(-5, -5, 50, 20, 10);
            popMatrix();

            // head
            pushMatrix();
            translate(0, cos(frameCount * 3) * -4);
            translate(-42, -91);
            fill(176, 176, 176);
            rect(0, 0, 60, 60, 40);

            // eyes
            pushMatrix();
            translate(0, cos(frameCount * 3) * -2);
            fill(207, 83, 112);
            stroke(161, 35, 69);
            ellipse(40, 36, 15, 15);
            ellipse(4, 28, 15, 15);
            popMatrix();

            // mouth
            pushMatrix();
            translate(0, sin(frameCount * 3));
            translate(19, 46);
            rotate(10 + sin(frameCount * 3 / 2) * 5);
            fill(224, 224, 224);
            stroke(166, 166, 166);
            arc(0, 0, 40, 27, 0, 180);
            line(-20, 0, 20, 0);
            popMatrix();

            popMatrix();
            stroke(0, 0, 0);

            popMatrix();
        },
        chooseAttack: function(enemy) {

            if(!enemy.charging) {
                enemy.charging = 0;
            }
            if(enemy.charging >= 2) {
                enemy.charging = -1;
                return 1;
            } else {
                enemy.charging++;
                return 0;
            }
        },
        attacks: [{
                name: "charge",
                description: function(attack, enemy) {
                    return "Charge a powerful attack";
                },
                symbols: ["unknown"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;

                    }
                ],
            },
            {
                name: "whack",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 25;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        enemy.smashAnim = 1;
                    }
                ],
            },
        ],
    },
    "giant acid slime": {
        integrityVals: [65, 69],
        height: 85,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -14);
            scale(1.5);
            pushMatrix();
            var num = cos(frameCount * 3) * 0.04;

            rotate(sin(frameCount * 6) * 2);
            var a = 10;
            translate(0, a);
            scale(1 + num, 0.8 - num);
            translate(0, -a);

            stroke(49, 171, 15);
            strokeWeight(6);
            fill(56, 222, 58, 200);
            ellipse(0, 0, 80, 80);

            popMatrix();
            popMatrix();
        },
        startingEffects: function() {
            return {
                split: 1,
            };
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 30],
                [1, 30],
                [2, 40],
            ]);
        },
        attacks: [{
                name: "corrosive spit",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Shuffle 2 slimed cards into discard";
                },
                damage: function(attack, player, enemy) {
                    return 11;
                },
                symbols: ["sword", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },
            {
                name: "lick",
                num: 2,
                description: function(attack) {
                    return "Apply 2 Weak";
                },
                symbols: ["debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 2, player);
                    },
                ],
            },
            {
                name: "tackle",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 16;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "split",
                description: function(attack, enemy) {
                    return "Split into two smaller slimes";
                },
                symbols: ["unknown"],
                effect: [
                    function(attack, enemy) {
                        for(var i = 0; i < 2; i++) {
                            var enemy2 = new enemyObj("acid slime");
                            enemy2.maxIntegrity = enemy.integrity;
                            enemy2.integrity = enemy2.maxIntegrity;
                            enemies.push(enemy2);
                        }
                        enemy.integrity = 0;
                    }
                ],
            },
        ],
    },
    "giant plasma slime": {
        integrityVals: [65, 69],
        height: 85,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -14);
            scale(1.5);
            pushMatrix();
            var num = cos(frameCount * 3 + 180) * 0.04;

            rotate(sin(frameCount * 6) * 2);
            var a = 10;
            translate(0, a);
            scale(1 + num, 0.8 - num);
            translate(0, -a);

            stroke(15, 155, 171);
            strokeWeight(6);
            fill(68, 195, 199, 200);
            ellipse(0, 0, 80, 80);

            popMatrix();
            popMatrix();
        },
        startingEffects: function() {
            return {
                split: 1,
            };
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 30],
                [1, 70],
            ]);
        },
        attacks: [{
                name: "corrosive spit",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Shuffle 2 slimed cards into discard";
                },
                damage: function(attack, player, enemy) {
                    return 16;
                },
                symbols: ["sword", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },
            {
                name: "lick",
                num: 2,
                description: function(attack) {
                    return "Apply 2 Frail";
                },
                symbols: ["debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("frail", 2, player);
                    },
                ],
            },
            {
                name: "split",
                description: function(attack, enemy) {
                    return "Split into two smaller slimes";
                },
                symbols: ["unknown"],
                effect: [
                    function(attack, enemy) {
                        for(var i = 0; i < 2; i++) {
                            var enemy2 = new enemyObj("plasma slime");
                            enemy2.maxIntegrity = enemy.integrity;
                            enemy2.integrity = enemy2.maxIntegrity;
                            enemies.push(enemy2);
                        }
                        enemy.integrity = 0;
                    }
                ],
            },
        ],
    },
    "enforcer": {
        integrityVals: [46, 50],
        height: 130,
        draw: function(enemy) {
            pushMatrix();
            translate(10, 7);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 10);
            rect(0, 0, 16, 16, 5);
            popMatrix();
            pushMatrix();
            translate(-29, 8);
            rect(0, 0, 16, 16, 5);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-25, -56);
            pushMatrix();
            translate(-9, 6);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            rotate(30 + cos(frameCount * 3) * 8 - enemy.smashAnim * -1080);
            fill(191, 124, 61);
            rect(0, 0, 16, 40, 5);

            stroke(102, 102, 102);
            strokeWeight(8);
            line(-10, 42, 24, 42);
            stroke(135, 135, 135);
            strokeWeight(14);
            line(-10, 42, -62, 42);
            stroke(176, 176, 176);
            strokeWeight(10);
            line(-10, 30, -10, 54);

            stroke(0, 0, 0);
            strokeWeight(4);
            fill(66, 66, 66);
            ellipse(8, 42, 20, 20);
            popMatrix();

            fill(66, 66, 66);
            rect(-15, -2, 25, 25, 10);
            fill(191, 124, 61);
            rect(0, 0, 50, 58, 10);

            pushMatrix();
            translate(39, 13);
            rotate(-30 + cos(frameCount * 3) * -8);
            fill(191, 124, 61);
            rect(0, 0, 16, 43, 5);
            fill(66, 66, 66);
            ellipse(9, 45, 20, 20);
            popMatrix();

            fill(66, 66, 66);
            rect(-5, 0, 60, 20, 10);
            rect(35, 0, 25, 25, 10);
            popMatrix();

            // head
            pushMatrix();
            translate(-37, -116 + sin(frameCount * 3) * 6);
            fill(201, 90, 60);
            rect(0, 0, 60, 60, 40);
            fill(124, 216, 230);
            rect(-12, 16, 60, 20, 5);

            popMatrix();
            stroke(0, 0, 0);

            popMatrix();

        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 40],
                [1, 60],
            ]);
        },
        attacks: [{
                name: "rake",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Apply 1 Weak";
                },
                damage: function(attack, player, enemy) {
                    return 7;
                },
                num: 1,
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        enemy.smashAnim = 1;
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 1, player);
                    },
                ],
            },
            {
                name: "stab",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 12;
                },
                symbols: ["sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 0.2;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
        ],
    },
    "viral vessel": {
        integrityVals: [22, 28],
        height: 95,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -6);
            scale(0.8);
            stroke(0, 0, 0);
            strokeWeight(5);

            var a2 = sin(frameCount * 3) * 5;
            var a3 = cos(frameCount * 3) * 5;
            pushMatrix();
            translate(0, a2);
            noStroke();
            fill(0, 255, 30, 200);
            arc(0, -30, 100, 100, 0 + a3 * 1.5, 180 + a3);
            stroke(56, 56, 56);
            strokeWeight(8);
            fill(191, 191, 191, 100);
            ellipse(0, -30, 100, 100);
            strokeWeight(5);
            stroke(15, 50, 64);
            translate(-6, 0);
            fill(92, 194, 85, 50);
            rect(-64, -66, 68, 30, 15);
            stroke(0, 225, 255, 150);
            strokeWeight(20);
            point(-48 + sin(frameCount * 3) * 18 + 18, -66 + 15);
            stroke(0, 0, 0, 150);
            strokeWeight(8);
            point(-48 + sin(frameCount * 3) * 23 + 18, -66 + 15);
            popMatrix();

            var a = 45 + a2 / 2;
            stroke(56, 56, 56);
            strokeWeight(8);
            line(cos(a) * 50, -30 + sin(a) * 50 + a2, 60, -10 + a2 / 2);
            line(cos(180 - a) * 50, -30 + sin(180 - a) * 50 + a2, -60, -10 + a2 / 2);
            line(60, -10 + a2 / 2, 50, 30);
            line(-60, -10 + a2 / 2, -50, 30);

            popMatrix();
        },
        startingEffects: function() {
            return {
                contaminate: 2,
            };
        },
        chooseAttack: function(enemy) {
            if(enemy.selectedAttack === 1) {
                return 0;
            }
            return manageProbabilities([
                [0, 60],
                [1, 40],
            ]);
        },
        attacks: [{
                name: "ram",
                description: function(attack) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                damage: function(attack, target) {
                    return 6;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "grow",
                description: function(attack) {
                    return "Gain 3 strength";
                },
                num: 3,
                symbols: ["buff", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 3, enemy);
                    },
                ],
            },
        ],
    },
    "looter": {
        integrityVals: [44, 48],
        height: 105,
        draw: function(enemy) {
            pushMatrix();
            translate(8, 7);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 13);
            rect(0, 0, 16, 5, 5);
            popMatrix();
            pushMatrix();
            translate(-29, 13);
            rect(0, 0, 16, 5, 5);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-25, -56);
            pushMatrix();
            translate(-1, 6);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            rotate(30 + cos(frameCount * 3) * 8 - enemy.smashAnim * -100);
            fill(84, 54, 26);
            rect(0, 0, 16, 40, 5);

            stroke(102, 102, 102);
            strokeWeight(8);
            line(-10, 42, 24, 42);

            fill(209, 209, 209);
            stroke(112, 112, 112);
            strokeWeight(4);
            triangle(-10, 34, -10, 50, -49, 42);
            strokeWeight(10);
            line(-10, 30, -10, 54);

            stroke(0, 0, 0);
            strokeWeight(4);
            fill(38, 23, 3);
            ellipse(8, 42, 18, 18);
            popMatrix();
            fill(46, 26, 8);
            rect(0, 0, 40, 58, 10);

            pushMatrix();
            translate(27, 13);
            rotate(-30 + cos(frameCount * 3) * -8);
            fill(84, 54, 26);
            rect(0, 0, 16, 43, 5);
            fill(38, 23, 3);
            ellipse(9, 45, 18, 18);
            popMatrix();
            popMatrix();

            // head
            pushMatrix();
            translate(-34, -86 + sin(frameCount * 3) * 6);
            fill(135, 117, 112);
            rect(0, 0, 40, 50, 40);
            fill(179, 160, 75);
            beginShape();
            vertex(-5, 15);
            vertex(10, 20);
            vertex(25, 15);
            vertex(25, 25);
            vertex(10, 30);
            vertex(-5, 25);
            endShape(CLOSE);

            fill(64, 64, 64);
            rect(-2, 32, 44, 12, 5);

            popMatrix();
            stroke(0, 0, 0);

            popMatrix();
        },
        startingEffects: function() {
            return {
                thievery: 15,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;
            if(enemy.attackCounter < 3) {
                return 0;
            } else if(enemy.attackCounter === 3) {
                return floor(random(1, 3));
            } else {
                if(enemy.selectedAttack === 2) {
                    return 3;
                } else {
                    return 2;
                }
            }
        },
        attacks: [{
                name: "mug",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                symbols: ["sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "lunge",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 12;
                },
                symbols: ["sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "smoke bomb",
                defense: function(attack, target) {
                    return 6;
                },
                description: function(attack, enemy) {
                    return "Gain " + attack.defense(attack, enemy) + " defense";
                },
                symbols: ["shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
            {
                name: "escape",
                description: function(attack) {
                    return "Escape combat, taking all stolen money";
                },
                symbols: ["unknown"],
                effect: [
                    function(attack, enemy) {
                        if(enemies.indexOf(enemy) >= 0) {
                            enemies.splice(enemies.indexOf(enemy), 1);
                        }
                    }
                ],
            },
        ],
    },
    "mugger": {
        integrityVals: [48, 52],
        height: 105,
        draw: function(enemy) {
            pushMatrix();
            translate(10, 7);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 13);
            rect(0, 0, 16, 5, 5);
            popMatrix();
            pushMatrix();
            translate(-29, 13);
            rect(0, 0, 16, 5, 5);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-25, -56);
            pushMatrix();
            translate(-1, 6);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            rotate(30 + cos(frameCount * 3) * 8 - enemy.smashAnim * -100);
            fill(77, 66, 32);
            rect(0, 0, 16, 40, 5);

            stroke(102, 102, 102);
            strokeWeight(8);
            line(-10, 42, 24, 42);

            fill(209, 209, 209);
            stroke(112, 112, 112);
            strokeWeight(4);
            triangle(-10, 34, -10, 50, -60, 42);
            strokeWeight(10);
            line(-10, 30, -10, 54);

            stroke(0, 0, 0);
            strokeWeight(4);
            fill(38, 23, 3);
            ellipse(8, 42, 18, 18);
            popMatrix();
            fill(46, 26, 8);
            rect(0, 0, 40, 58, 10);

            pushMatrix();
            translate(27, 13);
            rotate(-30 + cos(frameCount * 3) * -8);
            fill(77, 66, 32);
            rect(0, 0, 16, 43, 5);
            fill(38, 23, 3);
            ellipse(9, 45, 18, 18);
            popMatrix();
            popMatrix();

            // head
            pushMatrix();
            translate(-34, -86 + sin(frameCount * 3) * 6);
            fill(135, 117, 112);
            rect(0, 0, 50, 50, 40);
            translate(5, 0);
            fill(179, 75, 101);
            beginShape();
            vertex(-10, 15);
            vertex(10, 20);
            vertex(30, 15);
            vertex(30, 25);
            vertex(10, 30);
            vertex(-10, 25);
            endShape(CLOSE);

            fill(64, 64, 64);
            rect(-7, 32, 54, 12, 5);

            popMatrix();
            stroke(0, 0, 0);

            popMatrix();
        },
        startingEffects: function() {
            return {
                thievery: 15,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;
            if(enemy.attackCounter < 3) {
                return 0;
            } else if(enemy.attackCounter === 3) {
                return floor(random(1, 3));
            } else {
                if(enemy.selectedAttack === 2) {
                    return 3;
                } else {
                    return 2;
                }
            }
        },
        attacks: [{
                name: "mug",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                symbols: ["sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "lunge",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 16;
                },
                symbols: ["sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "smoke bomb",
                defense: function(attack, target) {
                    return 11;
                },
                description: function(attack, enemy) {
                    return "Gain " + attack.defense(attack, enemy) + " defense";
                },
                symbols: ["shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
            {
                name: "escape",
                description: function(attack) {
                    return "Escape combat, taking all stolen money";
                },
                symbols: ["unknown"],
                effect: [
                    function(attack, enemy) {
                        if(enemies.indexOf(enemy) >= 0) {
                            enemies.splice(enemies.indexOf(enemy), 1);
                        }
                    }
                ],
            },
        ],
    },
    "orb sentinel": {
        integrityVals: [20, 20],
        height: 140,
        draw: function(enemy) {
            pushMatrix();
            scale(0.8);

            translate(0, -100 + sin(frameCount * 3 / 2) * 10);

            stroke(105, 105, 105);
            strokeWeight(8);
            line(-20, -20, -40, -50 + sin(frameCount * 3 / 2) * 5);
            line(-71 + cos(frameCount * 3 / 2) * 5, -20 + sin(frameCount * 3 / 2) * 10, -40, -50 + sin(frameCount * 3 / 2) * 5);

            pushMatrix();
            translate(cos(frameCount * 3 / 2) * 5, sin(frameCount * 3 / 2) * 10);
            rotate(-16);
            scale(0.7);
            translate(-99, -69);

            noStroke();
            stroke(0, 109, 117);
            strokeWeight(8);

            fill(55, 131, 150);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(111, 175, 191);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(0, 109, 117);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();

            strokeWeight(5);
            stroke(0, 109, 117);
            fill(111, 175, 191);
            ellipse(0, 0, 80, 80);

            stroke(0, 0, 0);
            var a = 160 + sin(frameCount * 3) * 20 + sin(frameCount * 3 / 4) * 20;
            fill(127, 150, 156);
            ellipse(cos(a) * 30, sin(a) * 30, 40, 40);
            noStroke();
            fill(217, 80, 119);
            ellipse(cos(a) * 30 - 8 + cos(frameCount * 3) * 3, sin(a) * 30, 10, 20);

            stroke(105, 105, 105);
            strokeWeight(8);
            line(15, -10, 54, -50 + sin(frameCount * 3 / 2) * 5);
            line(57, -10, 54, -50 + sin(frameCount * 3 / 2) * 5);

            popMatrix();
        },
        startingEffects: function(enemy) {
            enemy.defense = 40;
            return {
                barricade: 1,
                artifact: 3,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;
            if(enemy.attackCounter === 1) {
                return 0;
            } else if(enemy.attackCounter === 2) {
                return 1;
            } else {
                if(enemy.attackCounter % 2 === 0) {
                    return 2;
                } else {
                    return 3;
                }
            }
        },
        attacks: [{
                name: "activate",
                defense: function(attack, target) {
                    return 25;
                },
                description: function(attack, enemy) {
                    return "Gain " + attack.defense(attack, enemy) + " defense";
                },
                symbols: ["shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
            {
                name: "smash",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Apply 5 Frail";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                num: 5,
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("frail", 5, player);
                    },
                ],
            },
            {
                name: "harden",
                damage: function(attack, target) {
                    return 10;
                },
                defense: function(attack, target) {
                    return 15;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage. Gain " + attack.defense(attack, enemy) + " defense";
                },
                symbols: ["sword", "shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
            {
                name: "slam",
                damage: function(attack, target) {
                    return 10;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, twice";
                },
                symbols: ["sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
        ],
    },
    "ascended": {
        integrityVals: [95, 99],
        height: 158,
        draw: function(enemy) {
            pushMatrix();
            translate(10, -6);

            stroke(112, 142, 161);
            strokeWeight(4);
            fill(180, 205, 212);
            beginShape();
            vertex(42, 23);
            vertex(22, 43);
            vertex(-22, 40);
            vertex(-43, 23);
            vertex(-23, -67);
            vertex(20, -67);
            endShape(CLOSE);
            noStroke();
            fill(232, 238, 240);
            beginShape();
            vertex(35, 23);
            vertex(22, 32);
            vertex(5, 27);
            vertex(21, 23);
            vertex(6, -67);
            vertex(15, -67);
            endShape(CLOSE);

            pushMatrix();
            translate(18, -69 + sin(frameCount * 3) * 5);
            pushMatrix();
            rotate(-30 + sin(frameCount * 3) * 5);
            stroke(61, 61, 61);
            fill(120, 120, 120);
            rect(-70, -50, 75, 60, 10);
            line(5, -25, -30, -25);
            line(5, -15, -8, -15);
            popMatrix();
            translate(-4, 0);
            fill(179, 57, 209);
            rect(-83, -2, 40, 20, 10);
            popMatrix();

            pushMatrix();
            translate(-7, -111 + sin(frameCount * 3) * 8);
            rotate(sin(frameCount * 6) * 10);
            stroke(255, 221, 0);
            noFill();
            strokeWeight(8);
            ellipse(0, 0, 60, 20);
            popMatrix();

            pushMatrix();
            translate(-50, -5 + cos(frameCount * 3) * -10);
            scale(3);
            noStroke();
            fill(167, 24, 186);
            ellipse(0, 0, 18, 18);
            fill(201, 100, 217);
            ellipse(0, 0, 12, 12);
            fill(231, 197, 237);
            ellipse(0, 0, 5, 5);
            stroke(111, 235, 235);
            strokeWeight(1);

            pushMatrix();
            rotate(floor(frameCount / 10) * 100);
            line(-1, 0, 3, 3);
            line(2, -4, 3, 3);
            line(2, -4, -6, -1);
            line(3, 8, -6, -1);
            line(3, 8, 9, -4);
            line(-4, -10, 9, -4);
            line(-4, -10, -10, 1);
            popMatrix();
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;
            if(enemy.attackCounter === 1) {
                return 0;
            } else if(enemy.attackCounter === 2) {
                return 1;
            } else {
                if(enemy.attackCounter % 2 === 0) {
                    return manageProbabilities([
                        [0, 60],
                        [2, 40],
                    ]);
                } else {
                    return manageProbabilities([
                        [3, 50],
                        [4, 50],
                    ]);
                }
            }
        },
        attacks: [{
                name: "aggress",
                damage: function(attack, target) {
                    return 5;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, twice";
                },
                symbols: ["sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "hex",
                description: function(attack, enemy) {
                    return "Apply 1 Hex";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                num: 1,
                symbols: ["debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("hex", 1, player);
                    },
                ],
            },
            {
                name: "zap",
                damage: function(attack, target) {
                    return 18;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                symbols: ["sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },

            {
                name: "debilitate",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Apply 2 Vulnerable";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                num: 2,
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("vulnerable", 2, player);
                    },
                ],
            },
            {
                name: "drain",
                description: function(attack, enemy) {
                    return "Apply 3 Weak. Gain 3 Strength";
                },
                num: 3,
                symbols: ["debuff", "buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 3, player);
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 3, enemy);
                    },
                ],
            },
        ],
    },
    "shellwrecker": {
        integrityVals: [68, 72],
        height: 125,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -14);

            var a2 = sin(frameCount * 3) * -5;
            pushMatrix();
            translate(0, a2);
            stroke(0, 0, 0);
            strokeWeight(4);
            fill(59, 59, 59);
            ellipse(0, 0, 80, 80);
            stroke(87, 34, 16);
            fill(135, 49, 20);
            ellipse(15, 22, 10, 10);
            ellipse(-26, 16, 10, 10);
            popMatrix();

            stroke(0, 0, 0);
            strokeWeight(4);
            var a = 45 + a2 / 2;
            line(cos(a) * 40, sin(a) * 40 + a2, 50, 10 + a2 / 2);
            line(cos(180 - a) * 40, sin(180 - a) * 40 + a2, -50, 10 + a2 / 2);
            line(50, 10 + a2 / 2, 40, 40);
            line(-50, 10 + a2 / 2, -40, 40);

            pushMatrix();
            scale(1);
            rotate(190);
            translate(3, 2 + sin(frameCount * 3) * 3);

            noStroke();
            stroke(64, 45, 45);
            strokeWeight(4);

            fill(97, 61, 61);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(128, 92, 92);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(64, 45, 45);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();

            popMatrix();
        },
        startingEffects: function() {
            return {
                plated: 14,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 1;
                return manageProbabilities([
                    [0, 50],
                    [1, 50],
                ]);
            }
            return manageProbabilities([
                [0, 40],
                [1, 40],
                [2, 20],
            ]);
        },
        attacks: [{
                name: "double strike",
                damage: function(attack, target) {
                    return 6;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, twice";
                },
                symbols: ["sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "leech",
                damage: function(attack, target) {
                    return 10;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage. Regain integrity equal to unblocked damage";
                },
                symbols: ["sword", "buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.lifeTrackNumber = player.integrity;
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        if(player.integrity < enemy.lifeTrackNumber) {
                            enemy.integrity += enemy.lifeTrackNumber - player.integrity;
                            enemy.integrity = constrain(enemy.integrity, -999, enemy.maxIntegrity);
                        }
                    },
                ],
            },
            {
                name: "fell",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Apply 2 Frail";
                },
                damage: function(attack, player, enemy) {
                    return 18;
                },
                num: 2,
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("frail", 2, player);
                    },
                ],
            },
        ],
    },
    "drone": {
        integrityVals: [25, 31],
        height: 170,
        draw: function(enemy) {
            pushMatrix();
            if(!enemy.flyAnim) {
                enemy.flyAnim = 0;
            }
            if(enemy.effects.flying) {
                enemy.flyAnim = lerp(enemy.flyAnim, 1, 0.05);
            } else {
                enemy.flyAnim = lerp(enemy.flyAnim, -0.2, 0.05);
                if(enemy.flyAnim < 0) {
                    enemy.flyAnim = 0;
                }
            }
            translate(0, -80 * enemy.flyAnim);
            translate(cos(frameCount * 3) * 5 * enemy.flyAnim, sin(frameCount * 3) * 5 * enemy.flyAnim);
            rotate((-5 + cos(frameCount * 3) * -7) * enemy.flyAnim);

            var nf = 1 - enemy.flyAnim;

            translate(-25 * nf, 38 * nf);
            rotate((41 - abs(cos(frameCount * 3) * -7)) * nf);

            pushMatrix();
            translate(0, -50);
            stroke(176, 176, 176);
            strokeWeight(8);
            line(-10, 0, -29, -3);
            line(10, 0, -15, -10);
            stroke(193, 220, 227);
            strokeWeight(4);
            pushMatrix();
            translate(-30, -7);
            rotate(10);
            line(cos(frameCount * 15) * 10, 0, cos(frameCount * 15) * -10, 0);
            popMatrix();

            stroke(0, 0, 0);
            strokeWeight(4);
            pushMatrix();
            translate(0, sin(frameCount * 3) * 3);
            line(0, 0, 0, 30);
            line(-20, 30, 0, 30);
            line(-10, 30, -10, 40);
            line(-20, 40, -10, 40);
            stroke(21, 235, 196);
            strokeWeight(4);
            var a = -18 + sin(frameCount * 30);
            line(-18, 37, a, 35);
            line(-18, 33, a, 35);
            popMatrix();
            stroke(0, 0, 0);
            strokeWeight(4);
            fill(128, 128, 128);
            rect(-25, -15, 50, 30, 5);
            fill(190, 94, 209);
            ellipse(-25, 6, 10, 14);

            stroke(176, 176, 176);
            strokeWeight(8);
            line(-10, 0, -2, 2);
            line(10, 0, 37, 4);

            stroke(193, 220, 227);
            strokeWeight(4);
            pushMatrix();
            translate(38, 0);
            rotate(10);
            line(cos(frameCount * 15) * 10, 0, cos(frameCount * 15) * -10, 0);
            popMatrix();
            pushMatrix();
            translate(0, -2);
            rotate(10);
            line(cos(frameCount * 15 + 90) * 10, 0, cos(frameCount * 15 + 90) * -10, 0);
            popMatrix();
            popMatrix();

            popMatrix();
        },
        startingEffects: function(enemy) {
            enemy.flyCounter = 3;
            return {
                flying: 3,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.effects.flying) {
                if(!enemy.noFlyCounter) {
                    enemy.noFlyCounter = 0;
                }
                enemy.noFlyCounter++;
                if(enemy.noFlyCounter === 1) {
                    return 2;
                } else {
                    return 4;
                }
            } else {
                enemy.noFlyCounter = 0;
            }

            if(!enemy.attackCounter) {
                enemy.attackCounter = 1;
                return manageProbabilities([
                    [0, 62],
                    [3, 38],
                ]);
            }
            return manageProbabilities([
                [0, 50],
                [1, 20],
                [3, 30],
            ]);
        },
        attacks: [{
                name: "discharge",
                damage: function(attack, target) {
                    return 1;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, five times";
                },
                symbols: ["sword", "sword", "sword", "sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        stackTimer += 300;
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        stackTimer += 300;
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        stackTimer += 300;
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        stackTimer += 300;
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "blast",
                damage: function(attack, target) {
                    return 12;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "zap",
                damage: function(attack, target) {
                    return 3;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "charge",
                description: function(attack, enemy) {
                    return "Gain 1 strength";
                },
                symbols: ["buff"],
                num: 1,
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 1, enemy);
                    },
                ],
            },
            {
                name: "fly",
                description: function(attack, enemy) {
                    return "Gain 3 flying";
                },
                symbols: ["buff"],
                num: 3,
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("flying", 3, enemy);
                        enemy.flyCounter = 3;
                    },
                ],
            },
            {
                name: "stunned",
                description: function(attack, enemy) {
                    return "Does not attack";
                },
                symbols: [""],
                effect: [],
            },
        ],
    },
    "sentry": {
        integrityVals: [38, 42],
        height: 145,
        draw: function(enemy) {
            pushMatrix();

            translate(cos(frameCount * 3) * -5, sin(frameCount * 3) * 10);

            strokeWeight(4);
            pushMatrix();
            translate(sin(frameCount * 3 / 2) * 5 - 2, cos(frameCount * 3) * 3);
            stroke(26, 146, 186);
            fill(17, 233, 240);
            ellipse(0, -50, 40, 40);
            noStroke();
            fill(49, 194, 196);
            ellipse(0 + cos(frameCount * 3 / 2) * -4, -50 + sin(frameCount * 3 / 2) * 2, 20, 20);
            popMatrix();

            pushMatrix();
            stroke(102, 102, 102);
            fill(143, 143, 143);
            translate(0, sin(frameCount * 3) * 4);
            triangle(0, 20, 30, -30, -30, -30);
            translate(0, sin(frameCount * 3) * -8);
            triangle(0, -120, 30, -70, -30, -70);
            popMatrix();

            pushMatrix();
            translate(sin(frameCount * 3 / 2) * 5 - 2, cos(frameCount * 3) * 3);
            if(!enemy.beamAim) {
                enemy.beamAim = 0;
            } else {
                enemy.beamAim = lerp(enemy.beamAim, 0, 0.1);
            }
            // enemy.beamAim = 1;
            var a = ((-frameCount * 3 / 2 + 180) % 360) * (1 - enemy.beamAim) + 540 * enemy.beamAim;
            var a2 = 1000;
            stroke(17, 233, 240);
            if(enemy.beamWidth) {
                enemy.beamWidth = lerp(enemy.beamWidth, 2, 0.05);
            }
            strokeWeight(enemy.beamWidth || 2);
            line(0 + cos(frameCount * 3 / 2) * -4, -50 + sin(frameCount * 3 / 2) * 2, cos(a) * a2, -50 + sin(a) * a2);
            popMatrix();

            popMatrix();
        },
        startingEffects: function(enemy) {
            return {
                artifact: 1,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.selectedAttack) {
                return 1;
            }
            return 0;
        },
        attacks: [{
                name: "beam",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 9;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        // enemy.dx -= 60;
                        enemy.beamAim = 1;
                        enemy.beamWidth = 50;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "bolt",
                description: function(attack, enemy) {
                    return "Shuffle 2 Undefined cards into discard";
                },
                symbols: ["debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        // enemy.dx -= 60;
                        enemy.beamAim = 1;
                        enemy.beamWidth = 50;
                        var card2 = new cardObj("undefined", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        // enemy.dx -= 60;
                        enemy.beamAim = 1;
                        enemy.beamWidth = 50;
                        var card2 = new cardObj("undefined", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },

        ],
    },
    "biomanipulator": {
        integrityVals: [75, 79],
        height: 185,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -14);

            var a2 = sin(frameCount * 3) * -5;
            pushMatrix();
            translate(0, a2);
            stroke(0, 0, 0);
            strokeWeight(4);
            fill(59, 59, 59);
            ellipse(0, 0, 80, 80);
            stroke(87, 34, 16);
            fill(135, 49, 20);
            ellipse(15, 22, 10, 10);
            fill(46, 140, 95);
            stroke(16, 87, 16);
            ellipse(-26, 16, 10, 10);
            popMatrix();

            stroke(0, 0, 0);
            strokeWeight(4);
            var a = 45 + a2 / 2;
            line(cos(a) * 40, sin(a) * 40 + a2, 50, 10 + a2 / 2);
            line(cos(180 - a) * 40, sin(180 - a) * 40 + a2, -50, 10 + a2 / 2);
            line(50, 10 + a2 / 2, 40, 40);
            line(-50, 10 + a2 / 2, -40, 40);
            line(cos(a) * 40, -sin(a) * 40 + a2, 50, -10 + a2 / 2);
            line(cos(180 - a) * 40, -sin(180 - a) * 40 + a2, -50, -10 + a2 / 2);
            line(50, -10 + a2 / 2, 40, -40 + sin(frameCount * 3) * 4);
            line(-50, -10 + a2 / 2, -40, -40 + sin(frameCount * 3) * 4);
            pushMatrix();
            translate(0, a2);
            line(-40, 0, -60, 0 + cos(frameCount * 3) * 10);
            line(40, 0, 60, 0 + cos(frameCount * 3) * 10);
            line(-70, 17 + cos(frameCount * 3) * 15, -60, 0 + cos(frameCount * 3) * 10);
            line(70, 17 + cos(frameCount * 3) * 15, 60, 0 + cos(frameCount * 3) * 10);
            popMatrix();
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4);
            pushMatrix();
            {
                translate(-14, -107);
                scale(1, -1);
                rotate(sin(frameCount * 12) * 5);

                stroke(222, 145, 217);
                strokeWeight(8);
                noFill();
                beginShape();
                vertex(134, 13);

                vertex(63, 12);
                curveVertex(134, -4 + cos(frameCount * 12) * 5);
                vertex(264 + sin(frameCount * 12) * 60, -152);
                endShape();

                stroke(117, 117, 117);
                strokeWeight(4);
                // noStroke();

                fill(189, 189, 189);
                pushMatrix();
                translate(-157, -115);
                beginShape();
                vertex(103, 125);
                bezierVertex(102, 128, 166, 171, 232, 126);
                bezierVertex(221, 77, 136, 60, 102, 128);
                endShape();
                popMatrix();
                pushMatrix();
                translate(-30, 7);
                rotate(10 + cos(frameCount * 12) * -15);

                translate(-157, -110);
                noStroke();
                fill(230, 230, 230);
                rect(103, 121, 10, 20, 5);

                stroke(117, 117, 117);
                fill(163, 163, 163);
                pushMatrix();
                translate(175, 82);
                rotate(126);
                ellipse(0, 0, 20, 10);
                popMatrix();
                pushMatrix();
                translate(144, 80);
                rotate(78);
                ellipse(0, 0, 20, 10);
                popMatrix();
                beginShape();
                vertex(103, 125);
                bezierVertex(102, 128, 141, 144, 176, 118);
                bezierVertex(184, 77, 147, 60, 102, 128);
                endShape();
                stroke(222, 145, 217);
                strokeWeight(16);
                point(103, 126);
                strokeWeight(10);
                stroke(0, 0, 0);
                point(161, 105);
                popMatrix();
                stroke(222, 145, 217);
                strokeWeight(12);
                pushMatrix();
                line(-18, 37, -5, 25);
                line(56, 30, 45, 20);
                popMatrix();
            }
            stroke(80, 102, 78);
            noFill();
            arc(30, 0, 30, 80, -97, 101);
            arc(5, 0, 30, 80, -97, 101);
            line(20, 0, 45, 0);
            line(5, 40, 30, 40);
            line(-30, -40, 55, -40);
            popMatrix();

            fill(102, 133, 100);
            // stroke(0, 0, 0);
            strokeWeight(4);
            stroke(80, 102, 78);
            pushMatrix();
            translate(0, -56);
            rect(-70, -10, 140, 24, 5);
            strokeWeight(8);
            stroke(52, 190, 224);
            line(-50, 3, 10 + cos(frameCount * 3 / 2) * 40, 3);
            stroke(230, 41, 41);
            point(-55, -5);
            stroke(41, 230, 98);
            point(-45, -5);
            stroke(41, 92, 230);
            point(-35, -5);
            popMatrix();
            popMatrix();

            popMatrix();
        },
        startingEffects: function(enemy) {
            enemy.malleableCounter = 3;
            return {
                malleable: 3,
            };
        },
        chooseAttack: function(enemy) {
            if(enemy.chosenAttack === 1) {
                return 0;
            }
            return manageProbabilities([
                [0, 65],
                [1, 35],
            ]);
        },
        attacks: [{
                name: "triple strike",
                damage: function(attack, target) {
                    return 7;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, three times";
                },
                symbols: ["sword", "sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "fell",
                description: function(attack, enemy) {
                    return "Apply 2 Weak. Apply 2 Frail";
                },
                num: 2,
                symbols: ["debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 2, player);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("frail", 2, player);
                    },
                ],
            },
        ],
    },
    "CHAOS bot": {
        integrityVals: [114, 120],
        height: 150,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -6);

            strokeWeight(4);
            var rc = [abs(cos(frameCount * 3 / 4)) * (255 / 1.5), abs(cos(frameCount * 5 / 4)) * (255 / 1.5), abs(cos(frameCount * 7 / 4)) * (255 / 1.5)];

            // left arm
            pushMatrix();
            translate(-45, 11 + sin(frameCount * 3) * -3);
            rotate(30);
            noFill();
            stroke(rc[0] * 0.6, rc[1] * 0.6, rc[2] * 0.6);
            arc(0, 0, 20, 15, 180, 360);
            popMatrix();

            // wheel
            pushMatrix();
            translate(0, 26);
            fill(rc[0] * 0.7, rc[1] * 0.7, rc[2] * 0.7);
            stroke(rc[0] * 0.6, rc[1] * 0.6, rc[2] * 0.6);
            ellipse(0, 0, 20, 20);
            popMatrix();
            translate(0, 15);
            rotate(sin(frameCount * 3 / 2) * 5);
            translate(0, -15);
            // torso
            pushMatrix();
            translate(0, 2 + sin(frameCount * 3) * 3);
            fill(rc[0], rc[1], rc[2]);
            stroke(rc[0] * 0.8, rc[1] * 0.8, rc[2] * 0.8);
            rect(-15, -15, 30, 30, 5);
            popMatrix();
            rotate(sin(frameCount * 3 / 2) * 15);
            // head
            pushMatrix();
            translate(0, -40 + sin(frameCount * 3) * 5);
            fill(rc[0], rc[1], rc[2]);
            stroke(rc[0] * 0.8, rc[1] * 0.8, rc[2] * 0.8);
            rect(-30, -30, 60, 60, 5);

            line(0, -30, 0, -42);
            ellipse(24, -66, 15, 28);
            ellipse(12, -66, 15, 41);
            ellipse(0, -66, 15, 50);
            ellipse(-12, -66, 15, 41);
            ellipse(-24, -66, 15, 28);

            fill(rc[0] * 1.5, rc[1] * 1.5, rc[2] * 1.5);
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4);
            translate(-8, 12);
            rotate(10 + sin(frameCount * 3 / 2) * 5);
            noStroke();
            arc(0, 0, 40, 40, 0, 180);
            popMatrix();
            translate(0, sin(frameCount * 3) * 3);
            var a = 8 + sin(frameCount * 6) * 3;
            var a2 = 8 + cos(frameCount * 6) * 3;
            ellipse(18, 0, a, a);
            ellipse(-27, -10, a2, a2);
            popMatrix();

            // right arm
            pushMatrix();
            translate(41, 11 + cos(frameCount * 3) * 3);
            rotate(-30);
            noFill();
            stroke(rc[0] * 0.6, rc[1] * 0.6, rc[2] * 0.6);
            arc(0, 0, 20, 15, 180, 360);
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 1;
                return 0;
            }
            return manageProbabilities([
                [1, 40],
                [2, 60],
            ]);
        },
        attacks: [{
                name: "CHAOS",
                description: function(attack, enemy) {
                    return "Apply 1 CHAOS";
                },
                symbols: ["debuff", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("CHAOS", 1, player);
                    },
                ],
            },
            {
                name: "smash",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Apply 2 Vulnerable";
                },
                damage: function(attack, player, enemy) {
                    return 8;
                },
                num: 2,
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("vulnerable", 2, player);
                    },
                ],
            },
            {
                name: "ram",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 15;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },

        ],
    },
    "centurion": {
        integrityVals: [76, 80],
        height: 138,
        draw: function(enemy) {
            pushMatrix();
            translate(10, 9);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(8, 10);
            rect(0, 0, 16, 10, 5);
            popMatrix();
            pushMatrix();
            translate(-29, 8);
            rect(0, 0, 16, 10, 5);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-25, -56);
            pushMatrix();
            translate(-9, 6);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            rotate(30 + cos(frameCount * 3) * 8 - enemy.smashAnim * -100);
            fill(91, 101, 156);
            rect(0, 0, 16, 40, 5);

            stroke(102, 102, 102);
            strokeWeight(8);
            line(-10, 42, 24, 42);

            fill(209, 209, 209);
            stroke(112, 112, 112);
            strokeWeight(4);
            beginShape();
            vertex(-10, 34);
            vertex(-10, 50);
            vertex(-60, 48);
            vertex(-60, 36);
            endShape(CLOSE);
            strokeWeight(10);

            stroke(176, 176, 176);
            strokeWeight(10);
            line(-10, 30, -10, 54);

            stroke(0, 0, 0);
            strokeWeight(4);
            fill(163, 163, 163);
            ellipse(8, 42, 20, 20);
            popMatrix();

            fill(163, 163, 163);
            rect(-15, -2, 25, 25, 10);
            fill(146, 156, 209);
            rect(0, 0, 50, 58, 10);

            pushMatrix();
            translate(39, 13);
            rotate(-30 + cos(frameCount * 3) * -8);
            fill(91, 101, 156);
            rect(0, 0, 16, 43, 5);
            fill(163, 163, 163);
            ellipse(9, 45, 20, 20);
            popMatrix();

            fill(163, 163, 163);
            rect(-5, 0, 60, 20, 10);
            rect(35, 0, 25, 25, 10);
            popMatrix();

            // head
            pushMatrix();
            translate(-37, -105 + sin(frameCount * 3) * 6);
            fill(0, 0, 0);
            rect(0, 0, 60, 60, 40);
            stroke(0, 255, 242);
            strokeWeight(8);
            point(18, 30);
            point(42, 30);
            strokeWeight(4);
            stroke(64, 64, 64);
            // noStroke();
            fill(107, 107, 107);
            beginShape();
            vertex(70, 18);
            vertex(50, 70);
            vertex(35, 62);
            vertex(50, 21);
            vertex(44, 10);
            vertex(30, 21);
            vertex(16, 10);
            vertex(10, 21);
            vertex(25, 62);
            vertex(10, 70);
            vertex(-10, 18);
            vertex(10, -18);
            vertex(30, -3);
            vertex(50, -18);
            endShape(CLOSE);

            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(enemies.length >= 2) {
                return manageProbabilities([
                    [0, 65],
                    [2, 35],
                ]);
            } else {
                return manageProbabilities([
                    [0, 65],
                    [1, 35],
                ]);
            }
        },
        attacks: [{
                name: "slash",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 12;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "fury",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage, three times";
                },
                damage: function(attack, player, enemy) {
                    return 6;
                },
                symbols: ["sword", "sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "defend",
                defense: function(attack, target) {
                    return 15;
                },
                description: function(attack, enemy) {
                    return "Give " + attack.defense(attack, enemy) + " defense to another enemy";
                },
                symbols: ["shield"],
                effect: [
                    function(attack, enemy) {
                        if(enemies.length >= 2) {
                            enemy.dy += 20;
                            var selection = floor(random(0, enemies.length));
                            while(selection === enemies.indexOf(enemy)) {
                                selection = floor(random(0, enemies.length));
                            }
                            normalDefend(attack, enemies[selection]);
                        }
                    }
                ],
            },
        ],
    },
    "healer": {
        integrityVals: [48, 56],
        height: 140,
        draw: function(enemy) {
            pushMatrix();
            translate(10, -6);

            stroke(209, 203, 92);
            strokeWeight(4);
            fill(235, 233, 176);
            beginShape();
            vertex(42, 23);
            vertex(22, 43);
            vertex(-22, 40);
            vertex(-43, 23);
            vertex(-23, -67);
            vertex(20, -67);
            endShape(CLOSE);
            noStroke();
            fill(191, 190, 112);
            beginShape();
            vertex(35, 23);
            vertex(22, 32);
            vertex(5, 27);
            vertex(21, 23);
            vertex(6, -67);
            vertex(15, -67);
            endShape(CLOSE);

            pushMatrix();
            translate(-24, -22);
            noStroke();
            fill(214, 43, 43);
            rect(0, 0, 10, 30, 4);
            rect(-8, 10, 28, 10, 4);
            popMatrix();

            pushMatrix();
            translate(18, -69 + sin(frameCount * 3) * 5);
            pushMatrix();
            rotate(-30 + sin(frameCount * 3) * 5);
            stroke(61, 61, 61);
            fill(120, 120, 120);
            rect(-70, -50, 75, 60, 10);
            line(5, -25, -30, -25);
            line(5, -15, -8, -15);
            popMatrix();
            translate(-4, 0);
            fill(219, 218, 143);
            rect(-83, -2, 40, 20, 10);
            popMatrix();
            popMatrix();
        },
        chooseAttack: function(enemy) {
            for(var i = 0; i < enemies.length; i++) {
                if(enemies[i].integrity <= enemies[i].maxIntegrity - 16) {
                    return 0;
                }
            }
            return manageProbabilities([
                [1, 40],
                [2, 60],
            ]);
        },
        attacks: [{
                name: "heal",
                description: function(attack, enemy) {
                    return "Heal all enemies for 16";
                },
                symbols: ["buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        for(var i = 0; i < enemies.length; i++) {
                            enemies[i].integrity = constrain(enemies[i].integrity + 16, -999, enemies[i].maxIntegrity);
                        }
                    }
                ],
            },
            {
                name: "buff",
                description: function(attack, enemy) {
                    return "Apply 2 strength to all enemies";
                },
                num: 2,
                symbols: ["buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        for(var i = 0; i < enemies.length; i++) {
                            applyEffect("strength", 2, enemies[i]);
                        }
                    }
                ],
            },
            {
                name: "smash",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Apply 2 Frail";
                },
                damage: function(attack, player, enemy) {
                    return 8;
                },
                num: 2,
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("frail", 2, player);
                    },
                ],
            },
        ],
    },
    "strider": {
        integrityVals: [90, 96],
        height: 155,
        draw: function(enemy) {
            pushMatrix();
            translate(-16, -33);

            strokeWeight(4);

            translate(0, sin(frameCount * 3) * 5);

            // leg
            pushMatrix();
            translate(-29, -14);
            pushMatrix();
            translate(0, -sin(frameCount * 3) * 5);
            stroke(54, 54, 54);
            strokeWeight(10);
            line(38, -11 + sin(frameCount * 3) * 5, 62, 20);
            line(36, 70, 62, 20);
            popMatrix();

            strokeWeight(4);
            stroke(212, 167, 70);
            fill(214, 186, 83);
            pushMatrix();
            translate(37, -24);
            rotate(30 + sin(frameCount * 3 / 2) * 10);
            ellipse(0, 0, 20, 40);
            popMatrix();
            popMatrix();

            pushMatrix();
            rotate(25 + sin(frameCount * 3 / 2) * 5);

            // translate(0+sin(frameCount*3)*-10,0);
            // translate(-50,-20);
            pushMatrix();
            translate(0, sin(frameCount * 3) * 5);
            // cannon
            pushMatrix();
            translate(-81, -29);
            rotate(-30);

            stroke(0, 230, 255);
            if(enemy.beamWidth) {
                enemy.beamWidth = lerp(enemy.beamWidth, 2, 0.05);
            }
            strokeWeight(enemy.beamWidth || 2);
            line(-1, 10, -1000, 10);

            strokeWeight(4);
            stroke(51, 51, 51);
            fill(74, 74, 74);
            rect(20, 0, 60, 10, 5);
            rect(5, 10, 60, 10, 5);
            rect(-10, 5, 80, 10, 5);
            popMatrix();

            // body
            stroke(110, 110, 110);
            fill(163, 163, 163);
            pushMatrix();
            translate(0, -50);
            rotate(-10);
            ellipse(0, 0, 80, 40);
            popMatrix();
            pushMatrix();
            translate(20, -66);
            rotate(3);
            ellipse(0, 0, 60, 30);
            popMatrix();

            // shell
            stroke(212, 167, 70);
            fill(214, 186, 83);
            beginShape();
            vertex(-50, -42);
            vertex(-12, -56);
            vertex(2, -73);
            vertex(57, -78);
            vertex(46, -100);
            vertex(5, -109);
            vertex(-26, -88);
            vertex(-67, -47);
            endShape(CLOSE);
            popMatrix();
            popMatrix();
            // leg
            pushMatrix();
            translate(0, -sin(frameCount * 3) * 5);
            stroke(54, 54, 54);
            strokeWeight(10);
            line(38, -11 + sin(frameCount * 3) * 5, 62, 20);
            line(36, 70, 62, 20);
            popMatrix();

            strokeWeight(4);
            stroke(212, 167, 70);
            fill(214, 186, 83);
            pushMatrix();
            translate(37, -24);
            rotate(30 + sin(frameCount * 3 / 2) * 10);
            ellipse(0, 0, 20, 40);
            popMatrix();

            popMatrix();
        },
        startingEffects: function(enemy) {
            return {
                ritual: 3,
            };
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 60],
                [1, 40],
            ]);
        },
        attacks: [{
                name: "laser",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Shuffle one NaN card into draw, and one NaN card into discard";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                symbols: ["sword", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.beamWidth = 50;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        // enemy.dx -= 60;
                        var card2 = new cardObj("NaN", 0);
                        player.draw.push(card2);
                        player.draw = shuffleArray(player.draw);
                        drawAdding.push(card2);
                    },
                    function(attack, enemy) {
                        // enemy.dx -= 60;
                        var card2 = new cardObj("NaN", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },

                ],
            },
            {
                name: "ram",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 15;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
        ],
    },
    "spiker": {
        integrityVals: [42, 56],
        height: 110,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -35 + cos(frameCount * 3 / 2) * 10);

            strokeWeight(1);
            stroke(112, 112, 112);
            pushMatrix();
            rotate(sin(frameCount * 3) * 10 + 30);
            scale(4);
            fill(181, 181, 181);
            beginShape();
            var a = 15;
            var n = 8;
            var a2 = 1;
            for(var i = 15; i < 360; i += 360 / n) {
                a2 = 1 - a2;
                vertex(a / (1 + a2 * 0.2) * cos(i), a / (1 + a2 * 0.2) * sin(i));
                vertex((a / 2) * cos(i + 360 / (n * 2)), (a / 2) * sin(i + 360 / (n * 2)));
            }
            endShape(CLOSE);
            popMatrix();
            pushMatrix();
            rotate(cos(frameCount * 3) * 20 + 30);
            scale(4);
            fill(219, 219, 219);
            noStroke();
            beginShape();
            var a = 7;
            var n = 8;
            var a2 = 1;
            for(var i = -30; i < 360; i += 360 / n) {
                a2 = 1 - a2;
                vertex(a / (1 + a2 * 0.5) * cos(i), a / (1 + a2 * 0.5) * sin(i));
                vertex((a / 3) * cos(i + 360 / (n * 2)), (a / 3) * sin(i + 360 / (n * 2)));
            }
            endShape(CLOSE);
            popMatrix();

            translate(0, -sin(frameCount * 3) * 3);
            stroke(52, 146, 158);
            strokeWeight(4);
            fill(86, 193, 222);
            rect(-46, -10, 50, 20, 5);
            stroke(47, 104, 112);
            strokeWeight(8);
            point(-12, 0);
            point(-37, 0);

            popMatrix();
        },
        startingEffects: function(enemy) {
            return {
                thorns: 3,
            };
        },
        chooseAttack: function(enemy) {
            if(enemy.effects.thorns >= 15) {
                return 0;
            }
            return manageProbabilities([
                [0, 50],
                [1, 50],
            ]);
        },
        attacks: [{
                name: "cut",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 7;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "spike",
                description: function(attack, enemy) {
                    return "Gain 2 Thorns";
                },
                num: 2,
                symbols: ["buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("thorns", 2, enemy);
                    },
                ],
            },
        ],
    },
    "exploder": {
        integrityVals: [30, 30],
        height: 95,
        draw: function(enemy) {
            pushMatrix();

            translate(sin(frameCount * 3) * 5, 0);

            strokeWeight(4);

            pushMatrix();
            translate(cos(frameCount * 3) * -3, sin(frameCount * 3) * 3);
            stroke(99, 99, 99);
            fill(112, 112, 112);
            ellipse(0, -10, 50, 50);
            popMatrix();

            stroke(51, 51, 51);
            fill(71, 71, 71);
            rect(-25, 10, 50, 16, 30);
            strokeWeight(8);
            stroke(138, 138, 138);
            point(0, 19);
            point(14, 19);
            point(-14, 19);

            strokeWeight(4);

            if(!enemy.explodeAnim) {
                pushMatrix();
                translate(-sin(frameCount * 3) * 5, 0);
                translate(cos(frameCount * 3) * -6, sin(frameCount * 3) * 2);
                stroke(232, 105, 25);
                fill(240, 140, 19);
                ellipse(0, -50, 40, 40);
                noStroke();
                fill(250, 177, 30);
                ellipse(0 + cos(frameCount * 3 / 2) * -4, -50 + sin(frameCount * 3 / 2) * 2, 20, 20);
                popMatrix();
            } else {
                enemy.explodeAnim = lerp(enemy.explodeAnim, -0.05, 0.1);
                noStroke();
                fill(240, 78, 19);
                ellipse(0, -50, 1000 * enemy.explodeAnim, 1000 * enemy.explodeAnim);
                fill(240, 140, 19);
                ellipse(0, -50, 600 * enemy.explodeAnim, 600 * enemy.explodeAnim);
                fill(240, 188, 19);
                ellipse(0, -50, 400 * enemy.explodeAnim, 400 * enemy.explodeAnim);
                fill(240, 218, 19);
                ellipse(0, -50, 200 * enemy.explodeAnim, 200 * enemy.explodeAnim);
            }

            translate(cos(frameCount * 3) * -6, sin(frameCount * 3) * 2);
            stroke(99, 99, 99);
            fill(181, 181, 181);
            arc(0, -40, 60, 40, -20, 200);
            line(0 - cos(20) * 30, -40 - sin(20) * 20, 0, -40);
            line(0 + cos(20) * 30, -40 - sin(20) * 20, 0, -40);

            translate(0, -21 - sin(frameCount * 3) * 3);
            stroke(52, 146, 158);
            strokeWeight(4);
            fill(86, 193, 222);
            rect(-46, -10, 50, 20, 5);
            stroke(47, 104, 112);
            strokeWeight(8);
            point(-12, 0);
            point(-37, 0);

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;
            if(enemy.attackCounter <= 2) {
                return 0;
            }
            return 1;
        },
        attacks: [{
                name: "ram",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Explodes after 2 attacks\n(" + (3 - enemy.attackCounter) + " remaining)";
                },
                damage: function(attack, player, enemy) {
                    return 9;
                },
                symbols: ["sword", "unknown"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "explode",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage, then deal 999 damage to self";
                },
                damage: function(attack, player, enemy) {
                    return 30;
                },
                symbols: ["sword", "unknown"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        enemy.explodeAnim = 1;
                        normalDamage(attack, player, enemy);
                        enemy.integrity -= 999;
                    },
                ],
            },
        ],
    },
    "repulsor": {
        integrityVals: [29, 35],
        height: 70,
        draw: function(enemy) {
            pushMatrix();

            translate(0, sin(frameCount * 3 / 2) * 10);

            pushMatrix();
            translate(0, -17);

            noStroke();
            fill(91, 212, 91, 150);
            if(!enemy.repulseAnim) {
                enemy.repulseAnim = 0;
            }
            enemy.repulseAnim = lerp(enemy.repulseAnim, 0, 0.1);
            var a = 80 + pow((sin(frameCount * 3 / 2) + 1) / 2, 2) * 60 - 30 + enemy.repulseAnim * 150;
            ellipse(0, 0, a, a);

            strokeWeight(4);
            stroke(181, 153, 60);
            rotate(frameCount);
            noFill();
            pushMatrix();
            ellipse(0, 0, 50 * cos(frameCount * 3), 60);
            popMatrix();
            pushMatrix();
            rotate(90);
            ellipse(0, 0, 50 * sin(frameCount * 3), 60);
            popMatrix();
            pushMatrix();
            rotate(45);
            ellipse(0, 0, 50 * sin(frameCount * 3), 60);
            popMatrix();

            popMatrix();

            strokeWeight(4);
            translate(0, -21 - sin(frameCount * 3) * 3);
            stroke(52, 146, 158);
            strokeWeight(4);
            fill(86, 193, 222);
            rect(-46, -10, 50, 20, 5);
            stroke(47, 104, 112);
            strokeWeight(8);
            point(-12, 0);
            point(-37, 0);

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(enemy.selectedAttack === 1) {
                return 0;
            }
            return manageProbabilities([
                [0, 80],
                [1, 20],
            ]);
        },
        attacks: [{
                name: "repulse",
                description: function(attack, enemy) {
                    return "Shuffle 2 Undefined cards into draw";
                },
                symbols: ["debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.repulseAnim = 1;
                        var card2 = new cardObj("undefined", 0);
                        player.draw.push(card2);
                        player.draw = shuffleArray(player.draw);
                        drawAdding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.repulseAnim = 1;
                        var card2 = new cardObj("undefined", 0);
                        player.draw.push(card2);
                        player.draw = shuffleArray(player.draw);
                        drawAdding.push(card2);
                    },
                ],
            },
            {
                name: "bash",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 11;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
        ],
    },
    "mega rat": {
        integrityVals: [300, 300],
        height: 140,
        draw: function(enemy) {
            pushMatrix();
            translate(-14, -23);

            stroke(222, 145, 217);
            strokeWeight(8);
            noFill();
            beginShape();
            vertex(134, 13);

            vertex(63, 12);
            curveVertex(134, -24 + cos(frameCount * 3) * 5);
            vertex(264 + sin(frameCount * 3) * 60, -321);
            endShape();

            // noStroke();

            fill(189, 189, 189);
            strokeWeight(4);
            pushMatrix();
            pushMatrix();
            translate(-47, -9);
            stroke(222, 145, 217);
            strokeWeight(12);
            line(56, 50, 45, 14 + sin(frameCount * 3) * 2);
            line(56, 50, 36, 50);
            translate(0, 5 + cos(frameCount * 3) * 2);
            line(-5, -15 + cos(frameCount * 3) * 4, 26, -33);
            popMatrix();

            stroke(117, 117, 117);
            strokeWeight(4);
            translate(-157, -115 + sin(frameCount * 3) * 2);
            beginShape();
            vertex(124, 128);
            bezierVertex(124, 128, 166, 171, 232, 130);
            bezierVertex(262, 24, 109, -34, 124, 128);
            endShape();
            popMatrix();

            pushMatrix();
            translate(-18, -56);
            rotate(10 + sin(frameCount * 3) * 5);
            translate(-157, -110);
            noStroke();
            fill(230, 230, 230);
            rect(103, 121, 10, 34, 5);
            rect(121, 121, 10, 39, 5);
            stroke(117, 117, 117);
            fill(163, 163, 163);
            pushMatrix();
            translate(175, 82);
            rotate(126);
            ellipse(0, 0, 20, 10);
            popMatrix();
            pushMatrix();
            translate(144, 80);
            rotate(78);
            ellipse(0, 0, 20, 10);
            popMatrix();
            beginShape();
            vertex(103, 125);
            bezierVertex(102, 128, 141, 144, 176, 118);
            bezierVertex(184, 77, 147, 60, 102, 128);
            endShape();
            stroke(222, 145, 217);
            strokeWeight(24);
            point(103, 126);
            strokeWeight(10);
            stroke(0, 0, 0);
            point(161, 105);
            strokeWeight(6);
            stroke(107, 107, 107);
            line(161, 93, 150, 103);
            popMatrix();
            stroke(222, 145, 217);
            strokeWeight(12);
            pushMatrix();
            line(56, 50, 45, 14 + sin(frameCount * 3) * 2);
            line(56, 50, 36, 50);
            translate(0, sin(frameCount * 3) * 2);
            line(-5, -15 + sin(frameCount * 3) * 4, 26, -33);
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 1;
                return 0;
            }
            enemy.attackCounter++;

            if(enemy.selectedAttack === 0 || enemy.selectedAttack === 1) {
                return manageProbabilities([
                    [2, 50],
                    [3, 50],
                ]);
            }
            if(enemy.selectedAttack === 2) {
                return manageProbabilities([
                    [1, 50],
                    [3, 50],
                ]);
            }
            return 0;

        },
        attacks: [{
                name: "roar",
                description: function(attack, enemy) {
                    return "Apply 3 Weak. Apply 3 Frail";
                },
                num: 3,
                symbols: ["debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 3, player);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("frail", 3, player);
                    },
                ],
            },
            {
                name: "drool",
                description: function(attack, enemy) {
                    return "Gain 3 Strength";
                },
                num: 3,
                symbols: ["buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 3, enemy);
                    }
                ],
            },
            {
                name: "slam",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 25;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "nom",
                description: function(attack, enemy) {
                    var t = ceil(enemy.attackCounter / 2);
                    return "Deal " + attack.damage(attack, player, enemy) + " damage, " + t + " time" + ((t >= 2) ? "s" : "");
                },
                damage: function(attack, player, enemy) {
                    return 5;
                },
                symbols: ["sword", "unknown"],
                effect: [
                    function(attack, enemy) {
                        var t = ceil(enemy.attackCounter / 2);
                        enemy.repeatNum = 1;
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                        if(enemy.repeatNum >= t) {
                            enemy.animStep++;
                        }
                    },
                    function(attack, enemy) {
                        var t = ceil(enemy.attackCounter / 2);
                        if(enemy.repeatNum < t) {
                            enemy.repeatNum++;
                            enemy.dx -= 60;
                            if(enemy.repeatNum < t) {
                                enemy.animStep--;
                            }
                            normalDamage(attack, player, enemy);
                        }
                    },
                ],
            },
        ],
    },
    "overseer": {
        integrityVals: [160, 160],
        height: 140,
        draw: function(enemy) {
            pushMatrix();
            scale(0.8);

            translate(0, -100 + sin(frameCount * 3 / 2) * 10);

            stroke(105, 105, 105);
            strokeWeight(8);
            line(-20, -20, -40, -50 + sin(frameCount * 3 / 2) * 5);
            line(-71 + cos(frameCount * 3 / 2) * 5, -20 + sin(frameCount * 3 / 2) * 10, -40, -50 + sin(frameCount * 3 / 2) * 5);

            pushMatrix();
            translate(cos(frameCount * 3 / 2) * 5, sin(frameCount * 3 / 2) * 10);
            rotate(-16);
            scale(0.7);
            translate(-99, -69);

            noStroke();
            stroke(115, 0, 23);
            strokeWeight(8);

            fill(138, 36, 11);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(171, 61, 40);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(115, 0, 23);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();

            strokeWeight(5);
            stroke(115, 0, 23);
            fill(171, 61, 40);
            ellipse(0, 0, 80, 80);

            stroke(0, 0, 0);
            var a = 160 + sin(frameCount * 3) * 20 + sin(frameCount * 3 / 4) * 20;
            fill(196, 131, 143);
            ellipse(cos(a) * 30, sin(a) * 30, 40, 40);
            noStroke();
            fill(217, 80, 119);
            ellipse(cos(a) * 30 - 8 + cos(frameCount * 3) * 3, sin(a) * 30, 10, 20);

            if(!enemy.spinAnim) {
                enemy.spinAnim = 0;
            }
            enemy.spinAnim = lerp(enemy.spinAnim, 0, 0.05);

            stroke(105, 105, 105);
            strokeWeight(8);
            line(15, -10, 36 + cos(frameCount * 3) * -6, 30 + sin(frameCount * 3 / 2) * 5);
            line(15 + cos(frameCount * 3) * -20 - enemy.spinAnim * 30, 66, 36 + cos(frameCount * 3) * -6, 30 + sin(frameCount * 3 / 2) * 5);

            translate(cos(frameCount * 3) * -20, 0);
            var n = 3;
            for(var i = 0; i < 360; i += 360 / n) {
                pushMatrix();
                translate(15 - enemy.spinAnim * 30, 66);
                rotate(i + frameCount * 3 + sin(frameCount * 3) * 40 + enemy.spinAnim * -(360 * 2));
                stroke(105, 105, 105);
                strokeWeight(10);
                line(0, 0, 33, 0);
                stroke(31, 31, 31);
                strokeWeight(6);
                fill(69, 69, 69);
                arc(30, 0, 30, 60, 90, 180);
                line(30, 0, 30, 30);
                line(15, 0, 30, 0);
                popMatrix();
            }

            popMatrix();
        },
        startingEffects: function(enemy) {
            enemy.malleableCounter = 3;
            return {
                malleable: 3,
                reactive: 1,
            };
        },
        chooseAttack: function(enemy) {
            return manageProbabilities([
                [0, 30],
                [1, 20],
                [2, 30],
                [3, 20],
            ]);
        },
        attacks: [{
                name: "flail",
                damage: function(attack, target) {
                    return 15;
                },
                defense: function(attack, target) {
                    return 16;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage. Gain " + attack.defense(attack, enemy) + " defense";
                },
                symbols: ["sword", "shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
            {
                name: "cripple",

                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage. Apply 2 Weak. Apply 2 Frail";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                num: 2,
                symbols: ["sword", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        applyEffect("weak", 2, player);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        applyEffect("frail", 2, player);
                    },
                ],
            },
            {
                name: "triple strike",
                damage: function(attack, target) {
                    return 7;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, three times";
                },
                symbols: ["sword", "sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "smash",
                damage: function(attack, target) {
                    return 32;
                },
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.spinAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
        ],
    },
    "volatile construct": {
        integrityVals: [999, 999],
        height: 265,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -200);

            var a2 = sin(frameCount * 3) * -5;
            translate(0, a2);

            pushMatrix();
            stroke(0, 0, 0);
            strokeWeight(4);
            fill(59, 59, 59);
            ellipse(0, 0, 80, 80);
            stroke(87, 34, 16);
            fill(135, 49, 20);
            ellipse(15, 22, 10, 10);
            ellipse(-26, 16, 10, 10);
            popMatrix();
            stroke(0, 0, 0);
            strokeWeight(4);
            var a = 12 + a2 / 2;
            line(cos(a) * 40, sin(a) * 40 + a2, 50, 30 + a2 / 2);
            line(cos(180 - a) * 40, sin(180 - a) * 40 + a2, -50, 30 + a2 / 2);
            line(50, 30 + a2 / 2, 40, 40);
            line(-50, 30 + a2 / 2, -40, 40);

            // head/torso connection
            pushMatrix();
            translate(0, sin(frameCount * 3) * -2);
            stroke(158, 158, 158);
            strokeWeight(8);
            line(30, 55, 50, 80);
            line(20, 125, 50, 80);
            line(-30, 55, -50, 80);
            line(-20, 125, -50, 80);
            popMatrix();

            //legs

            pushMatrix();
            translate(0, 100 + sin(frameCount * 3) * -2);
            stroke(158, 158, 158);
            strokeWeight(8);
            line(30, 55, 40, 90 + sin(frameCount * 3) * 3);
            line(20, 125 + sin(frameCount * 3) * 7, 40, 90 + sin(frameCount * 3) * 3);
            line(-30, 55, -40, 90 + sin(frameCount * 3) * 3);
            line(-20, 125 + sin(frameCount * 3) * 7, -40, 90 + sin(frameCount * 3) * 3);
            fill(54, 54, 54);
            stroke(38, 38, 38);
            strokeWeight(6);
            pushMatrix();
            translate(-16, 128 + sin(frameCount * 3) * 7);
            arc(0, 0, 70, 40, 180, 256);
            line(0, 0, -35, 0);
            line(0, 0, 0 - sin(20) * 20, -cos(20) * 20);
            popMatrix();
            pushMatrix();
            translate(16, 128 + sin(frameCount * 3) * 7);
            arc(0, 0, 70, 40, -76, 0);
            line(0, 0, 35, 0);
            line(0, 0, 0 + sin(20) * 20, -cos(20) * 20);
            popMatrix();
            popMatrix();

            // arms

            enemy.swingAnim = lerp(enemy.swingAnim, 0, 0.05) || 0;

            var a3 = (360 * 4) * enemy.swingAnim;
            var a4 = 10 + enemy.swingAnim * 35;

            var a = 80;
            pushMatrix();
            translate(30, 130);
            rotate(-45 + sin(frameCount * 3 + a3) * a4);
            stroke(158, 158, 158);
            strokeWeight(8);
            line(0, 0, a + 3, 0);
            fill(54, 54, 54);
            stroke(38, 38, 38);
            strokeWeight(6);
            arc(a, 0, 40, 100, 90, 180);
            line(a, 0, a - 20, 0);
            line(a, 0, a, 50);
            popMatrix();
            pushMatrix();
            translate(30, 145);
            rotate(14 + cos(frameCount * 3 + a3) * a4);
            stroke(158, 158, 158);
            strokeWeight(8);
            line(0, 0, a + 3, 0);
            fill(54, 54, 54);
            stroke(38, 38, 38);
            strokeWeight(6);
            arc(a, 0, 40, 100, 90, 180);
            line(a, 0, a - 20, 0);
            line(a, 0, a, 50);
            popMatrix();
            pushMatrix();
            scale(-1, 1);
            translate(30, 130);
            rotate(-45 + sin(frameCount * 3 + a3) * -a4);
            stroke(158, 158, 158);
            strokeWeight(8);
            line(0, 0, a + 3, 0);
            fill(54, 54, 54);
            stroke(38, 38, 38);
            strokeWeight(6);
            arc(a, 0, 40, 100, 90, 180);
            line(a, 0, a - 20, 0);
            line(a, 0, a, 50);
            popMatrix();
            pushMatrix();
            scale(-1, 1);
            translate(30, 145);
            rotate(14 + cos(frameCount * 3 + a3) * -a4);
            stroke(158, 158, 158);
            strokeWeight(8);
            line(0, 0, a + 3, 0);
            fill(54, 54, 54);
            stroke(38, 38, 38);
            strokeWeight(6);
            arc(a, 0, 40, 100, 90, 180);
            line(a, 0, a - 20, 0);
            line(a, 0, a, 50);
            popMatrix();

            // head
            stroke(0, 0, 0);
            strokeWeight(4);
            fill(99, 62, 52);
            pushMatrix();
            translate(0, 36);
            arc(0, 0, 120, 70, -9, 190);
            line(0, 0, -cos(10) * 60, -sin(10) * 35);
            line(0, 0, cos(10) * 60, -sin(10) * 35);
            popMatrix();

            // torso

            pushMatrix();
            translate(0, sin(frameCount * 3) * 2);
            translate(0, 130);
            ellipse(0, 0, 90, 90);

            // enemy.explodeAnim = 1;
            // enemy.explodeAnim = 0;

            if(!enemy.explodeAnim) {
                pushMatrix();
                translate(0, 0);
                strokeWeight(4);
                stroke(232, 105, 25);
                fill(240, 140, 19);
                ellipse(0, 0, 40, 40);
                noStroke();
                fill(250, 177, 30);
                ellipse(0 + cos(frameCount * 3 / 2) * -4, sin(frameCount * 3 / 2) * 2, 20, 20);
                popMatrix();
            } else {
                enemy.explodeAnim = lerp(enemy.explodeAnim, -0.05, 0.1);
                noStroke();
                fill(240, 78, 19);
                ellipse(0, 0, 1000 * enemy.explodeAnim, 1000 * enemy.explodeAnim);
                fill(240, 140, 19);
                ellipse(0, 0, 600 * enemy.explodeAnim, 600 * enemy.explodeAnim);
                fill(240, 188, 19);
                ellipse(0, 0, 400 * enemy.explodeAnim, 400 * enemy.explodeAnim);
                fill(240, 218, 19);
                ellipse(0, 0, 200 * enemy.explodeAnim, 200 * enemy.explodeAnim);
            }

            popMatrix();

            popMatrix();
        },
        startingEffects: function(enemy) {
            enemy.fragileCounter = 0;
            enemy.attackCounter = 0;
            return {
                fragile: 1,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;

            enemy.fragileCounter = 0;
            return 0;
        },
        attacks: [{
            name: "wild attack",
            description: function(attack, enemy) {
                return "Deal " + attack.damage(attack, player, enemy) + " damage. Dies after 5 attacks\n(" + (6 - enemy.attackCounter) + " remaining)";
            },
            damage: function(attack, player, enemy) {
                return constrain(30 + 10 * (enemy.attackCounter - 1) - enemy.fragileCounter, 0, 999);
            },
            symbols: ["sword", "unknown"],
            effect: [
                function(attack, enemy) {
                    enemy.dx -= 60;
                    enemy.swingAnim = 1;
                    normalDamage(attack, player, enemy);
                    if(enemy.attackCounter >= 5) {
                        enemy.integrity = -999;
                        enemy.explodeAnim = 1;
                    }
                },
            ],
        }, ],
    },

    // bosses
    "mega slime": {
        integrityVals: [140, 140],
        height: 190,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -69 + cos(frameCount * 3) * 5);

            pushMatrix();
            scale(0.8);
            pushMatrix();
            translate(-50 + cos(frameCount * 3 / 8) * 80, -20 + sin(frameCount * 3 / 4) * 30);
            translate(40, 40);
            rotate(frameCount * 0.6);
            translate(-40, -40);
            stroke(0, 0, 0);
            strokeWeight(5);
            fill(181, 27, 189);
            rect(0, 0, 80, 80, 50);

            stroke(80, 194, 175);
            strokeWeight(5);
            line(13, 18, 42, 18);
            line(9, 25, 24, 25);
            popMatrix();

            translate(-60 + cos(frameCount * 3 / 8 + 180) * 60, -30 + sin(frameCount * 3 / 4 + 180) * 30);
            translate(40, 40);
            rotate(-frameCount * 0.4);
            translate(-40, -40);
            fill(224, 146, 45);
            var w = 73;
            var w2 = 59;
            var h = -3;
            var h2 = 13;
            var w3 = 8;
            var w4 = 7;
            var h3 = -7;
            // visor
            stroke(0, 0, 0);
            strokeWeight(4);
            pushMatrix();
            translate(0, sin(frameCount * 3) * 2 + 4);
            beginShape();
            vertex(0, h3);
            vertex(w3, 20 + h3);

            vertex(w3 + w2, 20 - h);

            vertex(w + w4, 20 - h2);
            vertex(w, 0 - h2);

            // vertex(20+w2,0-h);
            vertex(0 + w2, 0 - h);
            endShape(CLOSE);
            stroke(219, 219, 219);
            strokeWeight(5);
            line(67, 5, 71, 0);

            popMatrix();
            popMatrix();

            scale(3);
            pushMatrix();
            var num = cos(frameCount * 3) * 0.04;

            rotate(sin(frameCount * 6) * 2);
            var a = 10;
            translate(0, a);
            scale(1 + num, 0.8 - num);
            translate(0, -a);

            stroke(184, 32, 201);
            strokeWeight(6);
            fill(219, 100, 227, 200);
            ellipse(0, 0, 80, 80);

            popMatrix();
            popMatrix();
        },
        startingEffects: function() {
            return {
                split: 1,
            };
        },
        chooseAttack: function(enemy) {
            if(!enemy.firstAttack) {
                enemy.firstAttack = true;
                return 0;
            }
            return (enemy.selectedAttack + 1) % 3;
        },
        attacks: [{
                name: "goop spray",
                description: function(attack, enemy) {
                    return "Shuffle 3 Slimed cards into discard";
                },
                symbols: ["debuff", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("slime", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },
            {
                name: "preparing...",
                description: function(attack) {
                    return "Prepare a big attack";
                },
                symbols: ["unknown"],
                effect: [],
            },
            {
                name: "slam",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 35;
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    }
                ],
            },
            {
                name: "split",
                description: function(attack, enemy) {
                    return "Split into two smaller slimes";
                },
                symbols: ["unknown"],
                effect: [
                    function(attack, enemy) {
                        var enemy2 = new enemyObj("giant acid slime");
                        enemy2.maxIntegrity = enemy.integrity;
                        enemy2.integrity = enemy2.maxIntegrity;
                        enemies.push(enemy2);
                    },
                    function(attack, enemy) {
                        var enemy2 = new enemyObj("giant plasma slime");
                        enemy2.maxIntegrity = enemy.integrity;
                        enemy2.integrity = enemy2.maxIntegrity;
                        enemies.push(enemy2);
                        enemy.integrity = 0;
                    }
                ],
            },
        ],
    },
    "hexaghost": {
        integrityVals: [250, 250],
        height: 220,
        draw: function(enemy) {
            pushMatrix();
            translate(0, -30 + sin(frameCount * 3 / 2) * 10);

            var a = sin(frameCount * 3) * 25 + 25;
            noStroke();
            fill(156, 64, 151);
            ellipse(0, -50, 200 + a, 200 + a);
            fill(189, 66, 183);
            ellipse(0, -50, 150 + a, 150 + a);
            fill(201, 110, 195);
            ellipse(0, -50, 100 + a, 100 + a);

            strokeWeight(4);
            stroke(110, 83, 24);
            fill(204, 168, 96);
            pushMatrix();
            translate(0, -50);
            rotate(frameCount + sin(frameCount * 3) * 30);
            var a = 40;
            beginShape();
            for(var i = 0; i < 360; i += 360 / 6) {
                vertex(cos(i) * a, sin(i) * a);
            }
            endShape(CLOSE);

            rotate(frameCount + sin(frameCount * 3) * 10);
            var n = (enemy.attackCounter - 3) || 0;
            for(var i = 0; i < 60 * n; i += 360 / 6) {
                pushMatrix();
                translate(cos(i) * (a + 30), sin(i) * (a + 30));
                rotate(-frameCount * 2);
                fill(40, 219, 84);
                stroke(22, 148, 35);
                rect(-10, -10, 20, 20, 5);
                popMatrix();
            }

            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;
            if(enemy.attackCounter === 1) {
                return 0;
            }
            if(enemy.attackCounter === 2) {
                return 1;
            }
            if(enemy.attackCounter >= 10) {
                enemy.attackCounter = 3;
            }
            var attackMap = [
                3,
                4,
                3,
                5,
                4,
                3,
                2,
            ];
            return attackMap[enemy.attackCounter - 3];
        },
        attacks: [{
                name: "activate",
                description: function(attack, enemy) {
                    return "...";
                },
                symbols: ["unknown"],
                effect: [],
            },
            {
                name: "divider",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage\n(Half of the target's health)";
                },
                damage: function(attack, player, enemy) {
                    return ceil(player.integrity / 2);
                },
                symbols: ["sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "inferno",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage, six times. Shuffle 3 NaN cards into discard";
                },
                damage: function(attack, player, enemy) {
                    return 2;
                },
                symbols: ["sword", "sword", "sword", "sword", "sword", "sword", "debuff", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("NaN", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("NaN", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("NaN", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },
            {
                name: "sear",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage. Shuffle a NaN card into discard";
                },
                damage: function(attack, player, enemy) {
                    return 6;
                },
                symbols: ["sword", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("NaN", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },
            {
                name: "tackle",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player, enemy) + " damage, twice";
                },
                damage: function(attack, player, enemy) {
                    return 5;
                },
                symbols: ["sword", "sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "inflame",
                description: function(attack, enemy) {
                    return "Gain 2 Strength. Gain " + attack.defense(attack, enemy) + " defense";
                },
                defense: function(attack, target) {
                    return 12;
                },
                num: 2,
                symbols: ["buff", "shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 2, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
        ],
    },
    "scrapling supreme": {
        integrityVals: [420, 420],
        height: 260,
        draw: function(enemy) {
            pushMatrix();
            translate(0, 7);

            stroke(0, 0, 0);
            strokeWeight(4);

            // feet
            fill(79, 79, 79);
            pushMatrix();
            translate(16, 0);
            rotate(7);
            rect(0, 0, 32, 20, 5);
            popMatrix();
            pushMatrix();
            translate(-48, 6);
            rotate(-7);
            rect(0, 0, 32, 20, 5);
            popMatrix();

            // enemy.smashAnim = 1;

            // left hand
            pushMatrix();
            translate(-81 + enemy.smashAnim * 40, -100 + sin(frameCount * 3) * 2 + enemy.smashAnim * 50);
            if(!enemy.smashAnim) {
                enemy.smashAnim = 0;
            }
            enemy.smashAnim = lerp(enemy.smashAnim, 0, 0.1);
            rotate(60 - enemy.smashAnim * 150);

            stroke(112, 103, 90);
            strokeWeight(12);
            line(0, 33, 0, -205);
            fill(54, 54, 54);

            stroke(0, 0, 0);
            strokeWeight(4);
            rect(-60, -200, 120, 60, 5);

            fill(79, 79, 79);
            ellipse(0, 0, 30, 30);
            popMatrix();

            // torso
            pushMatrix();
            translate(0, sin(frameCount * 3) * 4 - 3);
            translate(-40, -120);
            fill(135, 135, 135);
            rect(0, 0, 80, 100, 10);
            fill(99, 99, 99);
            rect(-10, -10, 100, 40, 10);
            fill(166, 27, 27);
            pushMatrix();
            translate(-3, 22);
            rotate(-20);
            rect(-20, -20, 40, 40, 10);
            popMatrix();
            pushMatrix();
            translate(83, 22);
            rotate(20);
            rect(-20, -20, 40, 40, 10);
            popMatrix();
            pushMatrix();
            translate(40, 65);
            stroke(232, 105, 25);
            fill(240, 140, 19);
            ellipse(0, 0, 40, 40);
            noStroke();
            fill(250, 177, 30);
            ellipse(0 + cos(frameCount * 3 / 2) * -4, sin(frameCount * 3 / 2) * 2, 20, 20);
            popMatrix();
            stroke(0, 0, 0);
            popMatrix();

            // head
            pushMatrix();
            translate(0, cos(frameCount * 3) * -4);
            translate(-65, -210);
            fill(176, 176, 176);
            rect(0, 0, 100, 100, 40);

            // eyes
            pushMatrix();
            translate(0, cos(frameCount * 3) * -2);
            fill(200, 255, 0);
            stroke(142, 161, 35);
            ellipse(73, 50, 30, 30);
            ellipse(4, 40, 30, 30);
            popMatrix();

            // mouth
            pushMatrix();
            translate(0, sin(frameCount * 3));
            translate(29, 71);
            rotate(10 + sin(frameCount * 3 / 2) * 5);
            fill(222, 222, 222);
            stroke(166, 166, 166);
            arc(0, 0, 60, 50 + sin(frameCount * 3) * 10, 0, 180);
            line(-30, 0, 30, 0);
            popMatrix();

            popMatrix();
            stroke(0, 0, 0);

            // right hand
            pushMatrix();
            translate(67, -84 + sin(frameCount * 3) * 2);
            rotate(-7 - sin(frameCount * 3) * 5);
            pushMatrix();
            scale(1);

            noStroke();
            stroke(87, 87, 87);
            strokeWeight(4);

            fill(128, 126, 116);
            var a = 35;
            var a2 = 65;
            var a3 = 190;
            arc(-a, 0, 100 + a * 2, a3, 0, a2);
            arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

            fill(181, 170, 150);
            noStroke();
            triangle(5, 0, -5, 0, 0, 85);

            beginShape();
            vertex(0, -25);
            vertex(50, 0);
            vertex(0, 25);
            vertex(-50, 0);
            endShape(CLOSE);

            stroke(89, 89, 89);
            line(50, 0, 0, -25);
            line(-50, 0, 0, -25);
            popMatrix();

            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.phase) {
                enemy.phase = 1;
            }
            if(enemy.phase === 1 && enemy.integrity < enemy.maxIntegrity / 2) {
                enemy.phase = 2;
                enemy.attackCounter = 0;
                return 6;
            }
            if(!enemy.attackCounter) {
                enemy.attackCounter = 0;
            }
            enemy.attackCounter++;

            if(enemy.phase === 1) {
                if(enemy.attackCounter === 4) {
                    enemy.attackCounter = 0;
                    return 2;
                }
            } else {
                if(enemy.selectedAttack === 6) {
                    enemy.attackCounter = 0;
                    return 5;
                }
                if(enemy.attackCounter === 3) {
                    enemy.attackCounter = 0;
                    return 5;
                }
            }
            var num = 99;
            while(num === 99 || num === enemy.selectedAttack) {
                num = manageProbabilities([
                    [0, 15],
                    [4, 15],
                    [1, 25],
                    [3, 45],
                ]);
            }
            return num;
        },
        attacks: [{
                name: "fortify",
                description: function(attack, enemy) {
                    return "Gain 5 Hardened. Gain " + attack.defense(attack, enemy) + " defense";
                },
                defense: function(attack, target) {
                    return 10;
                },
                num: 5,
                symbols: ["buff", "shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("hardened", 5, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        normalDefend(attack, enemy);
                    }
                ],
            },
            {
                name: "smack",

                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage. Apply 2 Vulnerable. Apply 2 Frail";
                },
                damage: function(attack, player, enemy) {
                    return 12;
                },
                num: 2,
                symbols: ["sword", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        applyEffect("vulnerable", 2, player);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        applyEffect("frail", 2, player);
                    },
                ],
            },
            {
                name: "taunt",

                description: function(attack, enemy) {
                    return "Apply 2 Vulnerable. Apply 2 Weak";
                },
                num: 2,
                symbols: ["debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("vulnerable", 2, player);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        applyEffect("weak", 2, player);
                    },
                ],
            },
            {
                name: "heavy smash",

                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage";
                },
                damage: function(attack, player, enemy) {
                    return 16;
                },
                symbols: ["sword", ],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "gloat",
                description: function(attack, enemy) {
                    return "Gain 2 Strength";
                },
                num: 2,
                symbols: ["buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 2, enemy);
                    },
                ],
            },
            {
                name: "execute",

                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, twice";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                symbols: ["sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        enemy.smashAnim = 1;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "anger",
                description: function(attack, enemy) {
                    return "Remove all effects except for Strength and Hardened. Gain 6 Strength";
                },
                num: 6,
                symbols: ["unknown"],
                effect: [
                    function(attack, enemy) {
                        var amtHardened = enemy.effects.hardened;
                        var amtStrength = enemy.effects.strength;
                        enemy.effects = {};
                        enemy.effects.strength = amtStrength;
                        enemy.effects.hardened = amtHardened;
                    },
                    function(attack, enemy) {
                        enemy.dy += 20;
                        applyEffect("strength", 6, enemy);
                    },
                ],
            },
        ],
    },
    "ACKVNHY": {
        integrityVals: [250, 250],
        height: 120,
        draw: function(enemy) {
            pushMatrix();
            scale(-1, 1);
            scale(0.8);
            translate(-8, -80);

            stroke(0, 0, 0);
            strokeWeight(5);

            // feet
            pushMatrix();
            translate(-24, 106);
            rotate(-7);
            fill(89, 89, 89);
            rect(0, 0, 22, 12, 2);
            popMatrix();
            pushMatrix();
            translate(19, 100);
            rotate(7);
            fill(89, 89, 89);
            rect(0, 0, 22, 12, 2);
            popMatrix();

            // upper body
            pushMatrix();

            translate(0, cos(frameCount * 3) * 5 + 3);

            // torso
            pushMatrix();
            translate(-15, 40);
            fill(138, 211, 219);
            rect(0, 0, 42, 45, 15);
            pushStyle();
            noFill();
            fill(222, 112, 22);
            stroke(222, 112, 22);
            strokeWeight(4);
            triangle(23, 29, 18, 18, 28, 18);
            popStyle();
            popMatrix();

            // hands
            pushMatrix();
            translate(0, cos(frameCount * 3) * 4);

            fill(89, 89, 89);
            ellipse(-36, 74, 20, 20);
            fill(89, 89, 89);
            ellipse(51, 65, 20, 20);
            popMatrix();

            // shoulders
            pushMatrix();
            translate(0, cos(frameCount * 3) * 2);
            pushMatrix();
            translate(-37, 36);
            // rotate(-12);
            rotate(cos(frameCount * 3) * 6 - 18);
            fill(89, 89, 89);
            rect(0, 0, 20, 20, 2);
            popMatrix();
            pushMatrix();
            translate(34, 34);
            rotate(17);
            rotate(cos(frameCount * 3) * 3);
            fill(89, 89, 89);
            rect(0, 0, 20, 20, 2);
            popMatrix();
            popMatrix();

            // neck
            pushMatrix();
            translate(0, cos(frameCount * 3) * 2);
            translate(-22, 25);
            rotate(15);
            fill(166, 166, 166);
            rect(0, 0, 69, 20, 2);
            popMatrix();

            // head & face
            pushMatrix();
            translate(0, cos(frameCount * 3) * 5);
            // head
            pushMatrix();
            translate(-10, -38);
            rotate(9);

            // main part of head
            fill(112, 202, 212);
            rect(0, 0, 80, 80, 50);
            pushStyle();
            stroke(222, 112, 22);
            strokeWeight(5);
            line(13, 18, 42, 18);
            line(9, 25, 24, 25);
            popStyle();
            popMatrix();

            // scale(-1,1);

            var w = 73;
            var w2 = 59;
            var h = -3;
            var h2 = 13;
            var w3 = 8;
            var w4 = 7;
            var h3 = -7;

            fill(240, 196, 242);
            var x = 57 + cos(frameCount * 3) * 3 + 3;
            var y = 41;
            // mouth
            pushMatrix();
            scale(1, -1);
            translate(10, cos(frameCount * 6) * 1.2 - 82);
            beginShape();
            vertex(x, y);
            bezierVertex(48 + cos(frameCount * 3) * 5 + 10, 60, -11 + cos(frameCount * 3) * 2 + 5, 61, 1, 38);
            bezierVertex(19, 51, x, y, x, y);
            endShape();
            popMatrix();

            fill(136, 209, 102);
            // visor
            pushMatrix();
            translate(0, cos(frameCount * 3) * 2 + 4);
            beginShape();
            vertex(0, h3);
            vertex(w3, 20 + h3);

            vertex(w3 + w2, 20 - h);

            vertex(w + w4, 20 - h2);
            vertex(w, 0 - h2);

            // vertex(20+w2,0-h);
            vertex(0 + w2, 0 - h);
            endShape(CLOSE);
            stroke(219, 219, 219);
            strokeWeight(5);
            line(67, 5, 71, 0);

            popMatrix();

            popMatrix();
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.selectedAttack) {
                return 1;
            }
            return 0;
        },
        attacks: [{
                name: "beam",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, twice";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                symbols: ["sword", "sword"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                ],
            },
            {
                name: "develop",
                description: function(attack, enemy) {
                    return "All enemies gain 3 strength";
                },
                num: 3,
                symbols: ["buff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        for(var i = 0; i < enemies.length; i++) {
                            applyEffect("strength", 3, enemies[i]);
                        }
                    },
                ],
            },
        ],
    },
    "ACKVNHLO": {
        integrityVals: [250, 250],
        height: 120,
        draw: function(enemy) {
            pushMatrix();
            scale(-1, 1);
            scale(0.8);
            translate(-8, -80);

            stroke(0, 0, 0);
            strokeWeight(5);

            // feet
            pushMatrix();
            translate(-24, 106);
            rotate(-7);
            fill(89, 89, 89);
            rect(0, 0, 22, 12, 2);
            popMatrix();
            pushMatrix();
            translate(19, 100);
            rotate(7);
            fill(89, 89, 89);
            rect(0, 0, 22, 12, 2);
            popMatrix();

            // upper body
            pushMatrix();

            translate(0, cos(frameCount * 3) * 5 + 3);

            // torso
            pushMatrix();
            translate(-15, 40);
            fill(161, 212, 134);
            rect(0, 0, 42, 45, 15);
            pushStyle();
            noFill();
            fill(222, 36, 16);
            stroke(222, 36, 16);
            strokeWeight(4);
            triangle(23, 29, 18, 18, 28, 18);
            popStyle();
            popMatrix();

            // hands
            pushMatrix();
            translate(0, cos(frameCount * 3) * 4);

            fill(89, 89, 89);
            ellipse(-36, 74, 20, 20);
            fill(89, 89, 89);
            ellipse(51, 65, 20, 20);
            popMatrix();

            // shoulders
            pushMatrix();
            translate(0, cos(frameCount * 3) * 2);
            pushMatrix();
            translate(-37, 36);
            // rotate(-12);
            rotate(cos(frameCount * 3) * 6 - 18);
            fill(89, 89, 89);
            rect(0, 0, 20, 20, 2);
            popMatrix();
            pushMatrix();
            translate(34, 34);
            rotate(17);
            rotate(cos(frameCount * 3) * 3);
            fill(89, 89, 89);
            rect(0, 0, 20, 20, 2);
            popMatrix();
            popMatrix();

            // neck
            pushMatrix();
            translate(0, cos(frameCount * 3) * 2);
            translate(-22, 25);
            rotate(15);
            fill(166, 166, 166);
            rect(0, 0, 69, 20, 2);
            popMatrix();

            // head & face
            pushMatrix();
            translate(0, cos(frameCount * 3) * 5);
            // head
            pushMatrix();
            translate(-10, -38);
            rotate(9);

            // main part of head
            fill(136, 209, 102);
            rect(0, 0, 80, 80, 50);
            pushStyle();
            stroke(222, 36, 16);
            strokeWeight(5);
            line(13, 18, 42, 18);
            line(9, 25, 24, 25);
            popStyle();
            popMatrix();

            // scale(-1,1);

            var w = 73;
            var w2 = 59;
            var h = -3;
            var h2 = 13;
            var w3 = 8;
            var w4 = 7;
            var h3 = -7;

            fill(240, 196, 242);
            var x = 57 + cos(frameCount * 3) * 3 + 3;
            var y = 41;
            // mouth
            pushMatrix();
            scale(1, -1);
            translate(10, cos(frameCount * 6) * 1.2 - 82);
            beginShape();
            vertex(x, y);
            bezierVertex(48 + cos(frameCount * 3) * 5 + 10, 60, -11 + cos(frameCount * 3) * 2 + 5, 61, 1, 38);
            bezierVertex(19, 51, x, y, x, y);
            endShape();
            popMatrix();

            fill(112, 202, 212);
            // visor
            pushMatrix();
            translate(0, cos(frameCount * 3) * 2 + 4);
            beginShape();
            vertex(0, h3);
            vertex(w3, 20 + h3);

            vertex(w3 + w2, 20 - h);

            vertex(w + w4, 20 - h2);
            vertex(w, 0 - h2);

            // vertex(20+w2,0-h);
            vertex(0 + w2, 0 - h);
            endShape(CLOSE);
            stroke(219, 219, 219);
            strokeWeight(5);
            line(67, 5, 71, 0);

            popMatrix();

            popMatrix();
            popMatrix();

            popMatrix();
        },
        chooseAttack: function(enemy) {
            if(!enemy.selectedAttack) {
                return 1;
            }
            return 0;
        },
        attacks: [{
                name: "protect",
                description: function(attack, enemy) {
                    return "All enemies gain " + attack.defense(attack, enemy) + " defense";
                },
                defense: function(attack, target) {
                    return 16;
                },
                symbols: ["shield"],
                effect: [
                    function(attack, enemy) {
                        enemy.dy += 20;
                        for(var i = 0; i < enemies.length; i++) {
                            normalDefend(attack, enemies[i]);
                        }
                    },
                ],
            },
            {
                name: "beam",
                description: function(attack, enemy) {
                    return "Deal " + attack.damage(attack, player) + " damage, twice. Shuffle 2 Undefined cards into discard";
                },
                damage: function(attack, player, enemy) {
                    return 10;
                },
                symbols: ["sword", "sword", "debuff", "debuff"],
                effect: [
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        normalDamage(attack, player, enemy);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("undefined", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                    function(attack, enemy) {
                        enemy.dx -= 60;
                        var card2 = new cardObj("undefined", 0);
                        player.discard.push(card2);
                        discarding.push(card2);
                    },
                ],
            },

        ],
    },
};


// log all the enemies in the allEnemies array
for(var i in enemyData) {
    allEnemies.push(i);
}

/**
 * The constructor for enemies
 * @constructor
 * @param {String} type - what enemy it is
*/
function enemyObj(type) {
    this.x = 1000;
    this.y = 200;
    this.dx = this.x;
    this.dy = this.y;

    this.type = type || "scrapling";
    this.data = enemyData[this.type];
    this.maxIntegrity = floor(random(this.data.integrityVals[0], this.data.integrityVals[1] + 1));
    this.integrity = this.maxIntegrity;
    this.dIntegrity = this.integrity;
    this.defense = 0;
    this.dDefense = 0;
    this.selectedAttack = 0;
    this.effects = {};
    if(this.data.startingEffects) {
        var effects = this.data.startingEffects(this);
        for(var i in effects) {
            this.effects[i] = effects[i];
        }
    }
}

// queue the enemy attack
enemyObj.prototype.attack = function() {
    this.animStep = -1;

    attacks.push(this);
};

/**
 * Draw the symbol for an effect
 * @param {Object} target - what is affected
 * @param {[String, number]} data - the name and amount of the effect
*/
function drawEffect(target, data) {
    if(allTypes.indexOf(data[0]) >= 0) {
        noStroke();
        fire(color(209, 12, 202), color(227, 75, 222), color(235, 155, 232));
        pushMatrix();
        scale(0.07);
        translate(0, 20);
        strokeWeight(10);
        stroke(107, 107, 107);
        fill(240, 125, 240);
        rect(-50, -70, 100, 80, 5);

        fill(173, 219, 189);
        rect(-50, -15, 100, 85, 5);
        beginShape();
        vertex(-50, 0);
        vertex(-50, -35);
        vertex(-30, -15);
        vertex(30, -15);
        vertex(50, -35);
        vertex(50, 0);
        endShape();
        noStroke();

        fill(221, 48, 227);
        beginShape();
        vertex(-30, -33);
        vertex(-20, -23);
        vertex(20, -23);
        vertex(30, -33);
        endShape(CLOSE);

        beginShape();
        vertex(-30, -33);
        vertex(-20, -23);
        vertex(20, -23);
        vertex(30, -33);
        endShape(CLOSE);
        popMatrix();
        fill(0, 0, 0);
        textAlign(LEFT, BASELINE);
        textSize(12);
        text(data[1], 5, 15);

    } else if(allSpecialEffects.indexOf(data[0]) >= 0) {
        if(specialEffectData[data[0]].draw) {
            specialEffectData[data[0]].draw(data[1], target);
        }
    } else {
        switch(data[0]) {
            case "vulnerable":
                noStroke();
                pushMatrix();
                scale(0.05);
                translate(-323, -265);
                fill(212, 78, 78);
                beginShape();
                vertex(413, 198);
                vertex(366, 260);
                vertex(442, 331);
                vertex(362, 360);
                vertex(413, 408);
                vertex(387, 494);
                vertex(252, 398);
                vertex(190, 333);
                vertex(163, 277);
                vertex(160, 218);
                vertex(173, 173);
                vertex(200, 137);
                vertex(230, 115);
                vertex(258, 106);
                vertex(284, 103);
                vertex(319, 110);
                vertex(349, 124);
                endShape(CLOSE);
                fill(181, 47, 47);
                beginShape();
                vertex(204, 305);
                vertex(213, 330);
                vertex(246, 372);
                vertex(313, 429);
                vertex(347, 451);
                vertex(357, 448);
                vertex(358, 444);
                vertex(353, 437);
                vertex(297, 398);
                vertex(256, 361);
                vertex(219, 320);
                vertex(206, 303);
                endShape(CLOSE);
                fill(237, 104, 104);
                beginShape();
                vertex(196, 174);
                vertex(204, 156);
                vertex(223, 138);
                vertex(242, 129);
                vertex(269, 123);
                vertex(300, 124);
                vertex(321, 133);
                vertex(330, 140);
                vertex(331, 146);
                vertex(328, 150);
                vertex(302, 142);
                vertex(277, 136);
                vertex(261, 139);
                vertex(246, 153);
                vertex(236, 181);
                vertex(233, 216);
                vertex(232, 238);
                vertex(224, 251);
                vertex(210, 256);
                vertex(195, 253);
                vertex(190, 243);
                vertex(189, 217);
                endShape(CLOSE);
                popMatrix();
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(12);
                text(data[1], 5, 15);
                break;
            case "weak":
                noStroke();
                pushMatrix();
                scale(0.2);
                translate(35, -40);
                rotate(30);
                noStroke();

                fill(170, 194, 64);
                beginShape();
                vertex(-4, 114);
                vertex(-7, 90);
                vertex(-12, 80);
                vertex(-20, -10);
                vertex(-7, 9);
                vertex(5, -1);
                vertex(11, 14);
                vertex(20, 8);
                vertex(12, 80);
                vertex(7, 90);
                vertex(4, 114);
                endShape(CLOSE);
                fill(97, 110, 40);
                beginShape();
                vertex(-25, 90);
                vertex(-35, 80);
                vertex(-30, 70);
                vertex(-20, 80);
                vertex(-12, 80);
                vertex(12, 80);
                vertex(20, 80);
                vertex(30, 70);
                vertex(35, 80);
                vertex(25, 90);
                endShape(CLOSE);
                fill(209, 230, 113);
                beginShape();
                vertex(-12, 111);
                vertex(-8, 105);
                vertex(8, 105);
                vertex(12, 111);
                vertex(0, 124);
                endShape(CLOSE);
                noStroke();
                fill(106, 181, 60);
                beginShape();
                vertex(-1, 80);
                vertex(7, 31);
                vertex(16, 24);
                vertex(7, 63);
                endShape(CLOSE);
                popMatrix();
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(12);
                text(data[1], 5, 15);
                break;
            case "frail":
                noStroke();
                pushMatrix();
                scale(0.18);
                translate(0, -28);

                noStroke();
                fill(113, 148, 25);
                var a = 35;
                var a2 = 65;
                var a3 = 190;
                arc(-a + 4, 14, 80 + a * 2, 160, 0, a2);
                arc(a, 0, 100 + a * 2, a3, 180 - a2, 180);

                fill(157, 199, 50);
                noStroke();
                beginShape();
                vertex(-5, 0);
                vertex(5, 0);
                vertex(10, 37);
                vertex(-6, 61);
                vertex(0, 87);
                vertex(-13, 57);
                vertex(-4, 33);
                endShape(CLOSE);
                fill(173, 191, 128);
                beginShape();
                vertex(0, -25);
                vertex(9, -10);
                vertex(35, -3);
                vertex(44, 15);
                vertex(0, 25);
                vertex(-50, 0);
                endShape(CLOSE);
                // fill(148, 115, 25);
                // triangle(-13,-10,-34,0,16,-3);
                popMatrix();
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(12);
                text(data[1], 5, 15);
                break;
            case "strength":
                noStroke();
                pushMatrix();
                translate(0, 3);
                fire(-3064515, -161970, -143784);
                popMatrix();
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(12);
                text(data[1], 5, 15);
                break;
            case "no draw":
                pushMatrix();
                scale(0.12);
                translate(0, 20);
                strokeWeight(10);
                stroke(107, 107, 107);
                fill(240, 125, 240);
                rect(-50, -70, 100, 80, 5);

                fill(173, 219, 189);
                rect(-50, -15, 100, 85, 5);
                beginShape();
                vertex(-50, 0);
                vertex(-50, -35);
                vertex(-30, -15);
                vertex(30, -15);
                vertex(50, -35);
                vertex(50, 0);
                endShape();
                noStroke();

                fill(221, 48, 227);
                beginShape();
                vertex(-30, -33);
                vertex(-20, -23);
                vertex(20, -23);
                vertex(30, -33);
                endShape(CLOSE);

                beginShape();
                vertex(-30, -33);
                vertex(-20, -23);
                vertex(20, -23);
                vertex(30, -33);
                endShape(CLOSE);
                popMatrix();
                stroke(255, 0, 0);
                strokeWeight(2);
                line(-6, -3, 6, 10);
                line(-6, 10, 6, -3);
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(12);
                text(data[1], 5, 15);
                break;
        }
    }
}

/**
 * Get a description for an effect
 * @param {Object} target - what is affected
 * @param {[String, number]} data - the name and amount of the effect
 * @returns {String} - a description of the effect
*/
function getEffectDescription(target, data) {

    if(allTypes.indexOf(data[0]) >= 0) {
        return "Card effect:\n" + capitalize(data[0]);
    } else if(allSpecialEffects.indexOf(data[0]) >= 0) {
        if(specialEffectData[data[0]].description) {
            return specialEffectData[data[0]].description(data[1]);
        }
    } else {
        switch(data[0]) {
            case "vulnerable":
                return "Take 50% more damage from attacks for " + data[1] + " turn" + ((data[0] > 1) ? "s" : "");
            case "weak":
                return "Deal 25% less damage for " + data[1] + " turn" + ((data[0] > 1) ? "s" : "");
            case "frail":
                return "Gain 25% less defense for " + data[1] + " turn" + ((data[0] > 1) ? "s" : "");
            case "strength":
                return "Deal " + data[1] + " more damage";
            case "no draw":
                return "Cannot draw cards for " + data[1] + " turn" + ((data[0] > 1) ? "s" : "");
        }
    }
    return "Description not available";
}

/**
 * Draw all the effects that a target has
 * @param {Object} target - what is affected
*/
function drawEffects(target) {
    var effects = [];
    for(var i in target.effects) {
        if(target.effects[i]) {
            effects.push([i, target.effects[i]]);
        }
    }
    for(var i = effects.length - 1; i > -1; i--) {
        pushMatrix();
        translate((-(effects.length - 1) / 2 + i) * min(30, (40 / ((effects.length - 1) / 2))), 60);
        drawEffect(target, effects[i]);
        popMatrix();
    }
}

/**
 * Draw the name bar of a target
 * @param {Object} target - what is having their name bar drawn
*/
function nameBar(target) {
    stroke(0, 0, 0);
    strokeWeight(2);
    fill(101, 205, 212);
    var add = (target.type.length - 1) * 6;
    rect(-10 - add / 2, 25, 20 + add, 15, 5);
    fill(0, 0, 0);
    textSize(10);
    textAlign(CENTER, BASELINE);
    text(capitalize(target.type), 0, 37);
}

/**
 * Draws the shield animation for a target
 * @param {Object} target - what is being shielded
*/
function doShieldAnim(target) {
    if(target.shieldAnim) {
        target.shieldAnim = lerp(target.shieldAnim, 0, 0.1);

        var alpha = 255 * target.shieldAnim;

        pushMatrix();

        translate(0, -target.data.height / 2);
        scale(1 - target.shieldAnim);
        noStroke();
        fill(58, 156, 186, alpha);
        var a = 35;
        var a2 = 65;
        var a3 = 190;
        arc(-a, 0, 100 + a * 2, a3, 0, a2);
        arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

        fill(127, 204, 227, alpha);
        triangle(5, 0, -5, 0, 0, 85);

        beginShape();
        vertex(0, -25);
        vertex(50, 0);
        vertex(0, 25);
        vertex(-50, 0);
        endShape(CLOSE);

        line(50, 0, 0, -25);
        line(-50, 0, 0, -25);
        popMatrix();

        if(target.shieldAnim < 1 / 255) {
            target.shieldAnim = 0;
        }
    }
}

/**
 * Draw the stats bar of a target
 * @param {Object} target - what is having their stats bar drawn
*/
function statsBar(target) {

    var add = (target.maxIntegrity.toString().length - 1) * 6;

    var borderRadius = constrain(min(5, (target.dIntegrity / target.maxIntegrity) * 50), 0, 5);

    noStroke();
    fill(255, 33, 33);
    rect(-40, 40, (80 - add / 2 - 8), 10, borderRadius);
    fill(33, 255, 96);
    rect(-40, 40, constrain((80 - add / 2 - 8) * (target.dIntegrity / target.maxIntegrity), 0, 999), 10, borderRadius);
    strokeWeight(2);
    stroke(0, 0, 0);
    noFill();
    rect(-40, 40, (80 - add / 2 - 8), 10, borderRadius);
    fill(255, 149, 0);
    rect(32 - add / 2, 37, 14 + add, 16, 5);

    if(round(target.dDefense) !== 0) {
        var alpha = 255 * ((target.defense > target.dDefense) ? target.dDefense / target.defense : (target.defense === 0) ? target.dDefense : 1);
        fill(0, 187, 255, alpha);
        stroke(0, 0, 0, alpha);
        // var add = (target.defense.toString().length-1)*5;
        // rect(-48-add/2,37,15+add,16,5);
        pushMatrix();

        translate(-40, 39);
        scale(0.2);

        noStroke();
        stroke(0, 0, 0);
        strokeWeight(8);

        fill(58, 156, 186);
        var a = 35;
        var a2 = 65;
        var a3 = 190;
        arc(-a, 0, 100 + a * 2, a3, 0, a2);
        arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

        fill(127, 204, 227);
        noStroke();
        triangle(5, 0, -5, 0, 0, 85);

        beginShape();
        vertex(0, -25);
        vertex(50, 0);
        vertex(0, 25);
        vertex(-50, 0);
        endShape(CLOSE);

        stroke(0, 0, 0);
        line(50, 0, 0, -25);
        line(-50, 0, 0, -25);
        popMatrix();
    }

    fill(0, 0, 0);
    textSize(10);
    textAlign(CENTER, BASELINE);
    text(target.integrity, 39, 49);
    if(round(target.dDefense) !== 0) {
        fill(0, 0, 0);
        textSize(10);
        textAlign(CENTER, BASELINE);
        if(round(target.dDefense) >= 100) {
            textSize(8.5);
            text(round(target.dDefense), -40, 48);
        } else {
            text(round(target.dDefense), -40, 49);
        }
    }
}

/**
 * Draw the graphics for the player
*/
function playerGraphics() {
    // feet
    pushMatrix();
    translate(-24, 106);
    rotate(-7);
    fill(89, 89, 89);
    rect(0, 0, 22, 12, 2);
    popMatrix();
    pushMatrix();
    translate(19, 100);
    rotate(7);
    fill(89, 89, 89);
    rect(0, 0, 22, 12, 2);
    popMatrix();

    // upper body
    pushMatrix();

    translate(0, sin(frameCount * 3) * 5 + 3);

    // torso
    pushMatrix();
    translate(-15, 40);
    fill(196, 42, 196);
    rect(0, 0, 42, 45, 15);
    pushStyle();
    noFill();
    fill(80, 194, 175);
    stroke(80, 194, 175);
    strokeWeight(4);
    triangle(23, 29, 18, 18, 28, 18);
    popStyle();
    popMatrix();

    // hands
    pushMatrix();
    translate(0, sin(frameCount * 3) * 4);

    fill(89, 89, 89);
    ellipse(-36, 74, 20, 20);
    fill(89, 89, 89);
    ellipse(51, 65, 20, 20);
    popMatrix();

    // shoulders
    pushMatrix();
    translate(0, sin(frameCount * 3) * 2);
    pushMatrix();
    translate(-37, 36);
    // rotate(-12);
    rotate(sin(frameCount * 3) * 6 - 18);
    fill(89, 89, 89);
    rect(0, 0, 20, 20, 2);
    popMatrix();
    pushMatrix();
    translate(34, 34);
    rotate(17);
    rotate(sin(frameCount * 3) * 3);
    fill(89, 89, 89);
    rect(0, 0, 20, 20, 2);
    popMatrix();
    popMatrix();

    // neck
    pushMatrix();
    translate(0, sin(frameCount * 3) * 2);
    translate(-22, 25);
    rotate(15);
    fill(166, 166, 166);
    rect(0, 0, 69, 20, 2);
    popMatrix();

    // head & face
    pushMatrix();
    translate(0, sin(frameCount * 3) * 5);
    // head
    pushMatrix();
    translate(-10, -38);
    rotate(9);

    // hair
    pushMatrix();
    translate(-20, -20);
    // rotate(3);
    translate(60, 60);
    rotate(5);
    rotate(cos(frameCount * 3) * 5);
    translate(-60, -60);
    fill(255, 176, 244);
    rect(-20, -20, 70, 70, 30);
    fill(247, 118, 228);
    rect(0, 0, 80, 80, 10);
    popMatrix();

    // main part of head
    fill(181, 27, 189);
    rect(0, 0, 80, 80, 50);
    pushStyle();
    stroke(80, 194, 175);
    strokeWeight(5);
    line(13, 18, 42, 18);
    line(9, 25, 24, 25);
    popStyle();
    popMatrix();

    // scale(-1,1);

    var w = 73;
    var w2 = 59;
    var h = -3;
    var h2 = 13;
    var w3 = 8;
    var w4 = 7;
    var h3 = -7;

    fill(240, 196, 242);
    var x = 72 + sin(frameCount * 3) * 3 + 3;
    var y = 21;
    // mouth
    pushMatrix();
    translate(0, sin(frameCount * 6) * 1.2);
    beginShape();
    vertex(x, y);
    bezierVertex(32 + sin(frameCount * 3) * 5 + 10, 60, -11 + sin(frameCount * 3) * 2 + 5, 61, 14, 20);
    bezierVertex(19, 51, x, y, x, y);
    endShape();
    popMatrix();

    fill(224, 146, 45);
    // visor
    pushMatrix();
    translate(0, sin(frameCount * 3) * 2 + 4);
    beginShape();
    vertex(0, h3);
    vertex(w3, 20 + h3);

    vertex(w3 + w2, 20 - h);

    vertex(w + w4, 20 - h2);
    vertex(w, 0 - h2);

    // vertex(20+w2,0-h);
    vertex(0 + w2, 0 - h);
    endShape(CLOSE);
    stroke(219, 219, 219);
    strokeWeight(5);
    line(67, 5, 71, 0);

    popMatrix();

    popMatrix();
    popMatrix();
}

/**
 * Draw the player
 * @param {Boolean} flip - should the player graphic be flipped horizontally?
*/
function drawPlayer(flip) {
    player.dIntegrity = lerp(player.dIntegrity, player.integrity, 0.1);
    player.dDefense = lerp(player.dDefense, player.defense, 0.1);
    player.dx = lerp(player.dx, player.x, 0.1);
    player.dy = lerp(player.dy, player.y, 0.1);
    pushMatrix();
    translate(player.dx, player.dy);
    pushMatrix();
    if(player.shake) {
        player.shake = lerp(player.shake, 0, 0.1);
        if(player.shake < 0.01) {
            player.shake = 0;
        }
        translate(sin(frameCount * 40) * player.shake, 0);
    }

    pushMatrix();
    if(flip) {
        scale(-1, 1);
    }

    scale(0.8);
    translate(-8, -80);

    stroke(0, 0, 0);
    strokeWeight(5);

    playerGraphics();

    popMatrix();
    popMatrix();

    if(!player.infoDraw) {
        nameBar(player);
        statsBar(player);
        drawEffects(player);
    }

    doShieldAnim(player);

    popMatrix();
    player.infoDraw = false;
}

// draw all the symbols for an enemy's intended attack
enemyObj.prototype.intentSymbols = function() {
    var data = this.data.attacks[this.selectedAttack];
    var symbols = data.symbols;
    for(var i = 0; i < symbols.length; i++) {
        pushMatrix();
        translate((-(symbols.length - 1) / 2 + i) * min(30, (40 / ((symbols.length - 1) / 2))), -this.data.height || -60);
        switch(symbols[i]) {
            case "sword":
                var n = calculateDamage(data, player, this);
                pushMatrix();
                if(n >= 15) {
                    scale(1.2);
                }
                if(n >= 25) {
                    scale(1.2);
                }
                scale(0.2);
                translate(40, -70);
                rotate(30);
                noStroke();
                stroke(115, 0, 0);
                strokeWeight(8);
                fill(194, 64, 64);
                beginShape();
                vertex(-4, 114);
                vertex(-7, 90);
                vertex(-25, 90);
                vertex(-35, 80);
                vertex(-30, 70);
                vertex(-20, 80);
                vertex(-12, 80);
                vertex(-20, -10);
                vertex(0, -50);
                vertex(20, -10);
                vertex(12, 80);
                vertex(20, 80);
                vertex(30, 70);
                vertex(35, 80);
                vertex(25, 90);
                vertex(7, 90);
                vertex(4, 114);
                endShape(CLOSE);
                fill(135, 24, 24);
                beginShape();
                vertex(-25, 90);
                vertex(-35, 80);
                vertex(-30, 70);
                vertex(-20, 80);
                vertex(-12, 80);
                vertex(12, 80);
                vertex(20, 80);
                vertex(30, 70);
                vertex(35, 80);
                vertex(25, 90);
                endShape(CLOSE);
                fill(227, 104, 104);
                beginShape();
                vertex(-12, 111);
                vertex(-8, 105);
                vertex(8, 105);
                vertex(12, 111);
                vertex(0, 124);
                endShape(CLOSE);
                noStroke();
                fill(184, 9, 9);
                beginShape();
                vertex(-1, 80);
                vertex(7, 31);
                vertex(7, -10);
                vertex(0, -40);
                vertex(16, -10);
                vertex(7, 63);
                endShape(CLOSE);
                popMatrix();
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(14);
                text(n, 5, 15);
                break;
            case "shield":
                pushMatrix();
                scale(0.2);
                translate(0, -45);

                noStroke();
                stroke(36, 116, 140);
                strokeWeight(8);

                fill(58, 156, 186);
                var a = 35;
                var a2 = 65;
                var a3 = 190;
                arc(-a, 0, 100 + a * 2, a3, 0, a2);
                arc(a, 0, 100 + a * 2, a3, 180 - a2 + 1, 180);

                fill(127, 204, 227);
                noStroke();
                triangle(5, 0, -5, 0, 0, 85);

                beginShape();
                vertex(0, -25);
                vertex(50, 0);
                vertex(0, 25);
                vertex(-50, 0);
                endShape(CLOSE);
                fill(25, 177, 224);
                triangle(-40, 0, -9, 15, -2, -18);

                stroke(36, 116, 140);
                line(50, 0, 0, -25);
                line(-50, 0, 0, -25);
                popMatrix();
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(14);
                var n = calculateDefense(data, this);
                // var n = 10;
                text(n, 5, 15);
                break;
            case "buff":
                stroke(94, 0, 94);
                strokeWeight(40);
                fire(color(176, 0, 176), color(227, 20, 227), color(232, 142, 232));
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(14);
                text(data.num, 5, 15);
                break;
            case "debuff":
                stroke(5, 92, 0);
                strokeWeight(40);
                fire(color(18, 150, 0), color(27, 189, 83), color(100, 222, 122));
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(14);
                text(data.num, 5, 15);
                break;
            default:
                stroke(92, 78, 0);
                strokeWeight(40);
                fire(color(148, 131, 0), color(189, 181, 28), color(222, 214, 102));
                fill(0, 0, 0);
                textAlign(LEFT, BASELINE);
                textSize(14);
                text(data.num, 5, 15);
                break;
        }
        popMatrix();
    }
};

// draw an enemy
enemyObj.prototype.draw = function() {
    // this.defense = 3;
    // if(clicked){this.attack();}
    pushMatrix();
    this.dx = lerp(this.dx, this.x, 0.1);
    this.dy = lerp(this.dy, this.y, 0.1);
    this.dIntegrity = constrain(lerp(this.dIntegrity, this.integrity, 0.1), 0, 9999);
    this.dDefense = lerp(this.dDefense, this.defense, 0.1);
    translate(this.dx, this.dy);
    pushMatrix();
    if(this.shake) {
        this.shake = lerp(this.shake, 0, 0.1);
        if(this.shake < 0.01) {
            this.shake = 0;
        }
        translate(sin(frameCount * 40) * this.shake, 0);
    }

    if(this.data.draw) {
        this.data.draw(this);
    } else {
        strokeWeight(5);
        stroke(0, 0, 0);
        fill(219, 46, 78);
        ellipse(0, 0, 80, 80);
    }
    popMatrix();
    // this.integrity = round(sin(frameCount)*5+5);
    // this.defense = 0;

    if(!this.infoDraw) {
        this.intentSymbols();
        nameBar(this);
        statsBar(this);
        drawEffects(this);
    }

    doShieldAnim(this);

    popMatrix();
    this.infoDraw = false;
};

// data for the background color of each card rarity
var rarityColors = {
    "basic": color(191, 191, 191),
    "common": color(191, 191, 191),
    "uncommon": color(70, 219, 235),
    "rare": color(227, 189, 53),
    "MALWARE": color(67, 115, 80),
};

// draw a card
cardObj.prototype.draw = function() {
    // this.level = 0;
    pushMatrix();
    this.dx = lerp(this.dx, this.x, 0.1);
    this.dy = lerp(this.dy, this.y, 0.1);
    this.pop = lerp(this.pop, this.toPop, 0.1);
    this.toPop = 1;

    translate(this.dx, this.dy);
    scale(this.pop);
    noStroke();
    fill(rarityColors[this.data.rarity]);
    rect(-50, -70, 100, 80, 5);

    fill(173, 219, 189);
    rect(-50, -15, 100, 85, 5);
    beginShape();
    vertex(-50, 0);
    vertex(-50, -35);
    vertex(-30, -15);
    vertex(30, -15);
    vertex(50, -35);
    vertex(50, 0);
    endShape();

    if(this.level >= 2 || (this.level === 1 && this.data.onlyOneUpgrade)) {
        fill(221, 48, 227);
        beginShape();
        vertex(-30, -33);
        vertex(-20, -23);
        vertex(20, -23);
        vertex(30, -33);
        endShape(CLOSE);
    } else if(this.level === 1) {
        fill(221, 48, 227);
        beginShape();
        vertex(-30, -33);
        vertex(-20, -23);
        vertex(0, -23);
        vertex(0, -33);
        endShape(CLOSE);
    }

    strokeWeight(5);
    stroke(0, 0, 0);
    noFill();
    rect(-50, -70, 100, 140, 5);
    strokeWeight(3);
    line(-50, -35, -30, -15);
    line(-30, -15, 30, -15);
    line(50, -35, 30, -15);

    strokeWeight(2);
    beginShape();
    vertex(-30, -33);
    vertex(-20, -23);
    vertex(20, -23);
    vertex(30, -33);
    endShape(CLOSE);

    strokeWeight(3);
    fill(205, 71, 207);
    for(var i = 0; i < this.cost; i++) {
        rect(-45 + i * 15, -75, 10, 10, 8);
    }

    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(this.data.nameTextSize || 10);
    text(capitalize(this.type), 0, -42);
    textSize(9);
    text(capitalize(this.data.type), 0, -54);
    textAlign(CENTER, BASELINE);
    textSize(9);
    text(this.data.description(this), -47, 2, 94, 70);

    popMatrix();
};


/**
 * Really poorly made function that draws a dashed, curving arrow
 * @param {{{number} x, {number} y} p1 - start of the arrow
 * @param {{{number} x, {number} y} p2 - end of the arrow
 * @param {number} h - extra height of the arrow
 * @param {number} dir - direction of the animation for the moving dashes
*/
function drawDashedArc(p1, p2, h, dir) {

    // so this is absolutely not the best way to do this but i don't think its really hurting anything that much by being a little inefficient
    var lower = (p1.y > p2.y) ? p1 : p2;
    var higher = (p1.y > p2.y) ? p2 : p1;
    var higherX = (p1.x > p2.x) ? p1 : p2;
    var lowerX = (p1.x > p2.x) ? p2 : p1;
    var angle = atan2(higher.y - lower.y, higherX.x - lowerX.x);
    var w = 2 * (higherX.x - lowerX.x) / (1 + cos(angle));
    var midpoint = higherX === higher ? lowerX.x + w / 2 : higherX.x - w / 2;
    var size = 10;
    var shift = dir * frameCount / 2;
    for(var i = 0; i < 90; i += size) {
        var start = i + shift % size + size;
        var stop = (i + size / 4) + shift % size + size;
        arc(
            midpoint,
            lower.y,
            higherX === higher ? (midpoint - lowerX.x) * 2 : (higherX.x - midpoint) * 2,
            (higher.y - lower.y - h) * 2,
            higherX === higher ? 90 + start : 90 - stop,
            higherX === higher ? 90 + stop : 90 - start
        );
    }
    for(var i = 0; i < 90; i += size * 2) {
        var start = i + shift % size * 2 + size;
        var stop = (i + size / 2) + shift % size * 2 + size;
        arc(
            midpoint,
            higher.y,
            higherX !== higher ? (midpoint - lowerX.x) * 2 : (higherX.x - midpoint) * 2,
            (h) * 2,
            higherX === higher ? 360 - stop : 180 + start,
            higherX === higher ? 360 - start : 180 + stop
        );
    }

    var arrowSize = h / 4;
    line(p2.x, p2.y + size, p2.x - arrowSize / 2, p2.y - arrowSize + size);
    line(p2.x, p2.y + size, p2.x + arrowSize / 2, p2.y - arrowSize + size);
    line(p2.x, p2.y + size / 4, p2.x - arrowSize / 2, p2.y - arrowSize + size);
    line(p2.x, p2.y + size / 4, p2.x + arrowSize / 2, p2.y - arrowSize + size);
}

// draw a card (from the top of the draw pile, to the player's hand)
// not to be confused with cardObj.draw
function drawCard() {

    if(!player.effects["no draw"]) {
        if(player.draw.length <= 0) {
            player.discard = shuffleArray(player.discard);
            for(var i = 0; i < player.discard.length; i++) {
                player.draw.push(player.discard[i]);
            }
            player.discard = [];
        }

        if(player.draw[0]) {
            player.hand.push(player.draw[0]);
            player.draw.splice(0, 1);
            var card = player.hand[player.hand.length - 1];
            card.dx = -800;
            card.dy = 500;
            card.x = -800;
            card.y = 500;
            managePowers(player, "cardDraw", {
                card: card
            });
        }

    }

}

/**
 * Draw an info card for the player or an enemy
 * @param {Object} target - who's card is being drawn
 * @param {Boolean} easeOut - if the info card is being eased out (when you stop hovering over the target)
*/
function infoCard(target, easeOut) {
    if(!target.infoAnim) {
        target.infoAnim = 0;
    }
    if(!target.effectInfoScroll) {
        target.effectInfoScroll = 0;
    }
    if(easeOut) {
        target.infoAnim = lerp(target.infoAnim, 0, 0.2);
        if(target.infoAnim < 0.001) {
            target.infoAnim = 0;
        }
        target.effectInfoScroll = 0;
    } else {
        if(1 - target.infoAnim < 0.001) {
            target.infoAnim = 1;
        }
        target.infoAnim = lerp(target.infoAnim, 1, 0.2);
    }

    var effects = [];
    var effect = '';
    for(var i in target.effects) {
        if(target.effects[i]) {
            effects.push(i);
        }
    }
    if(target.effectInfoScroll > effects.length) {
        target.effectInfoScroll = 0;
    }
    if(target.effectInfoScroll > 0) {
        target.addInfoHeight = 70;
        effect = effects[target.effectInfoScroll - 1];
    } else {
        target.addInfoHeight = 0;
    }

    pushMatrix();

    var y = -150;

    translate(target.dx, target.dy);

    pushMatrix();
    scale(target.infoAnim);
    translate(0, y);

    var header = (target.type) ? (capitalize(target.type)) : "CBRPNK";

    var w = max(20 + (header.length - 1) * 6, 150);
    var h = 200 + target.addInfoHeight;

    stroke(0, 0, 0);
    strokeWeight(5);
    fill(163, 240, 203);

    rect(-w / 2, 0, w, h, 5);

    fill(105, 36, 36);
    textSize(10);
    textAlign(CENTER, BASELINE);
    text("Max Integrity: " + target.maxIntegrity, 0, 55);

    if(target === player) {
        fill(145, 106, 20);
        text("Credits: " + target.credits, 0, 70);
    }

    if(target.data.attacks) {
        var attack = target.data.attacks[target.selectedAttack];
        fill(207, 0, 0);
        text("Intent: " + capitalize(attack.name), 0, 70);
        fill(0, 0, 0);
        text(attack.description(attack, target), -w / 2 + 5, 85, w - 10, 50);
    }

    if(target.effectInfoScroll > 0) {
        textSize(10);
        fill(183, 0, 250);
        text("Effect: " + capitalize(effects[target.effectInfoScroll - 1]), 0, 150);
        fill(0, 0, 0);
        text(getEffectDescription(target, [effect, target.effects[effect]]), -w / 2 + 5, 190, w - 10, 80);

    } else {
        if(effects.length > 0) {
            fill(183, 0, 250);
            text("Effects", 0, 150);
            textSize(8);
            fill(183, 0, 250);
            text("Click for more information", 0, 190);
        }
    }

    popMatrix();

    translate(0, target.infoAnim * (y - 25));
    nameBar(target);

    translate(0, target.infoAnim * 10);
    statsBar(target);

    pushMatrix();
    translate(0, target.infoAnim * ((target.data.height || 60) - 10));
    if(target.data.attacks) {
        target.intentSymbols();
    }
    popMatrix();

    translate(0, target.infoAnim * (70 + 50));
    if(target.effectInfoScroll > 0) {
        translate(0, 60);
        drawEffect(target, [effect, target.effects[effect]]);
    } else {
        drawEffects(target);
    }

    if(effects.length > 0) {
        if(clicked && !m.hold) {
            target.effectInfoScroll++;
        }
        if(target.effectInfoScroll > effects.length) {
            target.effectInfoScroll = 0;
        }
    }

    popMatrix();
}

/**
 * Manage the powers of effects and cyberware for a target, for any trigger
 * @param {Object} target - who's powers are being checked
 * @param {String} trigger - the power trigger
 * @param {Object} data - any additional data that is passed. varies with the trigger type.
 * @example
 * player.integrity -= 3;
 * managePowers(player, "integrity lost", {amount:3});
*/
function managePowers(target, trigger, data) {
    for(var i in target.effects) {
        if(target.effects[i]) {
            if(allTypes.indexOf(i) >= 0) {
                if(cardData[i][trigger]) {
                    cardData[i][trigger](target, target.effects[i], data);
                }
            }
            if(allSpecialEffects.indexOf(i) >= 0) {
                if(specialEffectData[i][trigger]) {
                    specialEffectData[i][trigger](target, target.effects[i], data);
                }
            }
        }
    }
    if(target.cyberware) {
        for(var i = 0; i < target.cyberware.length; i++) {
            if(target.cyberware[i].data[trigger]) {
                target.cyberware[i].data[trigger](target, target.cyberware[i], data);
            }
        }
    }
}

/**
 * Decrease effects that last only a certain number of turns
 * @param {Object} target - who is affected
*/
function manageEffects(target) {
    var decreasing = ["vulnerable", "weak", "no draw", "frail"];
    for(var i = 0; i < decreasing.length; i++) {
        if(target.effects[decreasing[i]]) {
            target.effects[decreasing[i]]--;
        }
    }
}

// check for dead enemies and get rid of them
function checkDeaths() {
    for(var i = enemies.length - 1; i > -1; i--) {
        if(enemies[i].integrity <= 0) {
            managePowers(enemies[i], "death");
            enemies.splice(i, 1);
        }
    }
}

// end the player's turn
function endTurn() {
    m.hold = false;
    m.lastHeld = false;

    manageEffects(player);
    if(enemies.length > 0) {
        managePowers(player, "endTurn");
    }
    checkDeaths();

    for(var i = 0; i < player.resetCosts.length; i++) {
        player.resetCosts[i].cost = player.resetCosts[i].data.baseCost(player.resetCosts[i]);
    }
    player.resetCosts = [];
    for(var i = player.hand.length - 1; i > -1; i--) {
        player.discard.push(player.hand[i]);
        discarding.push(player.hand[i]);
        if(player.hand[i].data.unused) {
            player.hand[i].data.unused(player.hand[i]);
        }
        player.hand.splice(i, 1);
    }
    for(var i = 0; i < enemies.length; i++) {
        var enemy = enemies[i];
        managePowers(enemy, "startTurn");
        if(enemy.keepShield) {
            enemy.keepShield = false;
        } else {
            enemy.defense = 0;
        }

        enemy.attack();
    }

    checkDeaths();
}

/**
 * start the player's turn
 * @param {Boolean} isFirstTurn - if it's the player's first turn of the fight
*/
function initTurn(isFirstTurn) {
    m.hold = false;
    m.lastHeld = false;
    checkDeaths();

    for(var i = 0; i < enemies.length; i++) {
        var enemy = enemies[i];
        if(enemy.data.chooseAttack) {
            enemy.selectedAttack = enemy.data.chooseAttack(enemy);
        } else {
            enemy.selectedAttack = floor(random(0, enemy.data.attacks.length));
        }

        if(!isFirstTurn) {
            manageEffects(enemy);
            managePowers(enemy, "endTurn");
        }
    }
    for(var i = 0; i < player.handSize; i++) {
        drawCard();
    }
    player.energy = player.maxEnergy;
    managePowers(player, "startTurn");
    if(player.keepShield) {
        player.keepShield = false;
    } else {
        player.defense = 0;
    }

    checkDeaths();
}

// various buttons
var endTurnButton = new button(550, 470, 40, 40);
endTurnButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(128, 255, 0);
    rect(-20 - 15 * anim, -20 - 3 * anim, 40 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    scale(1 + anim * 0.2);
    text("END\nTURN", 0, -2);
    popMatrix();
};
endTurnButton.onClick = function() {
    if(!stack[0] && !attacks[0]) {
        endTurn();
    }
};
var drawButton = new button(50, 550, 40, 40);
drawButton.saveAnim = true;
drawButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(255, 221, 0);
    rect(-20 - 15 * anim, -20 - 3 * anim, 40 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    scale(1 + anim * 0.2);
    text("DRAW\n" + player.draw.length, 0, -2);
    popMatrix();
};
drawButton.onClick = function() {
    if(!stack[0]) {
        queueSelection();
        noSelection = true;
        var view = [];
        for(var i = 0; i < player.draw.length; i++) {
            player.draw[i].dx = -200;
            player.draw[i].dy = 550;
            view.push(player.draw[i]);
        }
        view = shuffleArray(view);
        selection = view;
        selectionCaption = "Your Draw Pile\nDraw " + player.handSize + " cards each turn";
    }
};
var discardButton = new button(550, 550, 40, 40);
discardButton.saveAnim = true;
discardButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(122, 118, 95);
    rect(-20 - 15 * anim, -20 - 3 * anim, 40 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    scale(1 + anim * 0.2);
    var txt = "DSCD";
    if(anim > 0.4) {
        txt = "DSCRD";
        if(anim > 0.6) {
            txt = "DSCARD";
            if(anim > 0.8) {
                txt = "DISCARD";
            }
        }
    }
    text(txt + "\n" + player.discard.length, 0, -2);
    popMatrix();
};
discardButton.onClick = function() {
    if(!stack[0]) {
        queueSelection();
        noSelection = true;
        var view = [];
        for(var i = 0; i < player.discard.length; i++) {
            player.discard[i].dx = 800;
            player.discard[i].dy = 550;
            view.push(player.discard[i]);
        }
        view = shuffleArray(view);
        selection = view;
        selectionCaption = "Your Discard Pile";
    }
};
var deckButton = new button(50, 550, 40, 40);
deckButton.saveAnim = true;
deckButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(255, 145, 0);
    rect(-20 - 15 * anim, -20 - 3 * anim, 40 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    scale(1 + anim * 0.2);
    text("DECK\n" + player.deck.length, 0, -2);
    popMatrix();
};
deckButton.onClick = function() {
    if(!stack[0]) {
        queueSelection();
        noSelection = true;
        selection = player.deck;
        selectionCaption = "Your Deck";
    }
};

// the progress of the scene transition animation for some scenes
var snapshotAnim = 1.1;

// stores data for each tower level
var towerSegments = [];

// stores data about the tower
var tower = {
    scroll: 0,
    toScroll: 0,
    dragging: false,
    onDrag: 0,
    confirming: false,
    confirmAnim: 0,
    indicatorAnim: 0,
    healAnim: 0,
    cardRewards: [],
    intro: false,
};

// animation trackers for the menu and lose scenes
var menuAnim = 0;
var loseAnim = 0;

// draws info for the current level in the top left corner
function levelInfo() {
    noStroke();
    fill(186, 186, 186, 230);
    rect(-100, 20, 240, 30, 10);
    rect(-100, 55, 300, 30, 10);
    fill(0, 0, 0);
    textSize(20);
    textAlign(LEFT, BASELINE);
    text("Tower " + (player.curTower + 1), 20, 42);
    text("Floor " + (player.level) + " / " + (towerSegments.length - 1), 20, 77);
}

/**
 * Generates a new tower
 * @param {number} numFloors - how many floors to create
*/
function generateTower(numFloors) {
    tower = {
        scroll: 0,
        toScroll: 0,
        dragging: false,
        onDrag: 0,
        confirming: false,
        confirmAnim: 0,
        indicatorAnim: 0,
        healAnim: 0,
        cardRewards: [],
        intro: 1,
    };
    player.curLevelFights = 0;
    player.level = 0;
    player.integrity = player.maxIntegrity;

    towerSegments = [];

    var merchantLast = false;

    var restCount = 0;

    for(var i = 0; i < numFloors; i++) {
        var h = random(300, 500);
        var w = random(200, 550);
        var options = [];
        var num = (w > 450) ? 3 : (w > 300) ? 2 : 1;

        if(i === 0) {
            options = ["boss fight"];
            h = 350;
            w = 350;
        } else {
            var things = ["fight", "fight"];

            if(!merchantLast) {
                things.push("merchant");
            }
            if(restCount < 2) {
                things.push("rest");
            } else if(merchantLast) {
                things.push("fight");
            }

            merchantLast = false;
            for(var q = 0; q < num; q++) {
                var choice = floor(random(0, things.length));
                if(q === 0 && i === numFloors - 1) {
                    choice = 0;
                }
                if(q === 0 && i === 1) {
                    choice = 3;
                }
                options.push(things[choice]);
                if(things[choice] === "merchant") {
                    merchantLast = true;
                }
                if(things[choice] === "rest") {
                    restCount++;
                }
                things.splice(choice, 1);
            }
            if(options.indexOf("rest") < 0) {
                restCount = 0;
            }
        }

        towerSegments.push({
            w: w,
            h: h,
            yDis: 600 - h,
            options: options,
            pops: [0, 0, 0, 0, 0, 0],
            side: floor(random(0, 2)),
        });
    }
}

/**
 * Initiate the map scene
 * @param {Boolean} isFirstFloor - if it's the first floor of the run
*/
function initMap(isFirstFloor) {

    player.effects = {};
    player.defense = 0;

    if(isFirstFloor) {
        generateTower(16);
    } else {
        player.level++;
        player.level = round(player.level);
        if(player.level > towerSegments.length - 1) {
            player.curTower++;
            generateTower(16);
        }
    }

    scene = 'map';
    player.level = constrain(player.level, 0, towerSegments.length - 1);

    // player.level = 0;

    var curSeg = towerSegments[towerSegments.length - 1 - player.level];

    tower.toScroll = (towerSegments.length - 1 - player.level) * 600;

    if(player.curTower === 3) {
        scene = 'win';
        menuAnim = 0;
    }

}

// a butt-tonn of buttonns 
var leaveFightButton = new button(400, 550, 80, 40);
leaveFightButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(225, 0, 255);
    rect(-40 - 15 * anim, -20 - 3 * anim, 80 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    // scale(1+anim*0.2);
    if(!tower.cardRewardSelected) {
        var a = "(Skip Reward)";
        text("Leave\n" + a.substring(0, (a.length + 1) * anim), 0, 4 - anim * 6);
    } else {
        text("Leave", 0, 4);
    }

    popMatrix();
};
leaveFightButton.onClick = function() {
    initMap();
    snapshotAnim = 0;
};
var leaveMerchantButton = new button(500, 550, 80, 40);
leaveMerchantButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(26, 161, 8);
    rect(-40 - 15 * anim, -20 - 3 * anim, 80 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    scale(1 + anim * 0.2);
    text("Leave", 0, 4);
    popMatrix();
};
leaveMerchantButton.onClick = function() {
    initMap();
    snapshotAnim = 0;
};
var toMenuButton = new button(300, 550, 100, 40);
toMenuButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(168, 168, 168);
    rect(-50 - 15 * anim, -20 - 3 * anim, 100 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    scale(1 + anim * 0.2);
    text("Try Again?", 0, 4);
    popMatrix();
};
toMenuButton.onClick = function() {
    scene = 'menu';
};
var upgradeButton = new button(400, 500, 160, 100);
upgradeButton.saveAnim = true;
upgradeButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(214, 81, 210);
    rect(-80 - 15 * anim, -50 - 3 * anim, 160 + 30 * anim, 100 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(14);
    pushMatrix();
    scale(1 + anim * 0.2);
    text("Upgrade 1 card\nin your deck", 0, -2);
    popMatrix();
};
upgradeButton.onClick = function() {
    if(tower.restReward) {
        var filtered = [];
        for(var i = 0; i < player.deck.length; i++) {
            if(player.deck[i].level < 2 && !(player.deck[i].level === 1 && player.deck[i].data.onlyOneUpgrade)) {
                filtered.push(player.deck[i]);
            }
        }
        if(filtered.length > 0) {
            tower.restReward = false;
            queueSelection();
            selection = filtered;
            selectionCaption = "Choose a card to upgrade";
            tower.choosingUpgrade = true;
        }
    }
};
var healButton = new button(200, 500, 160, 100);
healButton.saveAnim = true;
healButton.art = function(anim) {
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(255, 230, 0);
    rect(-80 - 15 * anim, -50 - 3 * anim, 160 + 30 * anim, 100 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(14);
    pushMatrix();
    scale(1 + anim * 0.2);
    text("Recover all\nintegrity", 0, -2);
    popMatrix();
};
healButton.onClick = function() {
    if(tower.restReward) {
        tower.restReward = false;
        tower.healAnim = 1;
        tower.startingHeal = player.integrity;
    }
};


// modifier for rare card chance
var rareRewardMod = -5;

/**
 * Generates a new card reward
 * @param {number} baseRare - the base chance for a rare card
 * @returns {String} the name of a card
*/
function cardReward(baseRare) {
    var rarity = manageProbabilities([
        ['common', constrain((100 - 37 - baseRare) - rareRewardMod, 0, 63)],
        ['uncommon', 37],
        ['rare', constrain(baseRare + rareRewardMod, 0, 63)],
    ]);
    if(rarity === 'common') {
        rareRewardMod++;
    }
    if(rarity === 'rare') {
        rareRewardMod = -5;
    }

    return rarityData[rarity][floor(random(0, rarityData[rarity].length))];
}

// generates the rewards for winning a fight
function fightRewards() {

    tower.cardRewards = [];
    if(player.level === towerSegments.length - 1) {
        tower.rewardCredits = 75;
        player.credits += tower.rewardCredits;
        for(var i = 0; i < 4; i++) {
            var type = rarityData.rare[floor(random(0, rarityData.rare.length))];
            var card = new cardObj(type, 0);
            card.dy = -100;
            card.dx = 400;
            tower.cardRewards.push(card);
        }
    } else {
        tower.rewardCredits = floor(random(AVG_ENEMY_CREDITS_REWARD - 5, AVG_ENEMY_CREDITS_REWARD + 11));
        player.credits += tower.rewardCredits;
        for(var i = 0; i < NUM_REWARD_CARD_OPTIONS; i++) {
            var type = cardReward(BASE_RARE_CHANCE_PERCENT);
            var card = new cardObj(type, 0);
            card.dy = -100;
            card.dx = 400;
            tower.cardRewards.push(card);
        }
    }
    tower.cardRewardSelected = false;
}

// stores data about the merchant
var merchant = {
    cards: [],
    costData: {
        common: [20, 35],
        uncommon: [35, 50],
        rare: [50, 89],
    },
    restCost: 40,
    trimCost: 25,
    selected: false,
    selectedAnim: 0,
    notEnoughCreditsAnim: 0,
    animBuy: false,
    rested: false,
    trimming: false,
};

/**
 * Initiates the merchant scene
 * @param {Boolean} noReset - if the merchant shouldn't be reset
*/
function initMerchant(noReset) {
    scene = "merchant";
    snapshotAnim = 0;
    merchant.selected = false;
    player.restAnim = 0;
    merchant.notEnoughCreditsAnim = 0;
    merchant.selectedAnim = 0;

    if(!noReset) {
        merchant.cards = [];
        var pRareRewardMod = rareRewardMod;
        rareRewardMod = 0;

        for(var i = 0; i < 7; i++) {
            var type = cardReward(10);
            var card = new cardObj(type, 0);
            card.dy = -100;
            card.dx = 300;
            var data = merchant.costData[card.data.rarity];
            if(!data) {
                data = [100, 100];
            }
            card.merchantCost = floor(random(data[0], data[1] + 1));
            merchant.cards.push(card);
        }
        rareRewardMod = pRareRewardMod;
    }
}

// initiates the rest scene
function initRest() {
    scene = "rest";
    snapshotAnim = 0;
    player.restAnim = 0;
    tower.restReward = true;
    tower.healAnim = 0;
    tower.upgradeAnim = 0;
    merchant.rested = false;
}

/**
 * Initiates the fight scene
 * @param {Boolean} boss - if the fight is a boss fight
*/
function initFight(boss) {
    scene = "fight";
    snapshotAnim = 0;
    player.effects = {};
    player.resetCosts = [];
    player.cyberware = [];
    player.handSize = 5;
    player.defense = 0;
    player.win = false;
    discarding = [];
    drawAdding = [];
    deleted = [];

    portDeck();

    var innates = [];
    for(var i = player.draw.length - 1; i > -1; i--) {
        var card = player.draw[i];
        if(card.data.innate) {
            if(card.data.innate(card)) {
                player.draw.splice(i, 1);
                innates.push(card);
            }
        }
    }
    for(var i = 0; i < innates.length; i++) {
        player.draw.splice(0, 0, innates[i]);
    }

    // player.curLevelFights = 0;
    // player.curTower = 0;

    enemies = [];

    var easyFightNum = 3;
    if(player.curTower >= 2) {
        easyFightNum = 2;
    }

    var roster = false;

    var rosterFunc = false;

    while(!roster || player.pRoster === rosterFunc) {
        rosterFunc = manageProbabilities(encounters[player.curTower][(player.level === towerSegments.length - 1) ? 2 : (player.curLevelFights < easyFightNum) ? 0 : 1]);

        roster = rosterFunc();
    }

    player.pRoster = rosterFunc;

    for(var i = 0; i < roster.length; i++) {
        var enemy = new enemyObj(roster[i]);
        enemies.push(enemy);
    }

    player.curLevelFights++;

    initTurn(true);
}


// mmmmooooreeeee buttons
var merchantRestButton = new button(500, 450, 50, 50);
merchantRestButton.art = function(anim) {
    pushMatrix();
    scale(1 + anim * 0.1 + ((merchant.selected === 'rest') ? merchant.selectedAnim * 0.1 : 0));
    translate(0, -16);
    noStroke();
    fill(179, 98, 22);

    rect(-25, 8, 50, 4);
    rect(-25, 1, 50, 4);
    beginShape();
    vertex(-25, 15);
    vertex(25, 15);
    vertex(30, 20);
    vertex(-30, 20);
    endShape();
    beginShape();
    vertex(30, 22);
    vertex(25, 22);
    vertex(17, 35);
    vertex(19, 37);
    endShape();
    beginShape();
    vertex(20, 22);
    vertex(15, 22);
    vertex(8, 33);
    endShape();
    beginShape();
    vertex(-30, 22);
    vertex(-25, 22);
    vertex(-17, 35);
    vertex(-19, 37);
    endShape();
    beginShape();
    vertex(-20, 22);
    vertex(-15, 22);
    vertex(-8, 33);
    endShape();
    popMatrix();
};
merchantRestButton.onClick = function() {
    if(merchant.selected === 'rest') {
        if(player.credits >= merchant.restCost) {
            player.credits -= merchant.restCost;
            initRest();
            merchant.rested = true;
            snapshotAnim = 0;
        } else {
            merchant.notEnoughCreditsAnim = 1;
        }
    } else {
        merchant.selected = 'rest';
        merchant.selectedAnim = 0;
    }
};
var trimDeckButton = new button(130, 120, 40, 40);
trimDeckButton.art = function(anim) {
    pushMatrix();
    scale(1 + ((merchant.selected === 'trim') ? merchant.selectedAnim * 0.1 : 0));
    strokeWeight(5);
    stroke(0, 0, 0);
    fill(26, 161, 8);
    rect(-20 - 15 * anim, -20 - 3 * anim, 40 + 30 * anim, 40 + 6 * anim, 8);
    fill(0, 0, 0);
    textAlign(CENTER, BASELINE);
    textSize(12);
    pushMatrix();
    scale(1 + anim * 0.2);
    var a = "1 Card";
    text("Trim\n" + a.substring(0, (a.length + 1) * anim), 0, 4 - anim * 6);
    popMatrix();
    popMatrix();
};
trimDeckButton.onClick = function() {
    if(merchant.selected === 'trim') {
        if(player.credits >= merchant.trimCost) {
            player.credits -= merchant.trimCost;
            merchant.trimming = true;
            queueSelection();
            selectionCaption = "Select a card to remove from your deck";
            selection = player.deck;
            merchant.selected = false;
        } else {
            merchant.notEnoughCreditsAnim = 1;
        }
    } else {
        merchant.selected = 'trim';
        merchant.selectedAnim = 0;
    }
};

// start a new run
function newRun() {

    player = {

        draw: [],
        hand: [],
        discard: [],

        deck: [],

        data: {
            height: 130,
        },

        maxIntegrity: PLAYER_MAX_INTEGRITY,
        energy: 3,
        maxEnergy: 3,
        dEnergy: 3,
        notEnoughEnergyAnim: 0,
        integrity: PLAYER_MAX_INTEGRITY,
        dIntegrity: PLAYER_MAX_INTEGRITY,
        defense: 0,
        dDefense: 0,
        handSize: PLAYER_HANDSIZE,
        type: "CBRPNK",

        credits: STARTING_CREDITS,

        level: 0,

        curTower: 0,

        curLevelFights: 0,

        effects: {},

        resetCosts: [],
        cyberware: [],

        dx: 0,
        dy: 0,
        x: 0,
        y: 0,
    };

    // player.curTower = 2;
    initMap(true);

    // player.level = 14;

    player.deck = [];
    for(var i = 0; i < 4; i++) {
        var card = new cardObj("firewall", 0);
        player.deck.push(card);
    }
    for(var i = 0; i < 5; i++) {
        var card = new cardObj("spike", 0);
        player.deck.push(card);
    }
    var card = new cardObj("shellshock", 0);
    player.deck.push(card);
}

/**
A lot of stuff that helped when testing is commented out here
I'm not gonna get rid of it because its like ancient history
*/

// newRun();

// var most = '';
// for(var i in enemyData){
//     for(var q = 0; q < enemyData[i].attacks.length; q++){
//         var name = enemyData[i].attacks[q].name;
//         if(name.length > most.length){
//             most = name;
//         }
//     }

// }
// println(most);

// for(var i = 0; i < 45; i++){
//     initFight();
//     for(var q = 0; q < enemies.length; q++){
//         if(!enemyData[enemies[q].type]){
//             println('e');
//         }
//     }
//     initMap();
// // }
// player.level = 15;
// player.curTower = 2;
// player.curLevelFights = 4;
// initFight();
// enemies = [];
// for(var i = allEnemies.length-1; i > -1; i--){
//     if(enemyData[allEnemies[i]].draw){
//         if(enemies.length<2){
//         enemies.push(new enemyObj(allEnemies[i]));
//         }else{
//         i = -1;
//         }
//     }
// }
// player.integrity = 1;
// player.effects.weak = 10;
// player.effects.strength = 20;
// player.effects.ritual = 10;
// player.defense = 90;
// player.effects["no draw"] = 10;
// initRest();
// // initMerchant();
// for(var i = 0; i < allSpecialEffects.length; i++){
//     player.effects[allSpecialEffects[i]] = 1;
// }

// what millis() was last frame
var lMillis = millis();

// total time in millis the game has been running
var totalTime = 0;

function draw() {
    try {
    var mTemp = getTrueMouse();
    msx = mTemp.x;
    msy = mTemp.y;
    
    
    // calculate difference in millis between frames
    var tMillis = millis() - lMillis;
    lMillis = millis();
    // update time tracker
    totalTime += tMillis;
    
    
    cursor(ARROW);
    background(61, 61, 61);

    pushMatrix();
    
    // scene transition animation
    if(snapshotAnim < 1) {
        translate((1 - snapshotAnim) * -600, 0);
    }
    
    // manage each scene
    switch(scene) {
        // the first scene
        case "menu": {
            background(200, 0, 255);
            cursor(HAND);
            var t = ((frameCount % 200) / 10);
            pushMatrix();
            if(t < 1) {
                var a = 1 - t;
                translate(a * 100, a * 50);
            }
            noStroke();
            
            // epic background
            pushMatrix();
            rotate(-30 + sin(frameCount * (3 / 8)) * 10);
            var n = 8;
            var a = sin(frameCount * (3 / 4)) * 30;
            for(var i = 0; i < n; i++) {
                fill(200 - a, i * (185 / n) + a, 255 - i * (245 / n) + a);
                rect(-400, (sin(frameCount * (3 / 2) + i * (360 / n)) - 1) * 20 + i * 110, 1000, 200);
            }
            popMatrix();
            
            
            // title letters
            pushMatrix();
            translate(0, -100 + sin(frameCount * 3) * -10 + 10);
            fill(0, 0, 0);
            stroke(255, 255, 255);
            strokeWeight(10);
            //{
            beginShape();
            vertex(192, 133);
            vertex(131, 118);
            vertex(53, 165);
            vertex(37, 244);
            vertex(64, 310);
            vertex(153, 338);
            vertex(271, 357);
            vertex(160, 312);
            vertex(107, 278);
            vertex(86, 240);
            vertex(94, 194);
            vertex(142, 153);
            vertex(220, 171);
            endShape(CLOSE);
            beginShape();
            vertex(215, 195);
            vertex(207, 302);
            vertex(261, 330);
            vertex(296, 319);
            vertex(316, 281);
            vertex(282, 253);
            vertex(308, 237);
            vertex(324, 210);
            vertex(322, 184);
            vertex(267, 168);
            endShape(CLOSE);
            beginShape();
            vertex(351, 184);
            vertex(338, 348);
            vertex(372, 351);
            vertex(375, 299);
            vertex(397, 279);
            vertex(430, 291);
            vertex(539, 378);
            vertex(432, 253);
            vertex(481, 220);
            vertex(487, 173);
            vertex(433, 128);
            vertex(367, 134);
            endShape(CLOSE);
            popMatrix();
            pushMatrix();
            translate(0, sin(frameCount * 3) * 10 - 10);
            fill(0, 0, 0);
            stroke(255, 255, 255);
            strokeWeight(10);
            beginShape();
            vertex(93, 379);
            vertex(87, 508);
            vertex(73, 574);
            vertex(96, 586);
            vertex(108, 534);
            vertex(116, 464);
            vertex(183, 485);
            vertex(236, 429);
            vertex(251, 377);
            vertex(153, 343);
            endShape(CLOSE);
            beginShape();
            vertex(260, 389);
            vertex(238, 572);
            vertex(274, 580);
            vertex(286, 441);
            vertex(340, 582);
            vertex(429, 345);
            vertex(395, 338);
            vertex(349, 474);
            vertex(299, 349);
            endShape(CLOSE);
            beginShape();
            vertex(448, 353);
            vertex(373, 574);
            vertex(405, 580);
            vertex(432, 496);
            vertex(456, 488);
            vertex(520, 574);
            vertex(549, 573);
            vertex(504, 493);
            vertex(471, 455);
            vertex(456, 460);
            vertex(585, 390);
            vertex(554, 384);
            vertex(444, 440);
            vertex(488, 351);
            vertex(458, 333);
            endShape(CLOSE);
            //}
            popMatrix();
            
            // the player graphic
            pushMatrix();
            translate(280, 300);
            scale(1.5);
            stroke(0, 0, 0);
            strokeWeight(5);
            playerGraphics();
            popMatrix();

            fill(255, 255, 255, (100 + 155 * abs(sin(frameCount * 3))) * (1 - menuAnim));
            textAlign(CENTER, BASELINE);
            textSize(20);
            text("PRESS AND HOLD TO START", 300, 300);

            noStroke();
            fill(10, 10, 87, (150) * max(0, (1 - t)));
            rect(-500, -500, 1600, 1600);
            fill(0, 0, 0, 255 * menuAnim);
            rect(-500, -500, 1600, 1600);

            // start the game
            if(!mouseIsPressed) {
                menuAnim = lerp(menuAnim, 0, 0.1);
            } else {
                // if(menuAnim >= 0.8){
                // var a = ["hand","arrow","grab","grabbing","move","help","none","not-allowed","text"];
                // cursor(a[floor(random(0,a.length))]);
                // }

                menuAnim += tMillis / 3000;
                if(menuAnim >= 1) {
                    menuAnim = 0;
                    newRun();
                }
            }
            
            // glitchy effects
            var n = 1 + floor(random(0, 1.03)) + floor(sin(frameCount * 3) + 1);
            for(var i = 0; i < n; i++) {
                var y = (frameCount * 4 + i * (1000 / 3)) % 1000;
                var h = (i + 1) * 20;
                var strip = get(0, y, 600, h);
                image(strip, 10, y);
            }
            if(t < 1) {
                var a = 1 - t;
                var img = get(a * 100, a * 50, 400, 400);
                image(img, -250 * a, -80 * a);
            }
            popMatrix();
        }
        break;
        // the map
        case "map": {
            background(91, 96, 143);
            pushMatrix();
            noStroke();
            rotate(-30 + sin(frameCount * (3 / 8)) * 10);
            var n = 8;
            var a = (player.curTower === 0) ? 0 : (player.curTower === 1) ? 60 : 150;
            for(var i = 0; i < n; i++) {
                fill(200 - a * 1.5, i * (185 / n) - a, 255 - i * (245 / n));
                rect(-400, (sin(frameCount * (3 / 2) + i * (360 / n)) - 1) * 20 + i * 110, 1000, 200);
            }
            popMatrix();

            if(tower.intro) {

                tower.intro += tMillis;

                background(41, 9, 41);
                noStroke();
                fill(0, 0, 0, 255 * (200 / tower.intro));
                rect(-100, -100, 800, 800);

                if(tower.intro > 1000 && tower.intro < 4000) {
                    fill(230, 0, 255);
                    textSize(40);
                    textAlign(CENTER, BASELINE);
                    var towerNames = [
                        "TOWER ONE",
                        "TOWER TWO",
                        "THE FINAL TOWER",
                    ];
                    text(towerNames[player.curTower], 300, 300);
                }
                if(tower.intro > 5000) {
                    tower.intro = false;
                }
                // tower.intro = false;
            } else {

                pushMatrix();

                tower.scroll = constrain(tower.scroll, 0, (600 * towerSegments.length) - towerSegments[towerSegments.length - 1].yDis - 600);

                translate(0, -tower.scroll);

                if(tower.toScroll < ((towerSegments.length - 1 - player.level) * 600) - 800) {
                    tower.indicatorAnim = lerp(tower.indicatorAnim, 1, 0.1);
                } else {
                    tower.indicatorAnim = lerp(tower.indicatorAnim, 0, 0.1);
                }
                //{

                stroke(0, 0, 0);
                strokeWeight(5);
                fill(97, 61, 12);
                rect(-100, 600 * towerSegments.length - towerSegments[towerSegments.length - 1].yDis - 60, 800, 200);

                var descent = 0;
                var mostRight = towerSegments[0];
                var mostLeft = towerSegments[0];
                for(var i = 0; i < towerSegments.length; i++) {
                    var seg = towerSegments[i];
                    var pSeg = (i !== 0) ? towerSegments[i - 1] : seg;
                    var x;
                    if(i === 0) {
                        x = 300 - seg.w / 2;
                    } else {
                        x = (pSeg.x) + seg.side * (pSeg.w - seg.w);
                    }

                    x = constrain(x, 0, 600 - seg.w);

                    seg.x = x;

                    if(i < towerSegments.length - 3) {
                        if(x + seg.w >= mostRight.x + mostRight.w) {
                            mostRight = seg;
                        }
                        if(x <= mostLeft.x) {
                            mostLeft = seg;
                        }
                    }

                    seg.y = descent;
                    descent += seg.h + seg.yDis;
                }
                descent -= towerSegments[towerSegments.length - 1].yDis;

                strokeWeight(5);
                stroke(0, 0, 0);
                fill(227, 22, 227);
                rect(mostRight.x + mostRight.w - 13, mostRight.y + mostRight.h, 10, descent - mostRight.y - mostRight.h);
                rect(mostLeft.x + 2, mostLeft.y + mostLeft.h, 10, descent - mostLeft.y - mostLeft.h);

                var c = color(61, 61, 61);

                for(var i = floor(tower.scroll / 600); i < min(floor(tower.scroll / 600) + 3, towerSegments.length); i++) {
                    var floorNum = towerSegments.length - i;
                    var seg = towerSegments[i];
                    var pSeg = (i !== 0) ? towerSegments[i - 1] : seg;

                    //{
                    strokeWeight(5);
                    stroke(0, 0, 0);
                    fill(c);
                    var w = abs(sin(i * 234)) * (20) + 10;
                    rect(seg.x + sin(i * 582) * (w), seg.y + 50 + abs(sin(i * 1234)) * (seg.h - 140), seg.w + w, 40, 1);

                    noStroke();
                    fill(c);
                    rect(seg.x, seg.y - 2, seg.w, seg.h + 4);

                    fill(255, 153, 0);
                    rect(seg.x + 10, seg.y + seg.h - 40, seg.w - 20, 5, 1);
                    rect(seg.x + 10, seg.y + 40, seg.w - 20, 5, 1);

                    if(player.level >= floorNum) {
                        fill(210, 0, 214);
                        textSize(35);
                        textAlign(CENTER, BASELINE);
                        pushMatrix();
                        translate(cos(frameCount * 6) * 4, 0);
                        text("CLEARED", seg.x + seg.w / 2, seg.y + seg.h / 2);
                        popMatrix();
                    }

                    noStroke();
                    fill(c);
                    if(i !== 0) {
                        beginShape();
                        vertex(seg.x, seg.y);
                        vertex(seg.x + seg.w, seg.y);
                        vertex(pSeg.x + pSeg.w, seg.y - pSeg.yDis);
                        vertex(pSeg.x, seg.y - pSeg.yDis);
                        endShape(CLOSE);
                    }

                    strokeWeight(5);
                    stroke(0, 0, 0);
                    line(seg.x, seg.y, seg.x, seg.y + seg.h);
                    line(seg.x + seg.w, seg.y, seg.x + seg.w, seg.y + seg.h);
                    if(i !== 0) {
                        line(seg.x, seg.y, pSeg.x, pSeg.y + pSeg.h);
                        line(seg.x + seg.w, seg.y, pSeg.x + pSeg.w, pSeg.y + pSeg.h);
                    }

                    strokeWeight(5);
                    stroke(97, 97, 97);
                    line(seg.x + 10, seg.y + seg.h / 4, seg.x + 10, seg.y + (seg.h / 4) * 3);
                    line(seg.x + seg.w - 10, seg.y + seg.h / 4, seg.x + seg.w - 10, seg.y + (seg.h / 4) * 3);

                    var avgX = (seg.x + pSeg.x) / 2;
                    var avgW = (seg.w + pSeg.w) / 2;

                    if(i !== 0) {
                        if(i % 2 === 0) {
                            strokeWeight(30);
                            stroke(112, 112, 112);
                            line(seg.x + 40, seg.y, pSeg.x + 40, pSeg.y + pSeg.h);

                            fill(72, 155, 163);
                            textSize(50);
                            textAlign(CENTER, BASELINE);
                            text(floorNum, avgX + avgW / 2 + 40, seg.y - pSeg.yDis / 2 + 20);

                        } else {
                            for(var q = 0; q < 3; q++) {
                                var x = q * 30;
                                strokeWeight(5);
                                stroke(99, 130, 140);
                                line(seg.x - 40 - x + seg.w, seg.y, pSeg.x - 40 - x + pSeg.w, pSeg.y + pSeg.h);
                            }

                            fill(72, 155, 163);
                            textSize(50);
                            textAlign(CENTER, BASELINE);
                            text(floorNum, avgX + avgW / 2 - 40, seg.y - pSeg.yDis / 2 + 20);

                        }
                    }
                    //}

                    if(player.level + 1 === floorNum) {
                        strokeWeight(5);

                        var a = abs(sin(frameCount * 1.5)) * 3;
                        pushMatrix();
                        translate(a, 0);
                        stroke(168, 74, 168);
                        line(seg.x + 20, seg.y + seg.h / 4, seg.x + 20, seg.y + (seg.h / 4) * 3);
                        translate(a, 0);
                        stroke(230, 30, 230);
                        line(seg.x + 30, seg.y + seg.h / 4, seg.x + 30, seg.y + (seg.h / 4) * 3);
                        translate(-a * 3, 0);
                        stroke(168, 74, 168);
                        line(seg.x + seg.w - 20, seg.y + seg.h / 4, seg.x + seg.w - 20, seg.y + (seg.h / 4) * 3);
                        translate(-a, 0);
                        stroke(230, 30, 230);
                        line(seg.x + seg.w - 30, seg.y + seg.h / 4, seg.x + seg.w - 30, seg.y + (seg.h / 4) * 3);

                        popMatrix();
                    }
                    if(player.level < floorNum) {
                        var options = seg.options;
                        for(var q = 0; q < options.length; q++) {
                            var innerW = seg.w - 60;
                            var x = (seg.x + seg.w / 2) + (innerW / options.length) * (q - (options.length - 1) / 2);
                            var y = seg.y + seg.h / 2;
                            var realY = y - tower.scroll;

                            if(player.level + 1 === floorNum) {
                                if(dist(msx, msy, x, realY) <= 30) {
                                    seg.pops[q] = lerp(seg.pops[q], 1, 0.1);
                                    cursor(HAND);
                                    if(clicked) {
                                        clicked = false;
                                        if(tower.confirming !== q) {
                                            tower.confirming = q;
                                            tower.confirmAnim = 0;
                                        } else {
                                            tower.confirming = false;
                                            switch(options[q]) {
                                                case "fight":
                                                    initFight();
                                                    break;
                                                case "boss fight":
                                                    initFight(true);
                                                    break;
                                                case "merchant":
                                                    initMerchant();
                                                    break;
                                                case "rest":
                                                    initRest();
                                                    break;
                                            }
                                        }
                                    }

                                } else if(tower.confirming === q) {
                                    seg.pops[q] = lerp(seg.pops[q], 1, 0.1);

                                } else {
                                    seg.pops[q] = lerp(seg.pops[q], 0, 0.1);
                                }
                            }

                            pushMatrix();
                            translate(x, y);
                            pushMatrix();
                            var p1 = seg.pops[q] * 0.5;
                            var p2 = sin(frameCount * 6 - q * 90) * 0.05 + 0.05;
                            if(p1 > p2) {
                                scale(1 + p1);
                            } else {
                                scale(1 + p2);
                            }

                            // symbols
                            switch(options[q]) {
                                case "fight":
                                    //{
                                    pushMatrix();
                                    scale(0.6);
                                    translate(0, -15);
                                    noStroke();
                                    fill(184, 0, 0);
                                    beginShape();
                                    vertex(-24, 10);
                                    vertex(-4, 50);
                                    vertex(-1, 20);
                                    endShape();
                                    beginShape();
                                    vertex(24, 10);
                                    vertex(4, 50);
                                    vertex(1, 20);
                                    endShape();
                                    beginShape();
                                    vertex(0, 18);
                                    vertex(24, 5);
                                    vertex(9, -3);
                                    vertex(-9, -3);
                                    vertex(-24, 5);
                                    endShape();
                                    beginShape();
                                    vertex(29, 5);
                                    vertex(22, 20);
                                    vertex(40, 0);
                                    vertex(18, -33);
                                    endShape();
                                    beginShape();
                                    vertex(-29, 5);
                                    vertex(-22, 20);
                                    vertex(-40, 0);
                                    vertex(-18, -33);
                                    endShape();
                                    popMatrix();
                                    //}
                                    break;
                                case "boss fight":
                                    //{
                                    pushMatrix();
                                    scale(0.6);
                                    translate(0, -15);
                                    noStroke();
                                    fill(242, 0, 255);
                                    beginShape();
                                    vertex(0, 18 + 5);
                                    vertex(16, 15);
                                    vertex(20, 5);
                                    vertex(9, -3);
                                    vertex(-9, -3);
                                    vertex(-20, 5);
                                    vertex(-16, 15);
                                    endShape();

                                    fill(184, 0, 0);
                                    beginShape();
                                    vertex(-24, 10);
                                    vertex(-11, 44);
                                    vertex(-1, 20);
                                    endShape();
                                    beginShape();
                                    vertex(24, 10);
                                    vertex(11, 44);
                                    vertex(1, 20);
                                    endShape();

                                    beginShape();
                                    vertex(0, 18);
                                    vertex(24, 5);
                                    vertex(9, -3);
                                    vertex(-9, -3);
                                    vertex(-24, 5);
                                    endShape();

                                    beginShape();
                                    vertex(29, 5);
                                    vertex(22, 20);
                                    vertex(40, 0);
                                    vertex(12, -60);
                                    endShape();
                                    beginShape();
                                    vertex(-29, 5);
                                    vertex(-22, 20);
                                    vertex(-40, 0);
                                    vertex(-12, -60);
                                    endShape();
                                    beginShape();
                                    vertex(-48, 5);
                                    vertex(-23, 26);
                                    vertex(-60, 11);
                                    vertex(-40, -30);
                                    endShape();
                                    endShape();
                                    beginShape();
                                    vertex(48, 5);
                                    vertex(23, 26);
                                    vertex(60, 11);
                                    vertex(40, -30);
                                    endShape();
                                    beginShape();
                                    vertex(-14, 45);
                                    vertex(-24, 34);
                                    vertex(-41, 31);
                                    vertex(-4, 67);
                                    endShape();
                                    beginShape();
                                    vertex(14, 45);
                                    vertex(25, 34);
                                    vertex(41, 31);
                                    vertex(4, 67);
                                    endShape();
                                    popMatrix();
                                    //}
                                    break;
                                case "merchant":
                                    //{

                                    pushMatrix();

                                    scale(0.75);
                                    translate(0, -30);
                                    noStroke();
                                    fill(0, 184, 147);
                                    beginShape();
                                    vertex(0, 0);
                                    vertex(5, 5);
                                    vertex(0, 50);
                                    vertex(-5, 5);
                                    endShape();

                                    beginShape();
                                    vertex(12, 60);
                                    vertex(0, 52);
                                    vertex(-12, 60);
                                    endShape();

                                    beginShape();
                                    vertex(-25, 20);
                                    vertex(-35, 10);
                                    vertex(-25, 15);
                                    vertex(0, 10);
                                    vertex(25, 15);
                                    vertex(35, 10);
                                    vertex(25, 20);
                                    vertex(0, 15);
                                    endShape();
                                    beginShape();

                                    vertex(-18, 40);
                                    vertex(-25, 20);
                                    vertex(-15, 40);
                                    vertex(-20, 45);
                                    vertex(-30, 45);
                                    vertex(-35, 40);
                                    endShape();
                                    beginShape();
                                    vertex(15, 40);
                                    vertex(20, 45);
                                    vertex(30, 45);
                                    vertex(35, 40);
                                    vertex(25, 20);
                                    vertex(32, 40);
                                    endShape();
                                    popMatrix();
                                    //}
                                    break;
                                case "rest":
                                    //{
                                    pushMatrix();
                                    translate(0, -16);
                                    noStroke();
                                    fill(179, 98, 22);

                                    rect(-25, 8, 50, 4);
                                    rect(-25, 1, 50, 4);
                                    beginShape();
                                    vertex(-25, 15);
                                    vertex(25, 15);
                                    vertex(30, 20);
                                    vertex(-30, 20);
                                    endShape();
                                    beginShape();
                                    vertex(30, 22);
                                    vertex(25, 22);
                                    vertex(17, 35);
                                    vertex(19, 37);
                                    endShape();
                                    beginShape();
                                    vertex(20, 22);
                                    vertex(15, 22);
                                    vertex(8, 33);
                                    endShape();
                                    beginShape();
                                    vertex(-30, 22);
                                    vertex(-25, 22);
                                    vertex(-17, 35);
                                    vertex(-19, 37);
                                    endShape();
                                    beginShape();
                                    vertex(-20, 22);
                                    vertex(-15, 22);
                                    vertex(-8, 33);
                                    endShape();
                                    popMatrix();
                                    //}
                                    break;
                            }
                            popMatrix();

                            if(tower.confirming === q && player.level + 1 === floorNum) {
                                scale(tower.confirmAnim);
                                if(options[q] === 'boss fight') {
                                    scale(1.5);
                                }
                                textSize(20);
                                textAlign(CENTER, BASELINE);
                                text(capitalize(options[q]), 0, -50);
                                textSize(10);
                                text("Click to Confirm", 0, 50);
                            }

                            popMatrix();
                        }
                    }
                }

                //}

                if(tower.confirming || tower.confirming === 0) {
                    if(clicked) {
                        tower.confirming = false;
                    }
                    tower.confirmAnim = lerp(tower.confirmAnim, 1, 0.1);
                }

                pushMatrix();
                translate(0, tower.scroll);
                translate(0, (1 - tower.indicatorAnim) * 200);
                fill(125, 125, 125, 230);
                noStroke();
                rect(200, 500, 200, 80, 5);
                fill(107, 35, 106);
                textSize(20);
                textAlign(CENTER, BASELINE);
                text("Current Floor", 300, 530);
                stroke(107, 35, 106);
                strokeWeight(5);
                line(300, 543, 300, 570);
                line(290, 560, 300, 570);
                line(310, 560, 300, 570);
                popMatrix();
                if(player.level === 0 && player.curTower === 0) {
                    pushMatrix();
                    translate(0, tower.scroll);
                    fill(125, 125, 125, 230);
                    noStroke();
                    rect(70, 230, 460, 80, 5);
                    fill(107, 35, 106);
                    textSize(20);
                    textAlign(CENTER, BASELINE);
                    text("Select one option on each floor.\nMake it to the final floor.", 300, 262);
                    popMatrix();
                }

                if(!tower.dragging) {
                    if(mouseIsPressed) {
                        tower.dragging = true;
                        tower.onDrag = msy;
                    }
                } else {
                    if(!mouseIsPressed || clicked) {
                        tower.dragging = false;
                    } else {
                        cursor('grabbing');
                        if(msy !== tower.onDrag) {
                            var amt = (tower.onDrag - msy);
                            tower.scroll += amt / 2;
                            tower.toScroll += amt;
                            tower.onDrag = msy;
                        }
                    }
                }

                tower.toScroll = constrain(tower.toScroll, 0, (600 * towerSegments.length) - towerSegments[towerSegments.length - 1].yDis - 600);

                tower.scroll = lerp(tower.scroll, tower.toScroll, 0.1);

                popMatrix();

                levelInfo();

                deckButton.x = 50;
                deckButton.y = 120;
                deckButton.draw();

                pushMatrix();
                player.x = 500;
                if(tower.scroll < 600) {
                    player.y = 500;
                } else {
                    player.y = 150;
                    translate(0, 20 * player.infoAnim);
                }
                drawPlayer(true);
                if(dist(msx, msy, player.x, player.y) <= 50) {
                    infoCard(player);
                    player.infoDraw = true;
                } else {
                    infoCard(player, true);
                }
                if(player.infoAnim > 0) {
                    player.infoDraw = true;
                }

                popMatrix();

            }

            if(scene !== "map") {
                snapshotBg = get(0, 0, 600, 600);
            }
        }
        break;
        // resting
        case "rest": {
            background(91, 96, 143);
            pushMatrix();
            noStroke();
            // rotate(-30+sin(frameCount*(3/8))*10);
            var n = 8;
            for(var i = 0; i < n; i++) {
                fill(105, 40 + i * 8, 0);
                rect(-400, (sin(frameCount * (3 / 2)) - 1) * 20 + i * 110, 1000, 200);
            }
            popMatrix();

            if(tower.restReward) {
                player.restAnim = lerp(player.restAnim, 1, 0.1) || 0;
            } else {
                player.restAnim = lerp(player.restAnim, 0, 0.1) || 0;
            }
            pushMatrix();
            translate(300, 300 - (1 - player.restAnim) * 400 + (sin(frameCount * 6) * 5 * max(player.restAnim * 2 - 1, 0)));
            stroke(145, 106, 20);
            strokeWeight(5);
            fill(176, 176, 176);
            rect(-120, -50, 240, 90, 5);
            fill(145, 106, 20);
            textSize(25);
            textAlign(CENTER, BASELINE);
            text("Choose One", 0, 0);
            popMatrix();

            if(tower.choosingUpgrade) {
                tower.choosingUpgrade = false;
                if(selected) {
                    tower.upgradeAnim = 1;
                    tower.upgradedCard = selected;
                    tower.upgradeAnimation = true;
                } else {
                    tower.restReward = true;
                }
            }

            upgradeButton.draw();
            healButton.draw();

            levelInfo();

            deckButton.x = 50;
            deckButton.y = 120;
            deckButton.draw();

            pushMatrix();
            if(tower.healAnim) {
                player.x = 300;
                player.y = 300;
            } else {
                player.x = 500;
                player.y = 150;
                translate(0, 20 * player.infoAnim);
            }

            drawPlayer(true);

            if(dist(msx, msy, player.x, player.y) <= 50) {
                infoCard(player);
                player.infoDraw = true;
            } else {
                infoCard(player, true);
            }
            if(player.infoAnim > 0) {
                player.infoDraw = true;
            }

            if(tower.healAnim) {
                if(dist(300, 300, player.dx, player.dy) < 30) {
                    var w = (1 - tower.healAnim) * 1000;
                    if(tower.healAnim < 0.9) {
                        player.integrity = player.maxIntegrity;
                        tower.healAnim = lerp(tower.healAnim, 0, 0.1);
                        if(tower.healAnim < 0.001) {
                            if(merchant.rested) {
                                initMerchant(true);
                            } else {
                                initMap();
                            }
                        }
                    } else {
                        player.integrity = round(tower.startingHeal + (player.maxIntegrity - tower.startingHeal) * ((1 - tower.healAnim) / 0.1));
                        tower.healAnim -= 0.001;
                        w += sin(frameCount * 12) * 5;
                    }
                    noStroke();
                    var a = 200 + 55 * (1 - tower.healAnim);
                    fill(230, 204, 101, a);
                    ellipse(player.dx, player.dy, w, w);
                }
            }
            if(tower.upgradeAnim) {
                var card = tower.upgradedCard;
                card.x = 300;
                card.y = 300;
                card.draw();

                if(dist(300, 300, card.dx, card.dy) < 30) {
                    var w = (1 - tower.upgradeAnim) * 1000;
                    if(tower.upgradeAnim < 0.9) {
                        tower.upgradeAnim = lerp(tower.upgradeAnim, 0, 0.1);
                        if(tower.upgradeAnim < 0.001) {
                            if(merchant.rested) {
                                initMerchant(true);
                            } else {
                                initMap();
                            }
                        }
                        if(tower.upgradeAnimation) {
                            tower.upgradeAnimation = false;
                            card.pop = 1.5;
                            upgradeCard(card);
                        }
                    } else {
                        tower.upgradeAnim -= 0.001;
                        if(card.pop < 1 + (1 - tower.upgradeAnim) * 0.48) {
                            card.pop = 1.1 + (1 - tower.upgradeAnim) * 4;
                        }
                        w += cos(((1 - tower.upgradeAnim) / 0.001) * 24) * 5;
                    }
                    noStroke();
                    var a = 200 + 55 * (1 - tower.upgradeAnim);
                    for(var i = 0; i < 5; i++) {
                        var w2 = w - i * 100;
                        if(w2 > 0) {
                            fill(230 - i * 50 * tower.upgradeAnim, 101 - i * 50 * tower.upgradeAnim, 217 - i * 120 * tower.upgradeAnim, a);
                            ellipse(card.dx, card.dy, w2, w2);
                        }
                    }

                }
            }

            popMatrix();

            if(scene !== "rest") {
                snapshotBg = get(0, 0, 600, 600);
            }
        }
        break;
        // merchant
        case "merchant": {
            background(89, 156, 128);
            pushMatrix();
            noStroke();
            var n = 4;
            for(var i = 0; i < n; i++) {
                fill(89 + i * (20 + sin(frameCount * (3 / 2)) * 5), 156, 128);
                ellipse(300, 300, 900 - i * (800 / n), 900 - i * (800 / n));
            }
            popMatrix();

            if(merchant.trimming) {
                if(selected) {
                    if(player.deck.indexOf(selected) >= 0) {
                        player.deck.splice(player.deck.indexOf(selected), 1);
                    }
                }
                merchant.trimming = false;
            }

            player.restAnim = lerp(player.restAnim, 1, 0.05) || 0;
            pushMatrix();
            translate(300, 70 - (1 - player.restAnim) * 200 + (sin(frameCount * 6) * 5 * max(player.restAnim * 2 - 1, 0)));
            stroke(145, 106, 20);
            strokeWeight(5);
            fill(176, 176, 176);
            rect(-80, -42, 160, 70, 5);
            fill(145, 106, 20);
            textSize(25);
            textAlign(CENTER, BASELINE);
            text("Merchant", 0, 0);
            popMatrix();

            levelInfo();

            deckButton.x = 50;
            deckButton.y = 120;
            deckButton.draw();

            var toDraw = [];
            var hovered = false;

            if(merchant.selected) {
                pushMatrix();
                fill(38, 255, 0);
                if(merchant.selected === 'rest') {
                    merchant.selectedAnim = lerp(merchant.selectedAnim, 1, 0.1) || 0;
                    fill(38, 255, 0, 255 * merchant.selectedAnim);
                    translate(merchantRestButton.x, merchantRestButton.y + 35 * merchant.selectedAnim);
                } else if(merchant.selected === 'trim') {
                    merchant.selectedAnim = lerp(merchant.selectedAnim, 1, 0.1) || 0;
                    fill(38, 255, 0, 255 * merchant.selectedAnim);
                    translate(trimDeckButton.x, trimDeckButton.y + 70 * merchant.selectedAnim);
                } else {
                    translate(merchant.selected.dx, merchant.selected.dy + ((merchant.selected.dy > 380) ? (merchant.selectedAnim * 105) : (-merchant.selectedAnim * 100)));
                }

                textSize(10);
                textAlign(CENTER, BASELINE);
                text("Click to Purchase", 0, 0);
                popMatrix();
            }

            var numInRow = 4;
            var xl = min(merchant.cards.length - 1, numInRow - 1);

            for(var i = 0; i < merchant.cards.length; i++) {
                var card = merchant.cards[i];
                var xi = i % numInRow;
                var yi = floor(i / numInRow);

                var x = 300 + (-(xl) / 2 + xi) * min(140, (200 / ((xl) / 2)));
                var y = 300 + yi * 160;
                card.x = x;
                card.y = y;
                if(card.hovered()) {
                    cursor(HAND);
                    hovered = card;
                }
                if(merchant.selected === card) {
                    card.toPop = 1.1;
                    merchant.selectedAnim = lerp(merchant.selectedAnim, 1, 0.1) || 0;
                }
                toDraw.push(card);
            }

            for(var i = 0; i < toDraw.length; i++) {

                if(toDraw[i] !== hovered) {
                    toDraw[i].draw();
                }
            }

            if(hovered) {
                if(merchant.selected === hovered) {
                    hovered.toPop = 1.15;
                    if(clicked) {
                        if(player.credits >= merchant.selected.merchantCost) {
                            player.credits -= merchant.selected.merchantCost;
                            player.deck.push(merchant.selected);
                            merchant.cards.splice(merchant.cards.indexOf(merchant.selected), 1);
                            merchant.animBuy = merchant.selected;
                            merchant.selected = false;
                        } else {
                            merchant.notEnoughCreditsAnim = 1;
                        }
                    }
                } else {
                    hovered.toPop = 1.05;
                    if(clicked) {
                        merchant.selected = hovered;
                        merchant.selectedAnim = 0;
                    }
                }
                hovered.draw();
            } else {
                if(clicked && merchant.selected && !merchantRestButton.hovered && !trimDeckButton.hovered) {
                    merchant.selected = false;
                    merchant.notEnoughCreditsAnim = 0;
                    merchant.selectedAnim = 0;
                }
            }

            if(merchant.animBuy) {
                merchant.animBuy.x = -200;
                merchant.animBuy.y = 100;
                merchant.animBuy.draw();
                if(merchant.animBuy.dx < -100) {
                    merchant.animBuy = false;
                }
            }

            for(var i = 0; i < merchant.cards.length; i++) {
                pushMatrix();
                translate(merchant.cards[i].dx + 45, merchant.cards[i].dy - 67);
                scale(0.5);
                scale(0.9 + (merchant.cards[i].pop - 0.9) * 5);
                stroke(176, 137, 10);
                strokeWeight(5);
                fill(245, 190, 27);
                rect(-20, -20, 40, 40, 5);

                if(merchant.cards[i] === merchant.selected && merchant.notEnoughCreditsAnim) {
                    merchant.notEnoughCreditsAnim = lerp(merchant.notEnoughCreditsAnim, 0, 0.2);
                    if(merchant.notEnoughCreditsAnim <= 0.001) {
                        merchant.notEnoughCreditsAnim = 0;
                    }

                    var a = merchant.notEnoughCreditsAnim;
                    rotate(sin(frameCount * a) * 5);
                    translate(cos(frameCount * a * 2) * 3 * a, sin(frameCount * a * 2) * 3 * a);
                    fill(245, 76, 30, 255 * a);
                    rect(-20, -20, 40, 40, 5);
                }

                fill(105, 85, 12);
                textSize(23);
                textAlign(CENTER, BASELINE);
                text(merchant.cards[i].merchantCost, 0, 8);
                popMatrix();
            }

            if(1 - player.restAnim > 0.0001) {
                merchantRestButton.x = 500 + 400 * (1 - player.restAnim);
                trimDeckButton.x = 130 - 400 * (1 - player.restAnim);
            } else {
                merchantRestButton.x = 500;
                trimDeckButton.x = 130;
            }
            merchantRestButton.draw();

            trimDeckButton.draw();

            pushMatrix();
            translate(merchantRestButton.x + 40, merchantRestButton.y - 25);
            scale(0.5);
            scale(1.4 + (merchantRestButton.anim) * 0.23);
            stroke(176, 137, 10);
            strokeWeight(5);
            fill(245, 190, 27);
            rect(-20, -20, 40, 40, 5);

            if('rest' === merchant.selected && merchant.notEnoughCreditsAnim) {
                merchant.notEnoughCreditsAnim = lerp(merchant.notEnoughCreditsAnim, 0, 0.2);
                if(merchant.notEnoughCreditsAnim <= 0.01) {
                    merchant.notEnoughCreditsAnim = 0;
                }

                var a = merchant.notEnoughCreditsAnim;
                rotate(sin(frameCount * a) * 5);
                translate(cos(frameCount * a * 2) * 3 * a, sin(frameCount * a * 2) * 3 * a);
                fill(245, 76, 30, 255 * a);
                rect(-20, -20, 40, 40, 5);
            }

            fill(105, 85, 12);
            textSize(23);
            textAlign(CENTER, BASELINE);
            text(merchant.restCost, 0, 8);
            popMatrix();

            pushMatrix();
            translate(trimDeckButton.x + 10 + 20 * trimDeckButton.anim, trimDeckButton.y + 25 + 13 * trimDeckButton.anim);
            scale(0.5);
            scale(1.4 + (trimDeckButton.anim) * 0.23);
            stroke(176, 137, 10);
            strokeWeight(5);
            fill(245, 190, 27);
            rect(-20, -20, 40, 40, 5);

            if('trim' === merchant.selected && merchant.notEnoughCreditsAnim) {
                merchant.notEnoughCreditsAnim = lerp(merchant.notEnoughCreditsAnim, 0, 0.2);
                if(merchant.notEnoughCreditsAnim <= 0.01) {
                    merchant.notEnoughCreditsAnim = 0;
                }

                var a = merchant.notEnoughCreditsAnim;
                rotate(sin(frameCount * a) * 5);
                translate(cos(frameCount * a * 2) * 3 * a, sin(frameCount * a * 2) * 3 * a);
                fill(245, 76, 30, 255 * a);
                rect(-20, -20, 40, 40, 5);
            }

            fill(105, 85, 12);
            textSize(23);
            textAlign(CENTER, BASELINE);
            text(merchant.trimCost, 0, 8);
            popMatrix();

            pushMatrix();
            translate(360, 150);
            stroke(176, 137, 10);
            strokeWeight(5);
            fill(245, 190, 27);
            rect(-40, -20, 80, 40, 5);
            fill(105, 85, 12);
            textSize(23);
            textAlign(CENTER, BASELINE);
            text(player.credits, 0, 8);
            text("Credits:", -105, 8);
            popMatrix();

            pushMatrix();
            player.x = 500;
            player.y = 130;
            translate(0, 40 * player.infoAnim);

            player.credits = round(player.credits);

            drawPlayer(true);

            if(dist(msx, msy, player.x, player.y) <= 50) {
                infoCard(player);
                player.infoDraw = true;
            } else {
                infoCard(player, true);
            }
            if(player.infoAnim > 0) {
                player.infoDraw = true;
            }

            popMatrix();

            leaveMerchantButton.draw();

            if(scene !== "merchant") {
                snapshotBg = get(0, 0, 600, 600);
            }
        }
        break;
        // enemy encounter
        case "fight": {

            pushMatrix();
            noStroke();
            var n = 8;
            if(player.level === towerSegments.length - 1) {
                rotate(-30 + sin(frameCount * (3 / 8)) * 10);
                // translate(0,80);
                n = 10;
            }
            for(var i = 0; i < n; i++) {
                if(player.level !== towerSegments.length - 1) {
                    fill(160, 100 - i * (100 / n), 100 - i * (100 / n));
                } else {
                    fill(60, 100 - i * (100 / n), 100 - i * (100 / n));
                }
                rect(-400, (sin(frameCount * (3 / 2) + i * (360 / n)) - 1) * 10 + i * 80 - 80, 1000, 200);
            }
            popMatrix();

            m.hover = false;

            var infoHover = false;

            // println('c');
            pushMatrix();
            player.x = 100;
            player.y = 300;
            if(dist(msx, msy, player.x, player.y) <= 50) {
                infoHover = player;
                player.infoDraw = true;
            }
            if(player.infoAnim > 0) {
                player.infoDraw = true;
            }

            drawPlayer();
            popMatrix();

            var targeted = false;

            for(var i = 0; i < enemies.length; i++) {
                var enemy = enemies[i];
                enemy.x = 380 + (-(enemies.length - 1) / 2 + i) * min(120, (130 / ((enemies.length - 1) / 2)));
                enemy.y = 300;

                if(abs(msx - enemy.x) <= 50 && msy <= enemy.y + 50 && msy >= enemy.y - (enemy.data.height || 60)) {
                    enemy.hoveredFor += tMillis;
                    if(enemy.integrity > 0) {
                        if(m.hold && !targeted) {
                            targeted = enemy;
                        }
                    }
                    if(((!m.hold || enemy.hoveredFor > 800) && !stack[0]) && !infoHover) {
                        infoHover = enemy;
                        enemy.infoDraw = true;
                    }
                } else {
                    enemy.hoveredFor = 0;
                }
                if(enemy.infoAnim > 0) {
                    enemy.infoDraw = true;
                }
                enemy.draw();
            }

            var toDraw = [];

            for(var i = 0; i < player.cyberware.length; i++) {
                var card = player.cyberware[i];
                card.toPop = 0.4;
                var x = 100 + (-(player.cyberware.length - 1) / 2 + i) * min(50, (50 / ((player.cyberware.length - 1) / 2)));
                var y = player.dy - player.data.height;
                if(card !== m.hold) {
                    card.x = x;
                    card.y = y;
                    if(card.hovered() && !m.hold) {
                        if(!m.hover || dist(msx, msy, x, y) < dist(msx, msy, m.hover.x, m.hover.y)) {
                            m.hover = card;
                        }
                    }
                    toDraw.push(card);
                }

                if(card.data.staticPower) {
                    card.data.staticPower(card);
                }
            }

            stroke(79, 79, 79);
            strokeWeight(5);
            fill(184, 184, 184);
            beginShape();
            vertex(-50, 650);
            vertex(-50, 450);
            vertex(100, 400);
            vertex(500, 400);
            vertex(650, 450);
            vertex(650, 650);
            endShape(CLOSE);

            pushMatrix();
            translate(0, 4);
            noFill();
            stroke(227, 22, 227);
            strokeWeight(5);
            beginShape();
            vertex(-50, 650);
            vertex(-50, 450);
            vertex(100, 400);
            vertex(500, 400);
            vertex(650, 450);
            vertex(650, 650);
            endShape();
            translate(0, 4);
            noFill();
            stroke(79, 79, 79);
            strokeWeight(5);
            beginShape();
            vertex(-50, 650);
            vertex(-50, 450);
            vertex(100, 400);
            vertex(500, 400);
            vertex(650, 450);
            vertex(650, 650);
            endShape();
            popMatrix();

            for(var i = 0; i < player.hand.length; i++) {
                var card = player.hand[i];
                var x = 300 + (-(player.hand.length - 1) / 2 + i) * min(110, (150 / ((player.hand.length - 1) / 2)));
                var y = 500;
                if(card !== m.hold) {
                    card.x = x;
                    card.y = y;
                    if(card.hovered() && !m.hold) {
                        // if(!m.hover){
                        m.hover = card;
                        cursor("grab");
                        // }
                    }
                    toDraw.push(card);
                }
                card.anchorX = x;
                card.anchorY = y;

                if(card.data.staticHandEffect) {
                    card.data.staticHandEffect(card);
                }
            }

            if(m.hover && player.hand.indexOf(m.hover) >= 0) {
                if(selectInput()) {
                    m.hold = m.hover;
                }
            }

            // card rewards
            if(player.win) {
                for(var i = 0; i < tower.cardRewards.length; i++) {
                    var card = tower.cardRewards[i];
                    var x = 400 + (-(tower.cardRewards.length - 1) / 2 + i) * min(110, (140 / ((tower.cardRewards.length - 1) / 2)));
                    var y = 260;
                    card.x = x;
                    card.y = y;
                    if(card.hovered() && !tower.cardRewardSelected) {
                        cursor(HAND);
                        // if(!m.hover){
                        m.hover = card;
                        // }

                    }
                    toDraw.push(card);
                }
                if(m.hover && tower.cardRewards.indexOf(m.hover) >= 0) {
                    var card = m.hover;
                    if(clicked) {
                        player.deck.push(card);
                        tower.cardRewardSelected = true;
                        for(var q = tower.cardRewards.length - 1; q > -1; q--) {
                            if(tower.cardRewards[q] !== card) {
                                discarding.push(tower.cardRewards[q]);
                                tower.cardRewards.splice(q, 1);
                            }
                        }
                    }
                }
            }

            for(var i = 0; i < toDraw.length; i++) {
                if(toDraw[i] !== m.hover && toDraw[i] !== stack[0]) {
                    toDraw[i].draw();
                }
            }

            for(var i = discarding.length - 1; i > -1; i--) {
                discarding[i].toPop = 0.5;
                discarding[i].x = 800;
                discarding[i].y = 500;
                discarding[i].draw();
                if(discarding[i].dx > 750) {
                    discarding.splice(i, 1);
                }
            }
            for(var i = drawAdding.length - 1; i > -1; i--) {
                drawAdding[i].toPop = 0.5;
                drawAdding[i].x = -200;
                drawAdding[i].y = 500;
                drawAdding[i].draw();
                if(drawAdding[i].dx < -150) {
                    drawAdding.splice(i, 1);
                }
            }

            if(m.hover) {
                m.hover.toPop = 1.05;
                m.hover.draw();
            }

            if(m.hold) {
                m.hold.toPop = 1.1;

                if(!m.hold.data.noTarget) {
                    var weight = 10;
                    m.hold.x = (msx + m.hold.anchorX * weight) / (weight + 1);
                    m.hold.y = (msy + m.hold.anchorY * weight) / (weight + 1);
                    noFill();
                    stroke(0, 230, 42);
                    strokeWeight(5);
                    var d = dist(msx, msy, m.hold.dx, m.hold.dy) / 3;
                    m.hold.lastArrowD = d;
                    if(!m.arrowTail) {
                        m.arrowTail = {
                            x: msx,
                            y: msy - d
                        };
                    }
                    var x = msx;
                    var y = msy - d;
                    if(targeted) {
                        x = targeted.x;
                        y = targeted.y - (targeted.data.height || 60) - 20;
                    }
                    m.arrowTail.x = lerp(m.arrowTail.x, x, 0.2);
                    m.arrowTail.y = lerp(m.arrowTail.y, y, 0.2);
                    drawDashedArc({
                        x: m.hold.dx,
                        y: m.hold.dy
                    }, m.arrowTail, d, msy - d < m.hold.dy ? -1 : 1);

                    var index = player.hand.indexOf(m.hold);
                    player.hand.splice(index, 1);
                    player.hand.splice(floor((player.hand.length + 1) / 2), 0, m.hold);

                } else {
                    var weight = 2;
                    m.hold.x = (msx * weight + m.hold.anchorX) / (weight + 1);
                    m.hold.y = (msy * weight + m.hold.anchorY) / (weight + 1);
                    if(msy <= 400) {
                        m.hold.toPop = 0.8;
                    }

                    var index = player.hand.indexOf(m.hold);
                    if(index >= 0) {

                        var toLeft = 0;
                        for(var i = 0; i < player.hand.length; i++) {
                            if((((index > i) && (m.hold.x > player.hand[i].x)) || ((index <= i) && (m.hold.x >= player.hand[i].x))) && player.hand[i] !== m.hold) {
                                toLeft++;
                            }

                        }
                        player.hand.splice(player.hand.indexOf(m.hold), 1);
                        player.hand.splice(toLeft, 0, m.hold);
                    }
                }

                m.hold.draw();
            } else {
                m.arrowTail = false;
            }

            if(attacks[0]) {
                stackTimer += tMillis;
                if(stackTimer >= 500) {
                    stackTimer = 0;
                    if(attacks[0].integrity > 0) {
                        attacks[0].animStep++;
                        if(attacks[0].data.attacks[attacks[0].selectedAttack].effect[attacks[0].animStep]) {
                            attacks[0].data.attacks[attacks[0].selectedAttack].effect[attacks[0].animStep](attacks[0].data.attacks[attacks[0].selectedAttack], attacks[0]);
                        } else {
                            attacks.splice(0, 1);
                        }
                    } else {
                        attacks.splice(0, 1);
                    }
                    if(!attacks[0]) {
                        initTurn();
                    }
                }
            }

            if(stack[0]) {

                var index = player.hand.indexOf(stack[0]);
                if(index >= 0) {
                    player.hand.splice(index, 1);
                }
                stack[0].x = 300;
                stack[0].y = 500;
                if(!stack[0].data.noTarget) {
                    noFill();
                    stroke(230, 0, 0);
                    strokeWeight(5);
                    drawDashedArc({
                        x: stack[0].dx,
                        y: stack[0].dy
                    }, {
                        x: stack[0].target.x,
                        y: stack[0].target.y - (stack[0].target.data.height || 60) - 20
                    }, stack[0].lastArrowD || 60, -1);
                }
                stack[0].toPop = 1.2;
                stack[0].draw();

                stackTimer += tMillis;
                if(stackTimer >= 500) {
                    stack[0].animStep++;
                    stackTimer = 0;
                    if(stack[0].data.effect[stack[0].animStep]) {
                        stack[0].data.effect[stack[0].animStep](stack[0]);
                    } else {

                        player.energy -= stack[0].cost;
                        if(stack[0].data.type === "cyberware") {
                            player.cyberware.push(stack[0]);
                        } else {
                            if((stack[0].data.exhaust || stack[0].exhaust) && (!stack[0].data.exhaustOverride || (!stack[0].data.exhaustOverride(stack[0])))) {
                                deleteCard(stack[0]);
                            } else {
                                discarding.push(stack[0]);
                                player.discard.push(stack[0]);
                            }
                        }
                        var card = stack[0];
                        stack.splice(0, 1);

                        managePowers(player, "cardPlayed", {
                            card: card
                        });

                        checkDeaths();

                        // safety to make sure next in que is valid
                        if(stack[0]) {
                            if(player.energy < stack[0].cost) {
                                stack.splice(0, 1);
                                player.notEnoughEnergyAnim = 1;
                            }
                        }
                    }
                }
            }

            drawButton.draw();

            discardButton.draw();

            pushMatrix();

            translate(30, 450);
            translate(20, 20);
            var a = 0.5 * (1 + player.notEnoughEnergyAnim);
            var a2 = a * 360 * 8;
            rotate(cos(frameCount + a2) * 5);
            translate(cos(frameCount * 2 + a2) * 3, sin(frameCount * 2 + a2) * 3);
            translate(-20, -20);

            fill(0, 0, 0);
            textSize(30);
            textAlign(CENTER, BASELINE);

            noStroke();
            fill(205, 71, 207);

            player.dEnergy = lerp(player.dEnergy, player.energy, 0.2);
            var a = constrain(player.dEnergy / player.maxEnergy, 0, 1);
            rect(0, (1 - a) * 40, 40, a * 40, 8);
            player.notEnoughEnergyAnim = lerp(player.notEnoughEnergyAnim, 0, 0.1);
            fill(224, 47, 65, 255 * player.notEnoughEnergyAnim);
            rect(0, 0, 40, 40, 8);

            strokeWeight(5);
            stroke(0, 0, 0);
            noFill();
            rect(0, 0, 40, 40, 8);

            fill(0, 0, 0);
            text(round(player.dEnergy), 21, 31);

            popMatrix();

            endTurnButton.draw();

            for(var i = 0; i < enemies.length; i++) {
                if(enemies[i] !== infoHover) {
                    if(enemies[i].infoAnim) {
                        infoCard(enemies[i], true);
                    }
                }
            }
            if(player !== infoHover) {
                if(player.infoAnim) {
                    infoCard(player, true);
                }
            }
            if(infoHover) {
                infoCard(infoHover);
            }

            if(m.hold) {
                cursor("grabbing");
                if(clicked) {
                    if((!m.hold.data.noTarget && targeted) || (m.hold.data.noTarget && msy <= 400)) {
                        if(!attacks[0]) {
                            var index = stack.indexOf(m.hold);
                            if(index < 0) {
                                if(player.energy >= m.hold.cost) {
                                    if(!m.hold.data.condition || m.hold.data.condition(m.hold)) {
                                        m.hold.target = targeted;
                                        m.hold.animStep = -1;
                                        stack.push(m.hold);
                                    }
                                } else {
                                    player.notEnoughEnergyAnim = 1;
                                }
                            }
                        }
                    }
                    m.lastHeld = m.hold;
                    m.hold = false;

                }
                if(rclicked) {
                    m.lastHeld = m.hold;
                    m.hold = false;
                }
            }

            // check win/lose
            if(!attacks[0] && !stack[0] && !player.win) {
                if(player.integrity > 0) {
                    if(enemies.length === 0) {
                        m.hold = false;
                        player.win = true;
                        endTurn();
                        fightRewards();
                    }
                } else {
                    scene = 'lose';
                    loseAnim = 1;
                }
            }

            if(player.win) {
                player.winAnim = lerp(player.winAnim, 1, 0.1) || 0;
                pushMatrix();
                translate(400, 100 - (1 - player.winAnim) * 400 + (sin(frameCount * 6) * 5 * max(player.winAnim * 2 - 1, 0)));
                stroke(145, 106, 20);
                strokeWeight(5);
                fill(176, 176, 176);
                rect(-120, -50, 240, 90, 5);
                fill(145, 106, 20);
                textSize(25);
                textAlign(CENTER, BASELINE);
                if(tower.cardRewardSelected) {
                    text("Card Added\nTo Deck", 0, -10);
                } else {
                    text("Choose Up To\n1 Card", 0, -10);
                }
                popMatrix();

                pushMatrix();
                translate(300 + sin(frameCount * 3) * 5, 470);
                scale(player.winAnim);
                fill(224, 47, 237);
                textSize(25);
                textAlign(CENTER, BASELINE);
                text("Floor Cleared", 0, 0);
                fill(145, 106, 20);
                textSize(18);
                popMatrix();
                pushMatrix();
                translate(300, 470);
                scale(max(player.winAnim * 2 - 1, 0));
                text("+" + tower.rewardCredits + " Credits", 0, 30);
                popMatrix();

                deckButton.x = 200;
                deckButton.y = 550 + (1 - player.winAnim) * 200;
                deckButton.draw();

                leaveFightButton.y = 550 + (1 - player.winAnim) * 400;
                leaveFightButton.draw();

            } else {

                // player.win = true;
                // enemies = [];
                // endTurn();
                // fightRewards();
                // snapshotAnim = 1.1;

                player.winAnim = false;
                if(player.curLevelFights === 3 && player.curTower === 0) {
                    pushMatrix();
                    fill(125, 125, 125, 230);
                    noStroke();
                    rect(220, 20, 360, 100, 5);
                    fill(107, 35, 106);
                    textSize(12);
                    textAlign(CENTER, BASELINE);
                    text("When your draw runs out of cards, your discard\nis shuffled and put into your draw.\n\nAll changes made to your deck during the fight\nare temporary.", 400, 48);
                    popMatrix();
                }
                if(player.curLevelFights === 2 && player.curTower === 0) {
                    pushMatrix();
                    fill(125, 125, 125, 230);
                    noStroke();
                    rect(220, 20, 360, 100, 5);
                    fill(107, 35, 106);
                    textSize(12);
                    textAlign(CENTER, BASELINE);
                    text("Hover over enemies to view useful information.\nEnemies say what they will do on their turn.\n\nChanges to enemy numbers caused by effects\nare automatically calculated and shown.", 400, 48);
                    popMatrix();
                }
                if(player.curLevelFights === 1 && player.curTower === 0) {
                    pushMatrix();
                    fill(125, 125, 125, 230);
                    noStroke();
                    rect(220, 20, 360, 100, 5);
                    fill(107, 35, 106);
                    textSize(20);
                    textAlign(CENTER, BASELINE);
                    text("Play cards from your hand.\nEnd Turn when out of energy.\nDefeat all enemies.", 400, 52);
                    popMatrix();
                }

            }

            levelInfo();

            // println('e');
            if(scene !== "fight") {
                snapshotBg = get(0, 0, 600, 600);
            }
        }
        break;
        // choosing a card from a selection or viewing a selection of cards
        case "selection": {
            image(snapshotBg, 0, 0);
            noStroke();
            fill(209, 209, 209, 200);
            rect(-100, -100, 800, 800);
            textSize(30);
            textAlign(CENTER, BASELINE);
            fill(0, 0, 0);
            text(selectionCaption, 50, 100, 500, 200);

            var hovered = false;
            var toDraw = [];

            var maxColumns = 5;
            var numInRow = floor((5 + sqrt(25 + 4 * (selection.length + 1))) / 2);

            if(numInRow < ceil(selection.length / maxColumns)) {
                numInRow = ceil(selection.length / maxColumns);
            }

            var xl = min(selection.length - 1, numInRow - 1);
            var yl = floor((selection.length - 1) / numInRow);

            for(var i = 0; i < selection.length; i++) {
                var card = selection[i];
                var xi = i % numInRow;
                var yi = floor(i / numInRow);

                var x = 300 + (-(xl) / 2 + xi) * min(110, (200 / ((xl) / 2)));
                var y = 370 + (-(yl) / 2 + yi) * min(160, (130 / ((yl) / 2)));
                card.x = x;
                card.y = y;
                if(card.hovered()) {
                    cursor(HAND);
                    hovered = card;
                }
                toDraw.push(card);
            }

            for(var i = 0; i < toDraw.length; i++) {

                if(toDraw[i] !== hovered) {
                    toDraw[i].draw();
                }
            }

            if(hovered) {
                hovered.toPop = 1.2;
                hovered.draw();
                if(clicked && !noSelection) {
                    selected = hovered;
                    scene = selectionBackTo;
                }
            }
            if(noSelection) {
                if(clicked) {
                    selected = false;
                    scene = selectionBackTo;
                }
            } else {
                if(selection.length === 0) {
                    selected = false;
                    scene = selectionBackTo;
                }
            }
        }
        break;
        // :(
        case "lose":{
            background(0, 0, 0);
            pushMatrix();
            if(loseAnim > 0) {
                var a = loseAnim;
                translate(a * 100, a * 50);
            }
            image(snapshotBg, 0, 0);
            if(loseAnim > 0) {
                var a = loseAnim;
                var img = get(a * 100, a * 50, 400, 400);
                image(img, -250 * a, -80 * a);
                loseAnim = lerp(loseAnim, 0, 0.05);

            }
            noStroke();
            fill(79, 79, 79, 200 * (1 - loseAnim));
            rect(-10, -10, 620, 620, 5);

            textAlign(CENTER, BASELINE);
            fill(255, 255, 255, 255 * (1 - loseAnim));
            textSize(15);
            text("FLATLINED", 300, 150);
            textSize(20);
            text("Tower " + (player.curTower + 1) + "\nFloor " + (player.level), 300, 180);

            deckButton.x = 300;
            deckButton.y = 300;
            deckButton.draw();

            toMenuButton.draw();

            popMatrix();
            }
        break;
        // i wonder what this is
        case "huh": {
            background(41, 9, 41);

            textAlign(CENTER, BASELINE);
            fill(255, 255, 255, 255);
            textSize(15);
            text("YOU WIN", 300, 150);
            textSize(20);
            text("Time: " + floor(totalTime / 1000) + " seconds\n\nDid you like this game?", 300, 180);

            deckButton.x = 300;
            deckButton.y = 400;
            deckButton.draw();
        }
        break;
        // :)
        case "win": {
            background(200, 0, 255);
            cursor(HAND);
            var t = ((frameCount % 200) / 10);
            pushMatrix();
            if(t < 1) {
                var a = 1 - t;
                translate(a * 100, a * 50);
            }
            noStroke();
            pushMatrix();
            rotate(-30 + sin(frameCount * (3 / 8)) * 10);
            var n = 8;
            var a = sin(frameCount * (3 / 4)) * 30;
            for(var i = 0; i < n; i++) {
                fill(200 - a, i * (185 / n) + a, 255 - i * (245 / n) + a);
                rect(-400, (sin(frameCount * (3 / 2) + i * (360 / n)) - 1) * 20 + i * 110, 1000, 200);
            }
            popMatrix();

            pushMatrix();
            translate(0, -100 + sin(frameCount * 3) * -10 + 10);
            fill(0, 0, 0);
            stroke(255, 255, 255);
            strokeWeight(10);
            //{
            beginShape();
            vertex(192, 133);
            vertex(131, 118);
            vertex(53, 165);
            vertex(37, 244);
            vertex(64, 310);
            vertex(153, 338);
            vertex(271, 357);
            vertex(160, 312);
            vertex(107, 278);
            vertex(86, 240);
            vertex(94, 194);
            vertex(142, 153);
            vertex(220, 171);
            endShape(CLOSE);
            beginShape();
            vertex(215, 195);
            vertex(207, 302);
            vertex(261, 330);
            vertex(296, 319);
            vertex(316, 281);
            vertex(282, 253);
            vertex(308, 237);
            vertex(324, 210);
            vertex(322, 184);
            vertex(267, 168);
            endShape(CLOSE);
            beginShape();
            vertex(351, 184);
            vertex(338, 348);
            vertex(372, 351);
            vertex(375, 299);
            vertex(397, 279);
            vertex(430, 291);
            vertex(539, 378);
            vertex(432, 253);
            vertex(481, 220);
            vertex(487, 173);
            vertex(433, 128);
            vertex(367, 134);
            endShape(CLOSE);
            popMatrix();
            pushMatrix();
            translate(0, sin(frameCount * 3) * 10 - 10);
            fill(0, 0, 0);
            stroke(255, 255, 255);
            strokeWeight(10);
            beginShape();
            vertex(93, 379);
            vertex(87, 508);
            vertex(73, 574);
            vertex(96, 586);
            vertex(108, 534);
            vertex(116, 464);
            vertex(183, 485);
            vertex(236, 429);
            vertex(251, 377);
            vertex(153, 343);
            endShape(CLOSE);
            beginShape();
            vertex(260, 389);
            vertex(238, 572);
            vertex(274, 580);
            vertex(286, 441);
            vertex(340, 582);
            vertex(429, 345);
            vertex(395, 338);
            vertex(349, 474);
            vertex(299, 349);
            endShape(CLOSE);
            beginShape();
            vertex(448, 353);
            vertex(373, 574);
            vertex(405, 580);
            vertex(432, 496);
            vertex(456, 488);
            vertex(520, 574);
            vertex(549, 573);
            vertex(504, 493);
            vertex(471, 455);
            vertex(456, 460);
            vertex(585, 390);
            vertex(554, 384);
            vertex(444, 440);
            vertex(488, 351);
            vertex(458, 333);
            endShape(CLOSE);
            //}
            popMatrix();

            pushMatrix();
            translate(280, 300);
            scale(1.5);
            scale(-1, 1);
            stroke(0, 0, 0);
            strokeWeight(5);
            playerGraphics();
            popMatrix();

            fill(255, 255, 255, (100 + 155 * abs(sin(frameCount * 3))) * (1 - menuAnim));
            textAlign(CENTER, BASELINE);
            textSize(20);
            text("PRESS AND HOLD TO END", 300, 300);

            noStroke();
            fill(10, 10, 87, (150) * max(0, (1 - t)));
            rect(-500, -500, 1600, 1600);
            fill(0, 0, 0, 255 * menuAnim);
            rect(-500, -500, 1600, 1600);

            if(!mouseIsPressed) {
                menuAnim = lerp(menuAnim, 0, 0.1);
            } else {
                if(menuAnim >= 0.8) {
                    var a = ["hand", "arrow", "grab", "grabbing", "move", "help", "none", "not-allowed", "text"];
                    cursor(a[floor(random(0, a.length))]);
                }

                menuAnim += tMillis / 3000;
                if(menuAnim >= 1) {
                    menuAnim = 0;
                    scene = 'huh';
                }
            }
            var n = 1 + floor(random(0, 1.03)) + floor(sin(frameCount * 3) + 1);
            for(var i = 0; i < n; i++) {
                var y = (frameCount * 4 + i * (1000 / 3)) % 1000;
                var h = (i + 1) * 20;
                var strip = get(0, y, 600, h);
                image(strip, 10, y);
            }
            if(t < 1) {
                var a = 1 - t;
                var img = get(a * 100, a * 50, 400, 400);
                image(img, -250 * a, -80 * a);
            }
            popMatrix();
        }
        break;
    }

    // animation stuff
    if(snapshotAnim < 1 && scene !== "lose" && scene !== "huh") {
        snapshotAnim = lerp(snapshotAnim, 1.001, 0.1);
        image(snapshotBg, 600, 0);
    }
    popMatrix();

    // thumbnail
    if(keyCode === 187) {
        noStroke();
        pushMatrix();
        rotate(-30);
        var n = 8;
        var a = -15;
        for(var i = 0; i < n; i++) {
            fill(200 - a, i * (185 / n) + a, 255 - i * (245 / n) + a);
            rect(-400, (-1) * 20 + i * 110, 1000, 200);
        }
        popMatrix();
        var a = 134;
        for(var i = 0; i < allEnemies.length; i++) {
            pushMatrix();
            if(allEnemies[i] !== "sentry" && allEnemies[i] !== "strider") {
                translate(600 + cos((i + a) * 1227) * 250-abs(sin((i + a) * 1206) * 260), 300 + sin((i + a) * 1206) * 260);
                scale(1 / ((enemyData[allEnemies[i]].height + 100) / 200));
                enemyData[allEnemies[i]].draw({
                    effects: {}
                });
            }
            popMatrix();
        }
        pushMatrix();
        translate(60,0);
        translate(300,300);
        scale(0.4);
        translate(-300,-300);
        pushMatrix();
        translate(0, -90);
        fill(0, 0, 0);
        stroke(255, 255, 255);
        strokeWeight(10);
        //{
        beginShape();
        vertex(192, 133);
        vertex(131, 118);
        vertex(53, 165);
        vertex(37, 244);
        vertex(64, 310);
        vertex(153, 338);
        vertex(271, 357);
        vertex(160, 312);
        vertex(107, 278);
        vertex(86, 240);
        vertex(94, 194);
        vertex(142, 153);
        vertex(220, 171);
        endShape(CLOSE);
        beginShape();
        vertex(215, 195);
        vertex(207, 302);
        vertex(261, 330);
        vertex(296, 319);
        vertex(316, 281);
        vertex(282, 253);
        vertex(308, 237);
        vertex(324, 210);
        vertex(322, 184);
        vertex(267, 168);
        endShape(CLOSE);
        beginShape();
        vertex(351, 184);
        vertex(338, 348);
        vertex(372, 351);
        vertex(375, 299);
        vertex(397, 279);
        vertex(430, 291);
        vertex(539, 378);
        vertex(432, 253);
        vertex(481, 220);
        vertex(487, 173);
        vertex(433, 128);
        vertex(367, 134);
        endShape(CLOSE);
        popMatrix();
        pushMatrix();
        translate(0, -10);
        fill(0, 0, 0);
        stroke(255, 255, 255);
        strokeWeight(10);
        beginShape();
        vertex(93, 379);
        vertex(87, 508);
        vertex(73, 574);
        vertex(96, 586);
        vertex(108, 534);
        vertex(116, 464);
        vertex(183, 485);
        vertex(236, 429);
        vertex(251, 377);
        vertex(153, 343);
        endShape(CLOSE);
        beginShape();
        vertex(260, 389);
        vertex(238, 572);
        vertex(274, 580);
        vertex(286, 441);
        vertex(340, 582);
        vertex(429, 345);
        vertex(395, 338);
        vertex(349, 474);
        vertex(299, 349);
        endShape(CLOSE);
        beginShape();
        vertex(448, 353);
        vertex(373, 574);
        vertex(405, 580);
        vertex(432, 496);
        vertex(456, 488);
        vertex(520, 574);
        vertex(549, 573);
        vertex(504, 493);
        vertex(471, 455);
        vertex(456, 460);
        vertex(585, 390);
        vertex(554, 384);
        vertex(444, 440);
        vertex(488, 351);
        vertex(458, 333);
        endShape(CLOSE);
        //}
        popMatrix();
        popMatrix();
        pushMatrix();
        translate(100, 250);
        scale(1.4);
        stroke(0, 0, 0);
        strokeWeight(4);
        playerGraphics();
        popMatrix();
    }

    } catch (e) {
        
        console.log(e);
    }

    // if(true) {
    //     var window = (function(what) {
    //         return this[what];
    //     })("window");
    //     var canvas = window.Processing.instances[0].externals.canvas;

    //     canvas.onwheel = function(event) {
    //         event.preventDefault();

    //     };
    // }
    
    // stroke(255,0,0);
    // strokeWeight(5);
    // point(msx,msy);

    // reset some mouse stuff
    m.px = msx;
    m.py = msy;
    clicked = false;
    rclicked = false;
    mclicked = false;
}

// scrolling on the map scene
mouseScrolled = function() {
    if(scene === 'map') {
        var ms = -mouseScroll * 20;
        tower.scroll += ms;
        tower.toScroll += ms;
    }
};

// manage mouse inputs
mouseClicked = function() {
    if(mouseButton === 39) {
        rclicked = true;
    } else if(mouseButton === 3) {
        mclicked = true;
    } else {
        clicked = true;
    }
}

random();

      </script>

    <script src="https://cdn.jsdelivr.net/gh/ackvonhuelio/chickenGameCodes/runPJS_onKA.js"></script>
        
   <script>
            let scaleFactor = 1;
            function resizeCanvas() {
                let canvas = document.querySelector("canvas");
                if (!canvas) return;

                scaleFactor = Math.min(window.innerWidth / 600, window.innerHeight / 700);
                canvas.style.transform =`scale(${scaleFactor})`;

                // Pass the scale factor to the PJS code
                window.scaleFactor = scaleFactor;
            }

            window.addEventListener("resize", resizeCanvas);
            window.addEventListener("load", resizeCanvas);
            window.addEventListener("orientationchange", resizeCanvas);

           let firstClick = true;

            document.addEventListener("click", function () {
            if (firstClick) {
            setTimeout(resizeCanvas, 10);
            firstClick = false;
            }
            });

            // NEW FIX: Handle weird mobile resizing when tapping
            if (window.visualViewport) {
window.visualViewport.addEventListener("resize", resizeCanvas);
            }
        </script>
        
</body>

</html>
